// Generated by Haxe 4.1.0
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var Console = function() { };
Console.__name__ = true;
Console.printlnFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	Console.printFormatted(s + "\n",outputStream);
};
Console.println = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	Console.print(s + "\n",outputStream);
};
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	s += "<//>";
	var activeFormatFlagStack = [];
	var groupedProceedingTags = [];
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var open = e.matched(1) == null;
		var tags = e.matched(2).split(",");
		if(!open && tags.length == 1) {
			if(tags[0] == "") {
				var last = activeFormatFlagStack[activeFormatFlagStack.length - 1];
				var i = activeFormatFlagStack.indexOf(last);
				if(i != -1) {
					var proceedingTags = groupedProceedingTags[i];
					activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
					groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
				}
			} else if(FormatFlag.fromString(tags[0]) == "reset") {
				activeFormatFlagStack = [];
				groupedProceedingTags = [];
			} else {
				var flag = FormatFlag.fromString(tags[0]);
				if(flag != null) {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
						groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
					}
				}
			}
		} else {
			var proceedingTags = 0;
			var _g = 0;
			while(_g < tags.length) {
				var tag = tags[_g];
				++_g;
				var flag = FormatFlag.fromString(tag);
				if(flag == null) {
					return e.matched(0);
				}
				if(open) {
					activeFormatFlagStack.push(flag);
					groupedProceedingTags.push(proceedingTags);
					++proceedingTags;
				} else {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags1 = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags1,proceedingTags1 + 1);
						groupedProceedingTags.splice(i - proceedingTags1,proceedingTags1 + 1);
					}
				}
			}
		}
		switch(Console.formatMode) {
		case 1:
			var browserFormatArguments1 = browserFormatArguments;
			var result = new Array(activeFormatFlagStack.length);
			var _g = 0;
			var _g1 = activeFormatFlagStack.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = Console.getBrowserFormat(activeFormatFlagStack[i]);
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = result;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v != null) {
					_g.push(v);
				}
			}
			browserFormatArguments1.push(_g.join(";"));
			return "%c";
		case 2:
			return "";
		}
	});
	if(Console.formatMode == 1) {
		var logArgs = [result].concat(browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(Console.printIntercept != null) {
		var allowDefaultPrint = Console.printIntercept(s,outputStream);
		if(!allowDefaultPrint) {
			return;
		}
	}
	switch(outputStream) {
	case 1:
		console.warn(s);
		break;
	case 2:
		console.error(s);
		break;
	case 0:case 3:
		console.log(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[38;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex = HxOverrides.substr(flag,3,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[48;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return "";
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g = 0;
		var _g1 = set.length;
		while(_g < _g1) {
			var i = _g++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var ier = Math.abs(r - colorSteps[ir]);
	var ieg = Math.abs(g - colorSteps[ig]);
	var ieb = Math.abs(b - colorSteps[ib]);
	var averageColorError = ier + ieg + ieb;
	var jr = Math.round((r - 8) / 10);
	var jg = Math.round((g - 8) / 10);
	var jb = Math.round((b - 8) / 10);
	var jer = Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8));
	var jeg = Math.abs(g - Math.max(Math.min(jg * 10 + 8,238),8));
	var jeb = Math.abs(b - Math.max(Math.min(jb * 10 + 8,238),8));
	var averageGrayError = jer + jeg + jeb;
	if(averageGrayError < averageColorError && r == g && g == b) {
		var grayIndex = jr + 232;
		return grayIndex;
	} else {
		var colorIndex = 16 + ir * 36 + ig * 6 + ib;
		return colorIndex;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return "";
	}
};
Console.determineConsoleFormatMode = function() {
	var hasWindowObject = typeof(window) != "undefined";
	if(hasWindowObject) {
		return 1;
	}
	return 2;
};
Console.joinArgs = function(rest) {
	var msg = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString("",haxe_macro_StringLiteralKind.SingleQuotes)), pos : { file : "D:\\Dokumente\\GitHub\\snekky\\.haxelib\\console,hx/0,2,12/Console.hx", min : 19027, max : 19029}};
	var _g = 0;
	var _g1 = rest.length;
	while(_g < _g1) {
		var i = _g++;
		var e = rest[i];
		msg = { expr : haxe_macro_ExprDef.EBinop(haxe_macro_Binop.OpAdd,msg,e), pos : { file : "D:\\Dokumente\\GitHub\\snekky\\.haxelib\\console,hx/0,2,12/Console.hx", min : 19095, max : 19104}};
		if(i != rest.length - 1) {
			msg = { expr : haxe_macro_ExprDef.EBinop(haxe_macro_Binop.OpAdd,msg,{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString("" + Console.argSeparator,haxe_macro_StringLiteralKind.SingleQuotes)), pos : { file : "D:\\Dokumente\\GitHub\\snekky\\.haxelib\\console,hx/0,2,12/Console.hx", min : 19159, max : 19174}}), pos : { file : "D:\\Dokumente\\GitHub\\snekky\\.haxelib\\console,hx/0,2,12/Console.hx", min : 19152, max : 19174}};
		}
	}
	return msg;
};
var FormatFlag = {};
FormatFlag.fromString = function(str) {
	str = str.toLowerCase();
	if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
		var hIdx = str.indexOf("#");
		var hex = HxOverrides.substr(str,hIdx + 1,null);
		if(hex.length == 3) {
			var a = hex.split("");
			hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
		}
		if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
			return "";
		}
		var normalized = str.substring(0,hIdx) + "#" + hex;
		return normalized;
	}
	switch(str) {
	case "!":
		return "invert";
	case "/":
		return "reset";
	case "b":
		return "bold";
	case "bg_gray":
		return "bg_light_black";
	case "gray":
		return "light_black";
	case "i":
		return "italic";
	case "u":
		return "underline";
	default:
		return str;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
var Snekky = $hx_exports["Snekky"] = function() { };
Snekky.__name__ = true;
Snekky.compileString = function(filename,code,debug,compress) {
	var lexer = new lexer_Lexer(filename,code);
	var parser = new parser_Parser(lexer);
	parser.generateAst();
	var compiler = new compiler_Compiler(debug);
	compiler.compile(parser.ast);
	var byteCode = compiler.getByteCode(compress);
	return byteCode;
};
Snekky.evaluateBytes = function(byteCode) {
	var evaluator = new evaluator_Evaluator(byteCode);
	evaluator.eval();
};
Snekky.main = function() {
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
StringBuf.prototype = {
	toString: function() {
		return this.b;
	}
	,__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
var ValueType = $hxEnums["ValueType"] = { __ename__ : true, __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"]
	,TNull: {_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_index:8,__enum__:"ValueType",toString:$estr}
};
var Type = function() { };
Type.__name__ = true;
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var ctorName = enm.__constructs__[e._hx_index];
	var params = enm[ctorName].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var ast_NodeType = $hxEnums["ast.NodeType"] = { __ename__ : true, __constructs__ : ["File","Block","Expression","Statement","Variable","VariableAssign","VariableAssignOp","DestructureArray","DestructureHash","Ident","FunctionCall","Add","Subtract","Multiply","Divide","Modulo","LogicOr","LogicAnd","LessThan","LessThanOrEqual","GreaterThan","GreaterThanOrEqual","ConcatString","Equals","NotEquals","Negate","Not","Float","String","Function","Boolean","Array","Hash","Null","Return","Break","If","While","For","Range","Index","IndexAssign"]
	,File: {_hx_index:0,__enum__:"ast.NodeType",toString:$estr}
	,Block: {_hx_index:1,__enum__:"ast.NodeType",toString:$estr}
	,Expression: {_hx_index:2,__enum__:"ast.NodeType",toString:$estr}
	,Statement: {_hx_index:3,__enum__:"ast.NodeType",toString:$estr}
	,Variable: {_hx_index:4,__enum__:"ast.NodeType",toString:$estr}
	,VariableAssign: {_hx_index:5,__enum__:"ast.NodeType",toString:$estr}
	,VariableAssignOp: {_hx_index:6,__enum__:"ast.NodeType",toString:$estr}
	,DestructureArray: {_hx_index:7,__enum__:"ast.NodeType",toString:$estr}
	,DestructureHash: {_hx_index:8,__enum__:"ast.NodeType",toString:$estr}
	,Ident: {_hx_index:9,__enum__:"ast.NodeType",toString:$estr}
	,FunctionCall: {_hx_index:10,__enum__:"ast.NodeType",toString:$estr}
	,Add: {_hx_index:11,__enum__:"ast.NodeType",toString:$estr}
	,Subtract: {_hx_index:12,__enum__:"ast.NodeType",toString:$estr}
	,Multiply: {_hx_index:13,__enum__:"ast.NodeType",toString:$estr}
	,Divide: {_hx_index:14,__enum__:"ast.NodeType",toString:$estr}
	,Modulo: {_hx_index:15,__enum__:"ast.NodeType",toString:$estr}
	,LogicOr: {_hx_index:16,__enum__:"ast.NodeType",toString:$estr}
	,LogicAnd: {_hx_index:17,__enum__:"ast.NodeType",toString:$estr}
	,LessThan: {_hx_index:18,__enum__:"ast.NodeType",toString:$estr}
	,LessThanOrEqual: {_hx_index:19,__enum__:"ast.NodeType",toString:$estr}
	,GreaterThan: {_hx_index:20,__enum__:"ast.NodeType",toString:$estr}
	,GreaterThanOrEqual: {_hx_index:21,__enum__:"ast.NodeType",toString:$estr}
	,ConcatString: {_hx_index:22,__enum__:"ast.NodeType",toString:$estr}
	,Equals: {_hx_index:23,__enum__:"ast.NodeType",toString:$estr}
	,NotEquals: {_hx_index:24,__enum__:"ast.NodeType",toString:$estr}
	,Negate: {_hx_index:25,__enum__:"ast.NodeType",toString:$estr}
	,Not: {_hx_index:26,__enum__:"ast.NodeType",toString:$estr}
	,Float: {_hx_index:27,__enum__:"ast.NodeType",toString:$estr}
	,String: {_hx_index:28,__enum__:"ast.NodeType",toString:$estr}
	,Function: {_hx_index:29,__enum__:"ast.NodeType",toString:$estr}
	,Boolean: {_hx_index:30,__enum__:"ast.NodeType",toString:$estr}
	,Array: {_hx_index:31,__enum__:"ast.NodeType",toString:$estr}
	,Hash: {_hx_index:32,__enum__:"ast.NodeType",toString:$estr}
	,Null: {_hx_index:33,__enum__:"ast.NodeType",toString:$estr}
	,Return: {_hx_index:34,__enum__:"ast.NodeType",toString:$estr}
	,Break: {_hx_index:35,__enum__:"ast.NodeType",toString:$estr}
	,If: {_hx_index:36,__enum__:"ast.NodeType",toString:$estr}
	,While: {_hx_index:37,__enum__:"ast.NodeType",toString:$estr}
	,For: {_hx_index:38,__enum__:"ast.NodeType",toString:$estr}
	,Range: {_hx_index:39,__enum__:"ast.NodeType",toString:$estr}
	,Index: {_hx_index:40,__enum__:"ast.NodeType",toString:$estr}
	,IndexAssign: {_hx_index:41,__enum__:"ast.NodeType",toString:$estr}
};
var ast_nodes_Node = function(position,type) {
	this.position = position;
	this.type = type;
};
ast_nodes_Node.__name__ = true;
ast_nodes_Node.prototype = {
	__class__: ast_nodes_Node
};
var ast_nodes_ArrayNode = function(position,values) {
	ast_nodes_Node.call(this,position,ast_NodeType.Array);
	this.values = values;
};
ast_nodes_ArrayNode.__name__ = true;
ast_nodes_ArrayNode.__super__ = ast_nodes_Node;
ast_nodes_ArrayNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ArrayNode
});
var ast_nodes_BlockNode = function(position) {
	this.body = [];
	ast_nodes_Node.call(this,position,ast_NodeType.Block);
};
ast_nodes_BlockNode.__name__ = true;
ast_nodes_BlockNode.__super__ = ast_nodes_Node;
ast_nodes_BlockNode.prototype = $extend(ast_nodes_Node.prototype,{
	addNode: function(node) {
		this.body.push(node);
	}
	,__class__: ast_nodes_BlockNode
});
var ast_nodes_BooleanNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Boolean);
	this.value = value;
};
ast_nodes_BooleanNode.__name__ = true;
ast_nodes_BooleanNode.__super__ = ast_nodes_Node;
ast_nodes_BooleanNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_BooleanNode
});
var ast_nodes_BreakNode = function(position) {
	ast_nodes_Node.call(this,position,ast_NodeType.Break);
};
ast_nodes_BreakNode.__name__ = true;
ast_nodes_BreakNode.__super__ = ast_nodes_Node;
ast_nodes_BreakNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_BreakNode
});
var ast_nodes_CallNode = function(position,target,parameters) {
	ast_nodes_Node.call(this,position,ast_NodeType.FunctionCall);
	this.target = target;
	this.parameters = parameters;
};
ast_nodes_CallNode.__name__ = true;
ast_nodes_CallNode.__super__ = ast_nodes_Node;
ast_nodes_CallNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_CallNode
});
var ast_nodes_DestructureArrayNode = function(position,names) {
	ast_nodes_Node.call(this,position,ast_NodeType.DestructureArray);
	this.names = names;
};
ast_nodes_DestructureArrayNode.__name__ = true;
ast_nodes_DestructureArrayNode.__super__ = ast_nodes_Node;
ast_nodes_DestructureArrayNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_DestructureArrayNode
});
var ast_nodes_DestructureHashNode = function(position,names) {
	ast_nodes_Node.call(this,position,ast_NodeType.DestructureHash);
	this.names = names;
};
ast_nodes_DestructureHashNode.__name__ = true;
ast_nodes_DestructureHashNode.__super__ = ast_nodes_Node;
ast_nodes_DestructureHashNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_DestructureHashNode
});
var ast_nodes_ExpressionNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Expression);
	this.value = value;
};
ast_nodes_ExpressionNode.__name__ = true;
ast_nodes_ExpressionNode.__super__ = ast_nodes_Node;
ast_nodes_ExpressionNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ExpressionNode
});
var ast_nodes_FileNode = function(position,filename,code) {
	ast_nodes_BlockNode.call(this,position);
	this.filename = filename;
	this.code = code;
	this.type = ast_NodeType.File;
};
ast_nodes_FileNode.__name__ = true;
ast_nodes_FileNode.__super__ = ast_nodes_BlockNode;
ast_nodes_FileNode.prototype = $extend(ast_nodes_BlockNode.prototype,{
	__class__: ast_nodes_FileNode
});
var ast_nodes_ForNode = function(position,variable,iterator,block) {
	ast_nodes_Node.call(this,position,ast_NodeType.For);
	this.variable = variable;
	this.iterator = iterator;
	this.block = block;
};
ast_nodes_ForNode.__name__ = true;
ast_nodes_ForNode.__super__ = ast_nodes_Node;
ast_nodes_ForNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ForNode
});
var ast_nodes_HashNode = function(position,values) {
	ast_nodes_Node.call(this,position,ast_NodeType.Hash);
	this.values = values;
};
ast_nodes_HashNode.__name__ = true;
ast_nodes_HashNode.__super__ = ast_nodes_Node;
ast_nodes_HashNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_HashNode
});
var ast_nodes_IdentNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Ident);
	this.value = value;
};
ast_nodes_IdentNode.__name__ = true;
ast_nodes_IdentNode.__super__ = ast_nodes_Node;
ast_nodes_IdentNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IdentNode
});
var ast_nodes_IfNode = function(position,condition,consequence,alternative) {
	ast_nodes_Node.call(this,position,ast_NodeType.If);
	this.condition = condition;
	this.consequence = consequence;
	this.alternative = alternative;
};
ast_nodes_IfNode.__name__ = true;
ast_nodes_IfNode.__super__ = ast_nodes_Node;
ast_nodes_IfNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IfNode
});
var ast_nodes_IndexAssignNode = function(position,index,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.IndexAssign);
	this.index = index;
	this.value = value;
};
ast_nodes_IndexAssignNode.__name__ = true;
ast_nodes_IndexAssignNode.__super__ = ast_nodes_Node;
ast_nodes_IndexAssignNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IndexAssignNode
});
var ast_nodes_IndexNode = function(position,target,index) {
	ast_nodes_Node.call(this,position,ast_NodeType.Index);
	this.target = target;
	this.index = index;
};
ast_nodes_IndexNode.__name__ = true;
ast_nodes_IndexNode.__super__ = ast_nodes_Node;
ast_nodes_IndexNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IndexNode
});
var ast_nodes_OperatorNode = function(position,type,left,right) {
	ast_nodes_Node.call(this,position,type);
	this.left = left;
	this.right = right;
};
ast_nodes_OperatorNode.__name__ = true;
ast_nodes_OperatorNode.__super__ = ast_nodes_Node;
ast_nodes_OperatorNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_OperatorNode
});
var ast_nodes_RangeNode = function(position,start,end,inclusive) {
	ast_nodes_Node.call(this,position,ast_NodeType.Range);
	this.start = start;
	this.end = end;
	this.inclusive = inclusive;
};
ast_nodes_RangeNode.__name__ = true;
ast_nodes_RangeNode.__super__ = ast_nodes_Node;
ast_nodes_RangeNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_RangeNode
});
var ast_nodes_ReturnNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Return);
	this.value = value;
};
ast_nodes_ReturnNode.__name__ = true;
ast_nodes_ReturnNode.__super__ = ast_nodes_Node;
ast_nodes_ReturnNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ReturnNode
});
var ast_nodes_StatementNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Statement);
	this.value = value;
};
ast_nodes_StatementNode.__name__ = true;
ast_nodes_StatementNode.__super__ = ast_nodes_Node;
ast_nodes_StatementNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_StatementNode
});
var ast_nodes_VariableAssignNode = function(position,name,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.VariableAssign);
	this.name = name;
	this.value = value;
};
ast_nodes_VariableAssignNode.__name__ = true;
ast_nodes_VariableAssignNode.__super__ = ast_nodes_Node;
ast_nodes_VariableAssignNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_VariableAssignNode
});
var ast_nodes_VariableAssignOpNode = function(position,name,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.VariableAssignOp);
	this.name = name;
	this.value = value;
};
ast_nodes_VariableAssignOpNode.__name__ = true;
ast_nodes_VariableAssignOpNode.__super__ = ast_nodes_Node;
ast_nodes_VariableAssignOpNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_VariableAssignOpNode
});
var ast_nodes_VariableNode = function(position,name,value,mutable) {
	ast_nodes_Node.call(this,position,ast_NodeType.Variable);
	this.name = name;
	this.value = value;
	this.mutable = mutable;
};
ast_nodes_VariableNode.__name__ = true;
ast_nodes_VariableNode.__super__ = ast_nodes_Node;
ast_nodes_VariableNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_VariableNode
});
var ast_nodes_WhileNode = function(position,condition,block) {
	ast_nodes_Node.call(this,position,ast_NodeType.While);
	this.condition = condition;
	this.block = block;
};
ast_nodes_WhileNode.__name__ = true;
ast_nodes_WhileNode.__super__ = ast_nodes_Node;
ast_nodes_WhileNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_WhileNode
});
var ast_nodes_datatypes_FloatNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Float);
	this.value = value;
};
ast_nodes_datatypes_FloatNode.__name__ = true;
ast_nodes_datatypes_FloatNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_FloatNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_FloatNode
});
var ast_nodes_datatypes_FunctionNode = function(position,block,parameters) {
	ast_nodes_Node.call(this,position,ast_NodeType.Function);
	this.parameters = parameters;
	this.block = block;
};
ast_nodes_datatypes_FunctionNode.__name__ = true;
ast_nodes_datatypes_FunctionNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_FunctionNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_FunctionNode
});
var ast_nodes_datatypes_NullNode = function(position) {
	ast_nodes_Node.call(this,position,ast_NodeType.Null);
};
ast_nodes_datatypes_NullNode.__name__ = true;
ast_nodes_datatypes_NullNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_NullNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_NullNode
});
var ast_nodes_datatypes_StringNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.String);
	this.value = value;
};
ast_nodes_datatypes_StringNode.__name__ = true;
ast_nodes_datatypes_StringNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_StringNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_StringNode
});
var code_Code = function() { };
code_Code.__name__ = true;
code_Code.make = function(op,operands) {
	var instruction = new haxe_io_BytesOutput();
	instruction.writeByte(op);
	var _g = 0;
	while(_g < operands.length) {
		var operand = operands[_g];
		++_g;
		instruction.writeInt32(operand);
	}
	return instruction.getBytes();
};
var code_OpCode = function() { };
code_OpCode.__name__ = true;
var compiler_Compiler = function(debug) {
	this.breakPositions = [];
	this.error = new error_CompileError("","");
	this.filenameTable = new compiler_debug_FilenameTable();
	this.symbolTable = new compiler_symbol_SymbolTable();
	this.localVariableTable = new compiler_debug_LocalVariableTable();
	this.lineNumberTable = new compiler_debug_LineNumberTable();
	this.instructions = new haxe_io_BytesOutput();
	this.constantPool = new compiler_constant_ConstantPool();
	this.debug = debug;
};
compiler_Compiler.__name__ = true;
compiler_Compiler.prototype = {
	getByteCode: function(compress) {
		var program = new haxe_io_BytesOutput();
		program.write(this.filenameTable.toByteCode());
		program.write(this.lineNumberTable.toByteCode());
		program.write(this.localVariableTable.toByteCode());
		program.write(this.constantPool.toByteCode());
		var instructionsByteCode = this.instructions.getBytes();
		program.writeInt32(instructionsByteCode.length);
		program.write(instructionsByteCode);
		var output = new haxe_io_BytesOutput();
		output.writeByte(compress ? 1 : 0);
		if(compress) {
			output.write(haxe_zip_Compress.run(program.getBytes(),9));
		} else {
			output.write(program.getBytes());
		}
		return output.getBytes();
	}
	,compile: function(node) {
		var _gthis = this;
		switch(node.type._hx_index) {
		case 0:
			var cFile = js_Boot.__cast(node , ast_nodes_FileNode);
			var pFilename = this.error.filename;
			var pCode = this.error.code;
			this.error.filename = cFile.filename;
			this.error.code = cFile.code;
			var startIndex = this.instructions.b.pos;
			var _g = 0;
			var _g1 = cFile.body;
			while(_g < _g1.length) {
				var blockNode = _g1[_g];
				++_g;
				this.compile(blockNode);
			}
			this.error.filename = pFilename;
			this.error.code = pCode;
			if(this.debug) {
				this.filenameTable.define(startIndex,this.instructions.b.pos,cFile.filename);
			}
			break;
		case 1:
			var cBlock = js_Boot.__cast(node , ast_nodes_BlockNode);
			this.symbolTable.newScope();
			var _g = 0;
			var _g1 = cBlock.body;
			while(_g < _g1.length) {
				var blockNode = _g1[_g];
				++_g;
				this.compile(blockNode);
			}
			this.symbolTable.setParent();
			break;
		case 2:
			var cExpression = js_Boot.__cast(node , ast_nodes_ExpressionNode);
			this.compile(cExpression.value);
			break;
		case 3:
			var cStatement = js_Boot.__cast(node , ast_nodes_StatementNode);
			this.compile(cStatement.value.value);
			this.emit(1,cStatement.position,[]);
			break;
		case 4:
			var cVariable = js_Boot.__cast(node , ast_nodes_VariableNode);
			if(cVariable.name.type == ast_NodeType.Ident) {
				var cVariableName = (js_Boot.__cast(cVariable.name , ast_nodes_IdentNode)).value;
				var position = node.position;
				var mutable = cVariable.mutable;
				if(_gthis.symbolTable.currentScope.exists(cVariableName)) {
					_gthis.error.redeclareVariable(cVariable.position,cVariableName);
				}
				if(_gthis.debug) {
					_gthis.localVariableTable.define(_gthis.instructions.b.pos,cVariableName);
				}
				var symbol = _gthis.symbolTable.define(cVariableName,mutable);
				if(cVariable.value != null) {
					this.compile(cVariable.value);
				}
				this.emit(17,cVariable.position,[symbol.index]);
			} else if(cVariable.name.type == ast_NodeType.DestructureArray) {
				var cVariableName = js_Boot.__cast(cVariable.name , ast_nodes_DestructureArrayNode);
				var _g_current = 0;
				var _g_array = cVariableName.names;
				while(_g_current < _g_array.length) {
					var _g1_value = _g_array[_g_current];
					var _g1_key = _g_current++;
					var i = _g1_key;
					var varName = _g1_value;
					var position = node.position;
					var mutable = cVariable.mutable;
					if(_gthis.symbolTable.currentScope.exists(varName)) {
						_gthis.error.redeclareVariable(cVariable.position,varName);
					}
					if(_gthis.debug) {
						_gthis.localVariableTable.define(_gthis.instructions.b.pos,varName);
					}
					var symbol = _gthis.symbolTable.define(varName,mutable);
					if(cVariable.value != null) {
						this.compile(cVariable.value);
					}
					this.emit(25,node.position,[i]);
					this.emit(17,cVariable.position,[symbol.index]);
				}
				this.emit(1,node.position,[]);
			} else {
				var cVariableName = js_Boot.__cast(cVariable.name , ast_nodes_DestructureHashNode);
				var _g = 0;
				var _g1 = cVariableName.names;
				while(_g < _g1.length) {
					var varName = _g1[_g];
					++_g;
					var position = node.position;
					var mutable = cVariable.mutable;
					if(_gthis.symbolTable.currentScope.exists(varName)) {
						_gthis.error.redeclareVariable(cVariable.position,varName);
					}
					if(_gthis.debug) {
						_gthis.localVariableTable.define(_gthis.instructions.b.pos,varName);
					}
					var symbol = _gthis.symbolTable.define(varName,mutable);
					if(cVariable.value != null) {
						this.compile(cVariable.value);
					}
					this.constantPool.addConstant(new object_StringObj(varName,null));
					this.emit(0,node.position,[this.constantPool.getSize() - 1]);
					this.emit(26,node.position,[]);
					this.emit(17,cVariable.position,[symbol.index]);
				}
				this.emit(1,node.position,[]);
			}
			break;
		case 5:
			var cVariableAssign = js_Boot.__cast(node , ast_nodes_VariableAssignNode);
			var symbol = this.symbolTable.resolve(cVariableAssign.name.value);
			if(symbol == null) {
				this.error.symbolUndefined(cVariableAssign.position,cVariableAssign.name.value);
			} else if(!symbol.mutable) {
				this.error.symbolImmutable(cVariableAssign.position,cVariableAssign.name.value);
			}
			if(this.debug) {
				this.localVariableTable.define(this.instructions.b.pos,cVariableAssign.name.value);
			}
			this.compile(cVariableAssign.value);
			this.emit(17,cVariableAssign.position,[symbol.index]);
			break;
		case 6:
			var cVariableAssignOp = js_Boot.__cast(node , ast_nodes_VariableAssignOpNode);
			var symbol = this.symbolTable.resolve(cVariableAssignOp.name.value);
			if(symbol == null) {
				this.error.symbolUndefined(cVariableAssignOp.position,cVariableAssignOp.name.value);
			} else if(!symbol.mutable) {
				this.error.symbolImmutable(cVariableAssignOp.position,cVariableAssignOp.name.value);
			}
			if(this.debug) {
				this.localVariableTable.define(this.instructions.b.pos,cVariableAssignOp.name.value);
			}
			this.compile(cVariableAssignOp.value);
			this.emit(17,cVariableAssignOp.position,[symbol.index]);
			break;
		case 9:
			var cIdent = js_Boot.__cast(node , ast_nodes_IdentNode);
			var symbol = this.symbolTable.resolve(cIdent.value);
			if(symbol == null) {
				var builtInIndex = std_BuiltInTable.resolveName(cIdent.value);
				if(builtInIndex != -1) {
					this.emit(18,node.position,[builtInIndex]);
				} else {
					this.error.symbolUndefined(cIdent.position,cIdent.value);
				}
			} else {
				this.emit(16,node.position,[symbol.index]);
			}
			break;
		case 10:
			var cCall = js_Boot.__cast(node , ast_nodes_CallNode);
			var i = cCall.parameters.length;
			while(--i >= 0) this.compile(cCall.parameters[i]);
			this.compile(cCall.target);
			this.emit(19,node.position,[cCall.parameters.length]);
			break;
		case 11:case 12:case 13:case 14:case 15:case 18:case 20:case 22:case 23:case 24:
			var cOperator = js_Boot.__cast(node , ast_nodes_OperatorNode);
			this.compile(cOperator.left);
			this.compile(cOperator.right);
			switch(cOperator.type._hx_index) {
			case 11:
				this.emit(5,node.position,[]);
				break;
			case 12:
				this.emit(6,node.position,[]);
				break;
			case 13:
				this.emit(7,node.position,[]);
				break;
			case 14:
				this.emit(8,node.position,[]);
				break;
			case 15:
				this.emit(9,node.position,[]);
				break;
			case 18:
				this.emit(11,node.position,[]);
				break;
			case 20:
				this.emit(12,node.position,[]);
				break;
			case 22:
				this.emit(15,node.position,[]);
				break;
			case 23:
				this.emit(10,node.position,[]);
				break;
			case 24:
				this.emit(10,node.position,[]);
				this.emit(14,node.position,[]);
				break;
			default:
			}
			break;
		case 16:
			var cOperator = js_Boot.__cast(node , ast_nodes_OperatorNode);
			this.compile(cOperator.left);
			var jumpPeekInstructionPos = this.instructions.b.pos;
			this.emit(4,node.position,[0]);
			this.emit(1,node.position,[]);
			this.compile(cOperator.right);
			this.overwriteInstruction(jumpPeekInstructionPos,[this.instructions.b.pos]);
			break;
		case 17:
			var cOperator = js_Boot.__cast(node , ast_nodes_OperatorNode);
			this.compile(cOperator.left);
			this.emit(14,node.position,[]);
			var jumpPeekInstructionPos = this.instructions.b.pos;
			this.emit(4,node.position,[0]);
			this.emit(1,node.position,[]);
			this.compile(cOperator.right);
			var jumpInstructionPos = this.instructions.b.pos;
			this.emit(2,node.position,[0]);
			this.overwriteInstruction(jumpPeekInstructionPos,[this.instructions.b.pos]);
			this.emit(14,node.position,[]);
			this.overwriteInstruction(jumpInstructionPos,[this.instructions.b.pos]);
			break;
		case 19:case 21:
			var cOperator = js_Boot.__cast(node , ast_nodes_OperatorNode);
			this.compile(cOperator.left);
			this.compile(cOperator.right);
			if(node.type == ast_NodeType.LessThanOrEqual) {
				this.emit(11,node.position,[]);
			} else {
				this.emit(12,node.position,[]);
			}
			var jumpPeekInstructionPos = this.instructions.b.pos;
			this.emit(4,node.position,[0]);
			this.emit(1,node.position,[]);
			this.compile(cOperator.left);
			this.compile(cOperator.right);
			this.emit(10,node.position,[]);
			this.overwriteInstruction(jumpPeekInstructionPos,[this.instructions.b.pos]);
			break;
		case 25:case 26:
			var cOperator = js_Boot.__cast(node , ast_nodes_OperatorNode);
			this.compile(cOperator.right);
			if(cOperator.type == ast_NodeType.Negate) {
				this.emit(13,node.position,[]);
			} else {
				this.emit(14,node.position,[]);
			}
			break;
		case 29:
			var cFunction = js_Boot.__cast(node , ast_nodes_datatypes_FunctionNode);
			this.emit(0,node.position,[this.constantPool.getSize()]);
			var jumpInstructionPos = this.instructions.b.pos;
			this.emit(2,node.position,[0]);
			this.constantPool.addConstant(new object_UserFunctionObj(this.instructions.b.pos,cFunction.parameters.length,null));
			this.symbolTable.newScope();
			var _g = 0;
			var _g1 = cFunction.parameters;
			while(_g < _g1.length) {
				var parameter = _g1[_g];
				++_g;
				var symbol = this.symbolTable.define(parameter.value,false);
				this.emit(17,node.position,[symbol.index]);
			}
			this.compile(cFunction.block);
			this.emit(20,node.position,[]);
			this.overwriteInstruction(jumpInstructionPos,[this.instructions.b.pos]);
			this.symbolTable.setParent();
			break;
		case 31:
			var cArray = js_Boot.__cast(node , ast_nodes_ArrayNode);
			var _g = 0;
			var _g1 = cArray.values;
			while(_g < _g1.length) {
				var value = _g1[_g];
				++_g;
				this.compile(value);
			}
			this.emit(21,node.position,[cArray.values.length]);
			break;
		case 32:
			var cHash = js_Boot.__cast(node , ast_nodes_HashNode);
			var length = 0;
			var _g = new haxe_iterators_MapKeyValueIterator(cHash.values);
			while(_g.hasNext()) {
				var _g1 = _g.next();
				var key = _g1.key;
				var value = _g1.value;
				this.compile(key);
				this.compile(value);
				++length;
			}
			this.emit(22,node.position,[length]);
			break;
		case 27:case 28:case 30:case 33:
			switch(node.type._hx_index) {
			case 27:
				this.constantPool.addConstant(new object_NumberObj((js_Boot.__cast(node , ast_nodes_datatypes_FloatNode)).value,null));
				break;
			case 28:
				this.constantPool.addConstant(new object_StringObj((js_Boot.__cast(node , ast_nodes_datatypes_StringNode)).value,null));
				break;
			case 30:
				this.constantPool.addConstant(new object_NumberObj((js_Boot.__cast(node , ast_nodes_BooleanNode)).value ? 1 : 0,null));
				break;
			case 33:
				this.constantPool.addConstant(new object_NullObj(null));
				break;
			default:
			}
			this.emit(0,node.position,[this.constantPool.getSize() - 1]);
			break;
		case 34:
			var cReturn = js_Boot.__cast(node , ast_nodes_ReturnNode);
			if(cReturn.value != null) {
				this.compile(cReturn.value);
			}
			this.emit(20,node.position,[]);
			break;
		case 35:
			this.breakPositions.push(this.instructions.b.pos);
			this.emit(2,node.position,[0]);
			break;
		case 36:
			var cIf = js_Boot.__cast(node , ast_nodes_IfNode);
			this.compile(cIf.condition);
			var jumpNotInstructionPos = this.instructions.b.pos;
			this.emit(3,node.position,[0]);
			this.compile(cIf.consequence);
			var jumpInstructionPos = this.instructions.b.pos;
			this.emit(2,node.position,[0]);
			var jumpNotPos = this.instructions.b.pos;
			if(cIf.alternative != null) {
				this.compile(cIf.alternative);
			}
			var jumpPos = this.instructions.b.pos;
			this.overwriteInstruction(jumpNotInstructionPos,[jumpNotPos]);
			this.overwriteInstruction(jumpInstructionPos,[jumpPos]);
			break;
		case 37:
			var cWhile = js_Boot.__cast(node , ast_nodes_WhileNode);
			var jumpPos = this.instructions.b.pos;
			this.compile(cWhile.condition);
			var jumpNotInstructionPos = this.instructions.b.pos;
			this.emit(3,node.position,[0]);
			this.compile(cWhile.block);
			this.emit(2,node.position,[jumpPos]);
			var _g = 0;
			var _g1 = this.breakPositions;
			while(_g < _g1.length) {
				var pos = _g1[_g];
				++_g;
				this.overwriteInstruction(pos,[this.instructions.b.pos]);
			}
			this.overwriteInstruction(jumpNotInstructionPos,[this.instructions.b.pos]);
			break;
		case 38:
			var cFor = js_Boot.__cast(node , ast_nodes_ForNode);
			this.compile(cFor.iterator);
			this.constantPool.addConstant(new object_StringObj("Iterator",null));
			this.emit(0,node.position,[this.constantPool.getSize() - 1]);
			this.emit(23,node.position,[]);
			this.emit(19,node.position,[0]);
			var iterator = this.symbolTable.defineInternal();
			this.emit(17,node.position,[iterator]);
			var jumpPos = this.instructions.b.pos;
			this.emit(16,node.position,[iterator]);
			this.constantPool.addConstant(new object_StringObj("hasNext",null));
			this.emit(0,node.position,[this.constantPool.getSize() - 1]);
			this.emit(23,node.position,[]);
			this.emit(19,node.position,[0]);
			var jumpNotPos = this.instructions.b.pos;
			this.emit(3,node.position,[0]);
			this.emit(16,node.position,[iterator]);
			this.constantPool.addConstant(new object_StringObj("next",null));
			this.emit(0,node.position,[this.constantPool.getSize() - 1]);
			this.emit(23,node.position,[]);
			this.emit(19,node.position,[0]);
			this.symbolTable.newScope();
			if(cFor.variable != null) {
				this.compile(cFor.variable);
			} else {
				this.emit(1,node.position,[]);
			}
			this.compile(cFor.block);
			this.symbolTable.setParent();
			this.emit(2,node.position,[jumpPos]);
			var _g = 0;
			var _g1 = this.breakPositions;
			while(_g < _g1.length) {
				var pos = _g1[_g];
				++_g;
				this.overwriteInstruction(pos,[this.instructions.b.pos]);
			}
			this.overwriteInstruction(jumpNotPos,[this.instructions.b.pos]);
			break;
		case 39:
			var cRange = js_Boot.__cast(node , ast_nodes_RangeNode);
			this.compile(cRange.end);
			this.compile(cRange.start);
			this.emit(18,node.position,[std_BuiltInTable.resolveName("Range")]);
			if(cRange.inclusive) {
				this.constantPool.addConstant(new object_StringObj("Inclusive",null));
			} else {
				this.constantPool.addConstant(new object_StringObj("Exclusive",null));
			}
			this.emit(0,node.position,[this.constantPool.getSize() - 1]);
			this.emit(23,node.position,[]);
			this.emit(19,node.position,[2]);
			break;
		case 40:
			var cIndex = js_Boot.__cast(node , ast_nodes_IndexNode);
			this.compile(cIndex.target);
			this.compile(cIndex.index);
			this.emit(23,node.position,[]);
			break;
		case 41:
			var cIndexAssign = js_Boot.__cast(node , ast_nodes_IndexAssignNode);
			this.compile(cIndexAssign.index);
			this.removeLastInstruction();
			this.compile(cIndexAssign.value);
			this.emit(24,node.position,[]);
			break;
		default:
		}
	}
	,removeLastInstruction: function() {
		var currentBytes = this.instructions.getBytes();
		this.instructions = new haxe_io_BytesOutput();
		this.instructions.writeBytes(currentBytes,0,currentBytes.length - 1);
	}
	,overwriteInstruction: function(pos,operands) {
		var currentBytes = this.instructions.getBytes();
		currentBytes.setInt32(pos + 1,operands[0]);
		this.instructions = new haxe_io_BytesOutput();
		this.instructions.write(currentBytes);
	}
	,emit: function(op,position,operands) {
		if(this.debug) {
			this.lineNumberTable.define(this.instructions.b.pos,error_ErrorHelper.resolvePosition(this.error.code,position));
		}
		var instruction = code_Code.make(op,operands);
		this.instructions.write(instruction);
	}
	,__class__: compiler_Compiler
};
var compiler_constant_ConstantPool = function() {
	this.constants = [];
};
compiler_constant_ConstantPool.__name__ = true;
compiler_constant_ConstantPool.fromByteCode = function(byteCode,evaluator) {
	var pool = [];
	var poolSize = byteCode.readInt32();
	var startPosition = byteCode.pos;
	while(byteCode.pos < startPosition + poolSize) {
		var type = byteCode.readByte();
		switch(type) {
		case 0:
			var value = byteCode.readDouble();
			pool.push(new object_NumberObj(value,evaluator));
			break;
		case 1:
			var length = byteCode.readInt32();
			var value1 = byteCode.readString(length);
			pool.push(new object_StringObj(value1,evaluator));
			break;
		case 2:
			var position = byteCode.readInt32();
			var parametersCount = byteCode.readInt16();
			pool.push(new object_UserFunctionObj(position,parametersCount,evaluator));
			break;
		case 3:
			pool.push(new object_NullObj(evaluator));
			break;
		default:
		}
	}
	return pool;
};
compiler_constant_ConstantPool.prototype = {
	addConstant: function(obj) {
		return this.constants.push(obj);
	}
	,getSize: function() {
		return this.constants.length;
	}
	,toByteCode: function() {
		var constantsBytes = new haxe_io_BytesOutput();
		var _g = 0;
		var _g1 = this.constants;
		while(_g < _g1.length) {
			var $const = _g1[_g];
			++_g;
			switch($const.type._hx_index) {
			case 0:
				var cNumber = js_Boot.__cast($const , object_NumberObj);
				constantsBytes.writeByte(0);
				constantsBytes.writeDouble(cNumber.value);
				break;
			case 1:
				var cString = js_Boot.__cast($const , object_StringObj);
				constantsBytes.writeByte(1);
				constantsBytes.writeInt32(haxe_io_Bytes.ofString(cString.value).length);
				constantsBytes.writeString(cString.value);
				break;
			case 5:
				var cUserFunction = js_Boot.__cast($const , object_UserFunctionObj);
				constantsBytes.writeByte(2);
				constantsBytes.writeInt32(cUserFunction.position);
				constantsBytes.writeInt16(cUserFunction.parametersCount);
				break;
			case 7:
				constantsBytes.writeByte(3);
				break;
			default:
			}
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(constantsBytes.b.pos);
		output.write(constantsBytes.getBytes());
		return output.getBytes();
	}
	,__class__: compiler_constant_ConstantPool
};
var compiler_constant_ConstantType = function() { };
compiler_constant_ConstantType.__name__ = true;
var compiler_debug_FilenameTable = function() {
	this.table = [];
};
compiler_debug_FilenameTable.__name__ = true;
compiler_debug_FilenameTable.prototype = {
	define: function(start,end,filename) {
		this.table.push({ start : start, end : end, filename : filename});
	}
	,resolve: function(byteIndex) {
		var prev = null;
		var _g = 0;
		var _g1 = this.table;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.start <= byteIndex && entry.end >= byteIndex) {
				if(prev == null) {
					prev = entry;
					continue;
				}
				if(entry.start >= prev.start && entry.end <= prev.end) {
					prev = entry;
				}
			}
		}
		return prev.filename;
	}
	,toByteCode: function() {
		var tableBytes = new haxe_io_BytesOutput();
		var _g = 0;
		var _g1 = this.table;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			tableBytes.writeInt32(entry.start);
			tableBytes.writeInt32(entry.end);
			tableBytes.writeInt32(haxe_io_Bytes.ofString(entry.filename).length);
			tableBytes.writeString(entry.filename);
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(tableBytes.b.pos);
		output.write(tableBytes.getBytes());
		return output.getBytes();
	}
	,fromByteCode: function(byteCode) {
		var tableSize = byteCode.readInt32();
		var startPosition = byteCode.pos;
		while(byteCode.pos < startPosition + tableSize) {
			var start = byteCode.readInt32();
			var end = byteCode.readInt32();
			var filenameLength = byteCode.readInt32();
			var filename = byteCode.readString(filenameLength);
			this.table.push({ start : start, end : end, filename : filename});
		}
		return this;
	}
	,__class__: compiler_debug_FilenameTable
};
var compiler_debug_LineNumberTable = function() {
	this.table = new haxe_ds_IntMap();
};
compiler_debug_LineNumberTable.__name__ = true;
compiler_debug_LineNumberTable.prototype = {
	define: function(byteIndex,sourcePosition) {
		this.table.h[byteIndex] = sourcePosition;
	}
	,resolve: function(byteIndex) {
		if(byteIndex < 0) {
			return null;
		}
		var position = this.table.h[byteIndex];
		if(position != null) {
			return position;
		} else {
			return this.resolve(byteIndex - 1);
		}
	}
	,toByteCode: function() {
		var tableBytes = new haxe_io_BytesOutput();
		var _g = new haxe_iterators_MapKeyValueIterator(this.table);
		while(_g.hasNext()) {
			var _g1 = _g.next();
			var byteIndex = _g1.key;
			var position = _g1.value;
			tableBytes.writeInt32(byteIndex);
			tableBytes.writeInt32(position.line);
			tableBytes.writeInt32(position.linePos);
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(tableBytes.b.pos);
		output.write(tableBytes.getBytes());
		return output.getBytes();
	}
	,fromByteCode: function(byteCode) {
		var tableSize = byteCode.readInt32();
		var startPosition = byteCode.pos;
		while(byteCode.pos < startPosition + tableSize) {
			var byteIndex = byteCode.readInt32();
			var line = byteCode.readInt32();
			var linePos = byteCode.readInt32();
			this.table.h[byteIndex] = { line : line, linePos : linePos};
		}
		return this;
	}
	,__class__: compiler_debug_LineNumberTable
};
var compiler_debug_LocalVariableTable = function() {
	this.table = new haxe_ds_IntMap();
};
compiler_debug_LocalVariableTable.__name__ = true;
compiler_debug_LocalVariableTable.prototype = {
	define: function(byteIndex,name) {
		this.table.h[byteIndex] = name;
	}
	,resolve: function(byteIndex) {
		return this.table.h[byteIndex];
	}
	,toByteCode: function() {
		var tableBytes = new haxe_io_BytesOutput();
		var _g = new haxe_iterators_MapKeyValueIterator(this.table);
		while(_g.hasNext()) {
			var _g1 = _g.next();
			var byteIndex = _g1.key;
			var localName = _g1.value;
			tableBytes.writeInt32(byteIndex);
			tableBytes.writeInt32(haxe_io_Bytes.ofString(localName).length);
			tableBytes.writeString(localName);
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(tableBytes.b.pos);
		output.write(tableBytes.getBytes());
		return output.getBytes();
	}
	,fromByteCode: function(byteCode) {
		var tableSize = byteCode.readInt32();
		var startPosition = byteCode.pos;
		while(byteCode.pos < startPosition + tableSize) {
			var byteIndex = byteCode.readInt32();
			var localNameLength = byteCode.readInt32();
			var localName = byteCode.readString(localNameLength);
			this.table.h[byteIndex] = localName;
		}
		return this;
	}
	,__class__: compiler_debug_LocalVariableTable
};
var compiler_symbol_Symbol = function(index,mutable) {
	this.index = index;
	this.mutable = mutable;
};
compiler_symbol_Symbol.__name__ = true;
compiler_symbol_Symbol.prototype = {
	__class__: compiler_symbol_Symbol
};
var compiler_symbol_SymbolScope = function(parent) {
	this.symbols = new haxe_ds_StringMap();
	this.parent = null;
	this.parent = parent;
};
compiler_symbol_SymbolScope.__name__ = true;
compiler_symbol_SymbolScope.prototype = {
	resolve: function(name) {
		return this.symbols.h[name];
	}
	,define: function(name,value) {
		this.symbols.h[name] = value;
	}
	,exists: function(name) {
		return this.resolve(name) != null;
	}
	,__class__: compiler_symbol_SymbolScope
};
var compiler_symbol_SymbolTable = function() {
	this.currentScope = new compiler_symbol_SymbolScope(null);
	this.symbolIndex = 0;
};
compiler_symbol_SymbolTable.__name__ = true;
compiler_symbol_SymbolTable.prototype = {
	newScope: function() {
		this.currentScope = new compiler_symbol_SymbolScope(this.currentScope);
	}
	,setParent: function() {
		this.currentScope = this.currentScope.parent;
	}
	,define: function(name,mutable) {
		var symbol = new compiler_symbol_Symbol(this.symbolIndex,mutable);
		this.currentScope.define(name,symbol);
		this.symbolIndex++;
		return symbol;
	}
	,defineInternal: function() {
		return this.symbolIndex++;
	}
	,resolve: function(name) {
		var cScope = this.currentScope;
		while(cScope != null && !cScope.exists(name)) cScope = cScope.parent;
		if(cScope == null) {
			return null;
		}
		return cScope.resolve(name);
	}
	,__class__: compiler_symbol_SymbolTable
};
var equals_Equal = function() { };
equals_Equal.__name__ = true;
equals_Equal.isNull = function(a) {
	if(Type.typeof(a)._hx_index == 0) {
		return true;
	} else {
		return false;
	}
};
equals_Equal.isFunction = function(a) {
	if(Type.typeof(a)._hx_index == 5) {
		return true;
	} else {
		return false;
	}
};
equals_Equal.equals = function(a,b) {
	if(a == b) {
		return true;
	}
	if(equals_Equal.isNull(a) || equals_Equal.isNull(b)) {
		return false;
	}
	var _g = Type.typeof(a);
	switch(_g._hx_index) {
	case 2:
		if(isNaN(a)) {
			return isNaN(b);
		} else {
			return false;
		}
		break;
	case 0:case 1:case 3:case 8:
		return a == b;
	case 4:
		break;
	case 5:
		return Reflect.compareMethods(a,b);
	case 6:
		var _g1 = _g.c;
		if(((a) instanceof Array)) {
			var a1 = js_Boot.__cast(a , Array);
			var b1 = js_Boot.__cast(b , Array);
			if(a1.length != b1.length) {
				return false;
			}
			var _g1 = 0;
			var _g2 = a1.length;
			while(_g1 < _g2) {
				var i = _g1++;
				if(!equals_Equal.equals(a1[i],b1[i])) {
					return false;
				}
			}
			return true;
		}
		if(js_Boot.__implements(a,haxe_IMap)) {
			var a1 = js_Boot.__cast(a , haxe_IMap);
			var b1 = js_Boot.__cast(b , haxe_IMap);
			var _g1 = [];
			var key = a1.keys();
			while(key.hasNext()) {
				var key1 = key.next();
				_g1.push(key1);
			}
			var a_keys = _g1;
			var _g1 = [];
			var key = b1.keys();
			while(key.hasNext()) {
				var key1 = key.next();
				_g1.push(key1);
			}
			var b_keys = _g1;
			if(!equals_Equal.equals(a_keys,b_keys)) {
				return false;
			}
			var _g1 = 0;
			while(_g1 < a_keys.length) {
				var key = a_keys[_g1];
				++_g1;
				if(!equals_Equal.equals(a1.get(key),b1.get(key))) {
					return false;
				}
			}
			return true;
		}
		if(((a) instanceof Date)) {
			return (js_Boot.__cast(a , Date)).getTime() == (js_Boot.__cast(b , Date)).getTime();
		}
		if(((a) instanceof haxe_io_Bytes)) {
			return equals_Equal.equals((js_Boot.__cast(a , haxe_io_Bytes)).b.bufferValue,(js_Boot.__cast(b , haxe_io_Bytes)).b.bufferValue);
		}
		break;
	case 7:
		var _g1 = _g.e;
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var a_args = Type.enumParameters(a);
		var b_args = Type.enumParameters(b);
		return equals_Equal.equals(a_args,b_args);
	}
	var _g = 0;
	var _g1 = Reflect.fields(a);
	while(_g < _g1.length) {
		var field = _g1[_g];
		++_g;
		var pa = Reflect.field(a,field);
		var pb = Reflect.field(b,field);
		if(equals_Equal.isFunction(pa)) {
			if(equals_Equal.isNull(pa) != equals_Equal.isNull(pb)) {
				return false;
			}
			continue;
		}
		if(!equals_Equal.equals(pa,pb)) {
			return false;
		}
	}
	return true;
};
var error_CompileError = function(filename,code) {
	this.filename = filename;
	this.code = code;
};
error_CompileError.__name__ = true;
error_CompileError.prototype = {
	getMinIndentation: function(code) {
		var min = 2147483647;
		var _g = 0;
		while(_g < code.length) {
			var line = code[_g];
			++_g;
			if(line.length == 0) {
				continue;
			}
			var spaces = 0;
			var _g1 = 0;
			var _g2 = line.length;
			while(_g1 < _g2) {
				var i = _g1++;
				if(line.charAt(i) == " ") {
					++spaces;
				} else {
					break;
				}
			}
			if(spaces < min) {
				min = spaces;
			}
		}
		return min;
	}
	,printCode: function(errorLine,errorLinePosStart,errorLinePosEnd,message) {
		var codePreviewFull = this.code.split("\n");
		var previewStart = error_ErrorHelper.clamp(1,errorLine - 2,errorLine - 2);
		var previewEnd = error_ErrorHelper.clamp(1,codePreviewFull.length + 1,errorLine + 3);
		var codePreview = codePreviewFull.slice(previewStart - 1,previewEnd);
		var minIndentation = this.getMinIndentation(codePreview);
		var lineCountWidth = Std.string(errorLine + 3).length;
		var _g = previewStart;
		var _g1 = previewEnd;
		while(_g < _g1) {
			var i = _g++;
			var lineCount = StringTools.rpad(i == null ? "null" : "" + i," ",lineCountWidth);
			var codeLine = codePreviewFull[i - 1].substring(minIndentation);
			if(i == errorLine) {
				if(errorLinePosEnd == -1) {
					var highlightPosition = new StringBuf();
					var x = "" + error_ErrorHelper.repeatString(errorLinePosStart - minIndentation," ") + "^ ";
					highlightPosition.b += Std.string(x);
					if(message != null) {
						highlightPosition.b += message == null ? "null" : "" + message;
					}
					var outputStream = 0;
					if(outputStream == null) {
						outputStream = 0;
					}
					Console.printFormatted(Console.logPrefix + ("" + ("   " + lineCount + " | " + codeLine)) + "\n",outputStream);
					var s = Console.logPrefix;
					var s1 = "   " + error_ErrorHelper.repeatString(lineCountWidth," ") + " | <#DE4A3F>";
					var outputStream1 = 0;
					if(outputStream1 == null) {
						outputStream1 = 0;
					}
					Console.printFormatted(s + ("" + (s1 + Std.string(highlightPosition) + "</>")) + "\n",outputStream1);
				} else {
					var literalLength = errorLinePosEnd - errorLinePosStart;
					var codeLineHighlighted_b = "";
					codeLineHighlighted_b += Std.string(codeLine.substring(0,errorLinePosStart - minIndentation));
					codeLineHighlighted_b += "<#DE4A3F>";
					codeLineHighlighted_b += Std.string(HxOverrides.substr(codeLine,errorLinePosStart - minIndentation,literalLength));
					codeLineHighlighted_b += "</>";
					codeLineHighlighted_b += Std.string(HxOverrides.substr(codeLine,errorLinePosStart - minIndentation + literalLength,null));
					var outputStream2 = 0;
					if(outputStream2 == null) {
						outputStream2 = 0;
					}
					Console.printFormatted(Console.logPrefix + ("" + ("   " + lineCount + " | " + codeLineHighlighted_b)) + "\n",outputStream2);
					var underline = "" + error_ErrorHelper.repeatString(errorLinePosStart - minIndentation," ") + error_ErrorHelper.repeatString(literalLength,"~");
					var s2 = Console.logPrefix + ("" + ("   " + error_ErrorHelper.repeatString(lineCountWidth," ") + " | <#DE4A3F>" + underline + "</>"));
					var outputStream3 = 0;
					if(outputStream3 == null) {
						outputStream3 = 0;
					}
					Console.printFormatted(s2 + "\n",outputStream3);
				}
			} else {
				var outputStream4 = 0;
				if(outputStream4 == null) {
					outputStream4 = 0;
				}
				Console.printFormatted(Console.logPrefix + ("" + ("   " + lineCount + " | " + codeLine)) + "\n",outputStream4);
			}
		}
	}
	,printHead: function(line,linePos,message) {
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + this.filename + ":" + line + ":" + (linePos + 1) + "</> <#DE4A3F>error:</> " + message + ".")) + "\n",outputStream);
	}
	,unexpectedToken: function(token,expected) {
		var position = error_ErrorHelper.resolvePosition(this.code,token.position);
		this.printHead(position.line,position.linePos,"unexpected token `" + token.literal + "` (" + Std.string(token.type) + ")");
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("Expected " + expected + ".")) + "\n",outputStream);
		this.printCode(position.line,position.linePos,position.linePos + token.literal.length);
		throw haxe_Exception.thrown("");
	}
	,missingSemicolon: function(token) {
		var position = error_ErrorHelper.resolvePosition(this.code,token.position);
		this.printHead(position.line,position.linePos,"missing semicolon");
		this.printCode(position.line,position.linePos,position.linePos + token.literal.length);
		throw haxe_Exception.thrown("");
	}
	,unexpectedEof: function(token) {
		var position = error_ErrorHelper.resolvePosition(this.code,token.position);
		this.printHead(position.line,position.linePos,"unexpcted end of file");
		this.printCode(position.line,position.linePos,position.linePos + token.literal.length);
		throw haxe_Exception.thrown("");
	}
	,illegalToken: function(token) {
		var position = error_ErrorHelper.resolvePosition(this.code,token.position);
		this.printHead(position.line,position.linePos,"illegal token `" + token.literal + "` (" + Std.string(token.type) + ")");
		this.printCode(position.line,position.linePos,position.linePos + token.literal.length);
		throw haxe_Exception.thrown("");
	}
	,symbolUndefined: function(cPosition,symbol) {
		var position = error_ErrorHelper.resolvePosition(this.code,cPosition);
		this.printHead(position.line,position.linePos,"cannot find symbol `" + symbol + "` in this scope");
		this.printCode(position.line,position.linePos,-1,"not found in this scope");
		throw haxe_Exception.thrown("");
	}
	,symbolImmutable: function(cPosition,symbol) {
		var position = error_ErrorHelper.resolvePosition(this.code,cPosition);
		this.printHead(position.line,position.linePos,"cannot re-assign to immutable variable `" + symbol + "`");
		this.printCode(position.line,position.linePos,-1,"cannot be re-assgined");
		throw haxe_Exception.thrown("");
	}
	,redeclareVariable: function(cPosition,symbol) {
		var position = error_ErrorHelper.resolvePosition(this.code,cPosition);
		this.printHead(position.line,position.linePos,"cannot re-declare immutable variable `" + symbol + "`");
		this.printCode(position.line,position.linePos,-1,"has already been declared in this scope");
		throw haxe_Exception.thrown("");
	}
	,__class__: error_CompileError
};
var error_ErrorHelper = function() { };
error_ErrorHelper.__name__ = true;
error_ErrorHelper.repeatString = function(length,s) {
	var buffer_b = "";
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var _ = _g++;
		buffer_b += s == null ? "null" : "" + s;
	}
	return buffer_b;
};
error_ErrorHelper.clamp = function(min,max,value) {
	if(value < min) {
		return min;
	} else if(value > max) {
		return max;
	} else {
		return value;
	}
};
error_ErrorHelper.resolvePosition = function(code,position) {
	var line = 1;
	var linePos = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		if(new EReg("\r\n|\n","").match(code.charAt(i))) {
			++line;
			linePos = 0;
		} else {
			++linePos;
		}
	}
	return { line : line, linePos : linePos};
};
error_ErrorHelper.exit = function() {
	throw haxe_Exception.thrown("");
};
var error_RuntimeError = function(frames,lineNumberTable,localVariableTable,filenameTable,byteCode) {
	this.frames = frames;
	this.lineNumberTable = lineNumberTable;
	this.localVariableTable = localVariableTable;
	this.filenameTable = filenameTable;
	this.byteCode = byteCode;
};
error_RuntimeError.__name__ = true;
error_RuntimeError.prototype = {
	printHead: function(message) {
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("<#DE4A3F>error:</> " + message + ".")) + "\n",outputStream);
	}
	,printStackTrace: function() {
		var position = this.lineNumberTable.resolve(this.byteCode.pos);
		var filename = this.filenameTable.resolve(this.byteCode.pos);
		while(this.frames.head != null) {
			var _this = this.frames;
			var k = _this.head;
			var frame;
			if(k == null) {
				frame = null;
			} else {
				_this.head = k.next;
				frame = k.elt;
			}
			var functionPosition;
			if(frame.calledFunction != null && frame.calledFunction.type == object_ObjectType.UserFunction) {
				var cUserFunction = js_Boot.__cast(frame.calledFunction , object_UserFunctionObj);
				functionPosition = cUserFunction.position;
			} else {
				functionPosition = -1;
			}
			var functionName = this.localVariableTable.resolve(functionPosition - 10);
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			Console.printFormatted(Console.logPrefix + ("" + ("   at " + (functionName == null ? "[anonymous]" : functionName) + " (" + filename + ":" + position.line + ":" + (position.linePos + 1) + ")")) + "\n",outputStream);
			position = this.lineNumberTable.resolve(frame.returnAddress);
			filename = this.filenameTable.resolve(frame.returnAddress);
		}
	}
	,error: function(message) {
		this.printHead(message);
		this.printStackTrace();
		throw haxe_Exception.thrown("");
	}
	,__class__: error_RuntimeError
};
var evaluator_Environment = function() {
	this.variables = [];
};
evaluator_Environment.__name__ = true;
evaluator_Environment.prototype = {
	setVariable: function(index,value) {
		this.variables[index] = value;
	}
	,getVariable: function(index) {
		return this.variables[index];
	}
	,hasVariable: function(index) {
		return this.variables[index] != null;
	}
	,__class__: evaluator_Environment
};
var evaluator_Evaluator = function(fileData) {
	this.frames = new haxe_ds_GenericStack();
	this.stack = new haxe_ds_GenericStack();
	var fileData1 = new haxe_io_BytesInput(fileData);
	var byteCode = fileData1.readByte() == 1 ? new haxe_io_BytesInput(haxe_zip_Uncompress.run(fileData1.readAll())) : new haxe_io_BytesInput(fileData1.readAll());
	this.filenameTable = new compiler_debug_FilenameTable().fromByteCode(byteCode);
	this.lineNumberTable = new compiler_debug_LineNumberTable().fromByteCode(byteCode);
	this.localVariableTable = new compiler_debug_LocalVariableTable().fromByteCode(byteCode);
	this.constantPool = compiler_constant_ConstantPool.fromByteCode(byteCode,this);
	this.instructions = new haxe_io_BytesInput(byteCode.read(byteCode.readInt32()));
	this.builtInTable = new std_BuiltInTable(this);
	this.error = new error_RuntimeError(this.frames,this.lineNumberTable,this.localVariableTable,this.filenameTable,this.instructions);
	var _this = this.frames;
	_this.head = new haxe_ds_GenericCell(new evaluator_Frame(null,0,null),_this.head);
	var _this = this.frames;
	this.currentFrame = _this.head == null ? null : _this.head.elt;
};
evaluator_Evaluator.__name__ = true;
evaluator_Evaluator.prototype = {
	callFunction: function(closure,parameters) {
		parameters.reverse();
		var _g = 0;
		while(_g < parameters.length) {
			var p = parameters[_g];
			++_g;
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(p,_this.head);
		}
		if(closure.func.type._hx_index == 5) {
			var cUserFunction = js_Boot.__cast(closure.func , object_UserFunctionObj);
			if(parameters.length != cUserFunction.parametersCount) {
				this.error.error("wrong number of arguments to function");
			}
			var oPosition = this.instructions.pos;
			var _this = this.frames;
			_this.head = new haxe_ds_GenericCell(new evaluator_Frame(closure.context,this.instructions.totlen,cUserFunction),_this.head);
			var _this = this.frames;
			this.currentFrame = _this.head == null ? null : _this.head.elt;
			this.instructions.set_position(cUserFunction.position);
			this.eval();
			this.instructions.set_position(oPosition);
		}
		var _this = this.stack;
		var k = _this.head;
		if(k == null) {
			return null;
		} else {
			_this.head = k.next;
			return k.elt;
		}
	}
	,'eval': function() {
		while(this.instructions.pos < this.instructions.totlen) this.evalInstruction();
	}
	,evalInstruction: function() {
		var opCode = this.instructions.readByte();
		switch(opCode) {
		case 0:
			var constantIndex = this.instructions.readInt32();
			var constant = this.constantPool[constantIndex].type._hx_index == 5 ? new object_ClosureObj(js_Boot.__cast(this.constantPool[constantIndex] , object_UserFunctionObj),this.currentFrame,this) : this.constantPool[constantIndex];
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(constant,_this.head);
			break;
		case 1:
			var _this = this.stack;
			var k = _this.head;
			if(k != null) {
				_this.head = k.next;
			}
			break;
		case 2:
			var jumpIndex = this.instructions.readInt32();
			this.instructions.set_position(jumpIndex);
			break;
		case 3:
			var jumpIndex = this.instructions.readInt32();
			var _this = this.stack;
			var k = _this.head;
			var conditionValue;
			if(k == null) {
				conditionValue = null;
			} else {
				_this.head = k.next;
				conditionValue = k.elt;
			}
			var conditionValue1 = (js_Boot.__cast(conditionValue , object_NumberObj)).value;
			if(conditionValue1 == 0) {
				this.instructions.set_position(jumpIndex);
			}
			break;
		case 4:
			var jumpIndex = this.instructions.readInt32();
			var _this = this.stack;
			var conditionValue = (js_Boot.__cast(_this.head == null ? null : _this.head.elt , object_NumberObj)).value;
			if(conditionValue == 1) {
				this.instructions.set_position(jumpIndex);
			}
			break;
		case 5:case 6:case 7:case 8:case 9:case 11:case 12:
			var _this = this.stack;
			var k = _this.head;
			var right;
			if(k == null) {
				right = null;
			} else {
				_this.head = k.next;
				right = k.elt;
			}
			var _this = this.stack;
			var k = _this.head;
			var left;
			if(k == null) {
				left = null;
			} else {
				_this.head = k.next;
				left = k.elt;
			}
			if(left.type != object_ObjectType.Number || right.type != object_ObjectType.Number) {
				this.error.error("cannot perform operation");
			}
			var cLeft = (js_Boot.__cast(left , object_NumberObj)).value;
			var cRight = (js_Boot.__cast(right , object_NumberObj)).value;
			var result;
			switch(opCode) {
			case 5:
				result = cLeft + cRight;
				break;
			case 6:
				result = cLeft - cRight;
				break;
			case 7:
				result = cLeft * cRight;
				break;
			case 8:
				result = cLeft / cRight;
				break;
			case 9:
				result = cLeft % cRight;
				break;
			case 11:
				result = cLeft < cRight ? 1 : 0;
				break;
			case 12:
				result = cLeft > cRight ? 1 : 0;
				break;
			default:
				result = -1;
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_NumberObj(result,this),_this.head);
			break;
		case 10:
			var _this = this.stack;
			var k = _this.head;
			var right;
			if(k == null) {
				right = null;
			} else {
				_this.head = k.next;
				right = k.elt;
			}
			var _this = this.stack;
			var k = _this.head;
			var left;
			if(k == null) {
				left = null;
			} else {
				_this.head = k.next;
				left = k.elt;
			}
			var equals;
			var _g = right.type;
			switch(left.type._hx_index) {
			case 0:
				if(_g._hx_index == 0) {
					var cLeft = (js_Boot.__cast(left , object_NumberObj)).value;
					var cRight = (js_Boot.__cast(right , object_NumberObj)).value;
					equals = cLeft == cRight;
				} else {
					equals = false;
				}
				break;
			case 1:
				if(_g._hx_index == 1) {
					var cLeft = (js_Boot.__cast(left , object_StringObj)).value;
					var cRight = (js_Boot.__cast(right , object_StringObj)).value;
					equals = cLeft == cRight;
				} else {
					equals = false;
				}
				break;
			case 2:
				if(_g._hx_index == 2) {
					var cLeft = (js_Boot.__cast(left , object_ArrayObj)).value;
					var cRight = (js_Boot.__cast(right , object_ArrayObj)).value;
					equals = equals_Equal.equals(cLeft,cRight);
				} else {
					equals = false;
				}
				break;
			case 3:
				if(_g._hx_index == 3) {
					var cLeft = (js_Boot.__cast(left , object_HashObj)).value;
					var cRight = (js_Boot.__cast(right , object_HashObj)).value;
					equals = equals_Equal.equals(cLeft,cRight);
				} else {
					equals = false;
				}
				break;
			case 6:
				if(_g._hx_index == 6) {
					var cLeft = (js_Boot.__cast(left , object_ClosureObj)).func;
					var cRight = (js_Boot.__cast(right , object_ClosureObj)).func;
					equals = equals_Equal.equals(cLeft,cRight);
				} else {
					equals = false;
				}
				break;
			case 7:
				equals = _g._hx_index == 7;
				break;
			default:
				equals = false;
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_NumberObj(equals ? 1 : 0,this),_this.head);
			break;
		case 13:
			var _this = this.stack;
			var k = _this.head;
			var negValue;
			if(k == null) {
				negValue = null;
			} else {
				_this.head = k.next;
				negValue = k.elt;
			}
			if(negValue.type == object_ObjectType.Number) {
				var value = (js_Boot.__cast(negValue , object_NumberObj)).value;
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_NumberObj(-value,this),_this.head);
			} else {
				this.error.error("only floats can be negated");
			}
			break;
		case 14:
			var _this = this.stack;
			var k = _this.head;
			var invValue;
			if(k == null) {
				invValue = null;
			} else {
				_this.head = k.next;
				invValue = k.elt;
			}
			if(invValue.type == object_ObjectType.Number) {
				var value = (js_Boot.__cast(invValue , object_NumberObj)).value;
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_NumberObj(value == 1 ? 0 : 1,this),_this.head);
			} else {
				this.error.error("only floats can be inverted");
			}
			break;
		case 15:
			var _this = this.stack;
			var k = _this.head;
			var right;
			if(k == null) {
				right = null;
			} else {
				_this.head = k.next;
				right = k.elt;
			}
			var right1 = right.toString();
			var _this = this.stack;
			var k = _this.head;
			var left;
			if(k == null) {
				left = null;
			} else {
				_this.head = k.next;
				left = k.elt;
			}
			var left1 = left.toString();
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_StringObj("" + left1 + right1,this),_this.head);
			break;
		case 16:
			var localIndex = this.instructions.readInt32();
			var value = this.currentFrame.getVariable(localIndex);
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(value,_this.head);
			break;
		case 17:
			var localIndex = this.instructions.readInt32();
			var _this = this.stack;
			var k = _this.head;
			var value;
			if(k == null) {
				value = null;
			} else {
				_this.head = k.next;
				value = k.elt;
			}
			if(value == null) {
				this.currentFrame.setVariable(localIndex,new object_NullObj(this));
			} else {
				this.currentFrame.setVariable(localIndex,value);
			}
			break;
		case 18:
			var builtInIndex = this.instructions.readInt32();
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(this.builtInTable.resolveIndex(builtInIndex),_this.head);
			break;
		case 19:
			var callParametersCount = this.instructions.readInt32();
			var _this = this.stack;
			var k = _this.head;
			var object;
			if(k == null) {
				object = null;
			} else {
				_this.head = k.next;
				object = k.elt;
			}
			if(object.type._hx_index == 6) {
				var cClosure = js_Boot.__cast(object , object_ClosureObj);
				var _this = this.frames;
				_this.head = new haxe_ds_GenericCell(new evaluator_Frame(cClosure.context,this.instructions.pos,cClosure.func),_this.head);
				var _this = this.frames;
				this.currentFrame = _this.head == null ? null : _this.head.elt;
				if(cClosure.func.parametersCount != callParametersCount) {
					this.error.error("wrong number of arguments to function. expected " + cClosure.func.parametersCount + ", got " + callParametersCount);
				}
				switch(cClosure.func.type._hx_index) {
				case 4:
					var cBuiltInFunction = js_Boot.__cast(cClosure.func , object_BuiltInFunctionObj);
					this.builtInTable.callFunction(cBuiltInFunction);
					break;
				case 5:
					var cUserFunction = js_Boot.__cast(cClosure.func , object_UserFunctionObj);
					this.instructions.set_position(cUserFunction.position);
					break;
				default:
				}
			} else {
				this.error.error("object is not a function");
			}
			break;
		case 20:
			var _this = this.frames;
			var k = _this.head;
			var tmp;
			if(k == null) {
				tmp = null;
			} else {
				_this.head = k.next;
				tmp = k.elt;
			}
			this.instructions.set_position(tmp.returnAddress);
			var _this = this.frames;
			this.currentFrame = _this.head == null ? null : _this.head.elt;
			if(this.stack.head == null) {
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_NullObj(this),_this.head);
			}
			break;
		case 21:
			var arrayLength = this.instructions.readInt32();
			var arrayValues = [];
			var _g = 0;
			var _g1 = arrayLength;
			while(_g < _g1) {
				var _ = _g++;
				var _this = this.stack;
				var k = _this.head;
				var tmp;
				if(k == null) {
					tmp = null;
				} else {
					_this.head = k.next;
					tmp = k.elt;
				}
				arrayValues.unshift(tmp);
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_ArrayObj(arrayValues,this),_this.head);
			break;
		case 22:
			var hashLength = this.instructions.readInt32();
			var hashValues = new haxe_ds_StringMap();
			var _g = 0;
			var _g1 = hashLength;
			while(_g < _g1) {
				var _ = _g++;
				var _this = this.stack;
				var k = _this.head;
				var value;
				if(k == null) {
					value = null;
				} else {
					_this.head = k.next;
					value = k.elt;
				}
				var _this1 = this.stack;
				var k1 = _this1.head;
				var key;
				if(k1 == null) {
					key = null;
				} else {
					_this1.head = k1.next;
					key = k1.elt;
				}
				if(key.type == object_ObjectType.String) {
					hashValues.h[(js_Boot.__cast(key , object_StringObj)).value] = value;
				} else {
					this.error.error("hash key must be a string");
				}
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_HashObj(hashValues,this),_this.head);
			break;
		case 23:
			var _this = this.stack;
			var k = _this.head;
			var index;
			if(k == null) {
				index = null;
			} else {
				_this.head = k.next;
				index = k.elt;
			}
			var _this = this.stack;
			var k = _this.head;
			var target;
			if(k == null) {
				target = null;
			} else {
				_this.head = k.next;
				target = k.elt;
			}
			var value;
			var _g = index.type;
			switch(target.type._hx_index) {
			case 2:
				switch(_g._hx_index) {
				case 0:
					var cTarget = js_Boot.__cast(target , object_ArrayObj);
					var cIndex = js_Boot.__cast(index , object_NumberObj);
					value = cTarget.value[cIndex.value | 0];
					break;
				case 1:
					var cIndex = js_Boot.__cast(index , object_StringObj);
					value = target.getMembers().value.h[cIndex.value];
					break;
				default:
					value = new object_NullObj(this);
				}
				break;
			case 3:
				if(_g._hx_index == 1) {
					var cTarget = js_Boot.__cast(target , object_HashObj);
					var cIndex = js_Boot.__cast(index , object_StringObj);
					var value1 = cTarget.value.h[cIndex.value];
					if(value1 == null) {
						value1 = cTarget.getMembers().value.h[cIndex.value];
					}
					value = value1;
				} else {
					value = new object_NullObj(this);
				}
				break;
			default:
				if(_g._hx_index == 1) {
					var cIndex = js_Boot.__cast(index , object_StringObj);
					value = target.getMembers().value.h[cIndex.value];
				} else {
					value = new object_NullObj(this);
				}
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(value == null ? new object_NullObj(this) : value,_this.head);
			break;
		case 24:
			var _this = this.stack;
			var k = _this.head;
			var value;
			if(k == null) {
				value = null;
			} else {
				_this.head = k.next;
				value = k.elt;
			}
			var _this = this.stack;
			var k = _this.head;
			var index;
			if(k == null) {
				index = null;
			} else {
				_this.head = k.next;
				index = k.elt;
			}
			var _this = this.stack;
			var k = _this.head;
			var target;
			if(k == null) {
				target = null;
			} else {
				_this.head = k.next;
				target = k.elt;
			}
			var _g = index.type;
			switch(target.type._hx_index) {
			case 2:
				switch(_g._hx_index) {
				case 0:
					var cTarget = js_Boot.__cast(target , object_ArrayObj);
					var cIndex = js_Boot.__cast(index , object_NumberObj);
					cTarget.value[cIndex.value | 0] = value;
					break;
				case 1:
					var cIndex = js_Boot.__cast(index , object_StringObj);
					target.getMembers().value.h[cIndex.value] = value;
					break;
				default:
					this.error.error("index operator cannot be used on this datatype");
				}
				break;
			case 3:
				if(_g._hx_index == 1) {
					var cTarget = js_Boot.__cast(target , object_HashObj);
					var cIndex = js_Boot.__cast(index , object_StringObj);
					cTarget.value.h[cIndex.value] = value;
				} else {
					this.error.error("index operator cannot be used on this datatype");
				}
				break;
			default:
				if(_g._hx_index == 1) {
					var cIndex = js_Boot.__cast(index , object_StringObj);
					target.getMembers().value.h[cIndex.value] = value;
				} else {
					this.error.error("index operator cannot be used on this datatype");
				}
			}
			break;
		case 25:
			var _this = this.stack;
			var target = _this.head == null ? null : _this.head.elt;
			var destructureIndex = this.instructions.readInt32();
			if(target.type == object_ObjectType.Array) {
				var cTarget = js_Boot.__cast(target , object_ArrayObj);
				var value = cTarget.value[destructureIndex];
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(value == null ? new object_NullObj(this) : value,_this.head);
			} else {
				this.error.error("cannot destructure object");
			}
			break;
		case 26:
			var _this = this.stack;
			var k = _this.head;
			var index;
			if(k == null) {
				index = null;
			} else {
				_this.head = k.next;
				index = k.elt;
			}
			var _this = this.stack;
			var target = _this.head == null ? null : _this.head.elt;
			if(target.type == object_ObjectType.Hash) {
				var cTarget = js_Boot.__cast(target , object_HashObj);
				var cIndex = js_Boot.__cast(index , object_StringObj);
				var value = cTarget.value.h[cIndex.value];
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(value == null ? new object_NullObj(this) : value,_this.head);
			} else {
				this.error.error("cannot destructure object");
			}
			break;
		default:
		}
	}
	,__class__: evaluator_Evaluator
};
var evaluator_Frame = function(parent,returnAddress,calledFunction) {
	this.parent = parent;
	this.returnAddress = returnAddress;
	this.calledFunction = calledFunction;
	this.env = new evaluator_Environment();
};
evaluator_Frame.__name__ = true;
evaluator_Frame.prototype = {
	getVariable: function(index) {
		var v = this.env.getVariable(index);
		if(v == null && this.parent != null) {
			return this.parent.getVariable(index);
		}
		return v;
	}
	,setVariable: function(index,value) {
		if(this.parent != null && this.parent.env.hasVariable(index) && !this.env.hasVariable(index)) {
			this.parent.env.setVariable(index,value);
		} else {
			this.env.setVariable(index,value);
		}
	}
	,__class__: evaluator_Frame
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = true;
haxe__$Int64__$_$_$Int64.prototype = {
	__class__: haxe__$Int64__$_$_$Int64
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
haxe_crypto_Adler32.__name__ = true;
haxe_crypto_Adler32.read = function(i) {
	var a = new haxe_crypto_Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
};
haxe_crypto_Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
	,__class__: haxe_crypto_Adler32
};
var haxe_ds_GenericCell = function(elt,next) {
	this.elt = elt;
	this.next = next;
};
haxe_ds_GenericCell.__name__ = true;
haxe_ds_GenericCell.prototype = {
	__class__: haxe_ds_GenericCell
};
var haxe_ds_GenericStack = function() {
};
haxe_ds_GenericStack.__name__ = true;
haxe_ds_GenericStack.prototype = {
	__class__: haxe_ds_GenericStack
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.keysIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return keys[idx - 1];
	}};
};
haxe_ds_StringMap.valueIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return h[keys[idx - 1]];
	}};
};
haxe_ds_StringMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		return haxe_ds_StringMap.keysIterator(this.h);
	}
	,iterator: function() {
		return haxe_ds_StringMap.valueIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,readAll: function(bufsize) {
		if(bufsize == null) {
			bufsize = 16384;
		}
		var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
		var total = new haxe_io_BytesBuffer();
		try {
			while(true) {
				var len = this.readBytes(buf,0,bufsize);
				if(len == 0) {
					throw haxe_Exception.thrown(haxe_io_Error.Blocked);
				}
				total.addBytes(buf,0,len);
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return total.getBytes();
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
	,__class__: haxe_io_Input
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	set_position: function(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	,readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeDouble: function(x) {
		var i64 = haxe_io_FPHelper.doubleToI64(x);
		if(this.bigEndian) {
			this.writeInt32(i64.high);
			this.writeInt32(i64.low);
		} else {
			this.writeInt32(i64.low);
			this.writeInt32(i64.high);
		}
	}
	,writeInt16: function(x) {
		if(x < -32768 || x >= 32768) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		this.writeUInt16(x & 65535);
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
haxe_io_FPHelper.doubleToI64 = function(v) {
	var i64 = haxe_io_FPHelper.i64tmp;
	haxe_io_FPHelper.helper.setFloat64(0,v,true);
	i64.low = haxe_io_FPHelper.helper.getInt32(0,true);
	i64.high = haxe_io_FPHelper.helper.getInt32(4,true);
	return i64;
};
var haxe_io_Path = function() { };
haxe_io_Path.__name__ = true;
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
haxe_iterators_MapKeyValueIterator.__name__ = true;
haxe_iterators_MapKeyValueIterator.prototype = {
	hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
	,__class__: haxe_iterators_MapKeyValueIterator
};
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__ : true, __constructs__ : ["DoubleQuotes","SingleQuotes"]
	,DoubleQuotes: {_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__ : true, __constructs__ : ["CInt","CFloat","CString","CIdent","CRegexp"]
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["r","opt"],$_)
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__ : true, __constructs__ : ["OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow","OpIn"]
	,OpAdd: {_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__ : true, __constructs__ : ["OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"]
	,OpIncrement: {_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
};
var haxe_macro_FunctionKind = $hxEnums["haxe.macro.FunctionKind"] = { __ename__ : true, __constructs__ : ["FAnonymous","FNamed","FArrow"]
	,FAnonymous: {_hx_index:0,__enum__:"haxe.macro.FunctionKind",toString:$estr}
	,FNamed: ($_=function(name,inlined) { return {_hx_index:1,name:name,inlined:inlined,__enum__:"haxe.macro.FunctionKind",toString:$estr}; },$_.__params__ = ["name","inlined"],$_)
	,FArrow: {_hx_index:2,__enum__:"haxe.macro.FunctionKind",toString:$estr}
};
var haxe_macro_ExprDef = $hxEnums["haxe.macro.ExprDef"] = { __ename__ : true, __constructs__ : ["EConst","EArray","EBinop","EField","EParenthesis","EObjectDecl","EArrayDecl","ECall","ENew","EUnop","EVars","EFunction","EBlock","EFor","EIf","EWhile","ESwitch","ETry","EReturn","EBreak","EContinue","EUntyped","EThrow","ECast","EDisplay","EDisplayNew","ETernary","ECheckType","EMeta"]
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,EArray: ($_=function(e1,e2) { return {_hx_index:1,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e1","e2"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:2,op:op,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["op","e1","e2"],$_)
	,EField: ($_=function(e,field) { return {_hx_index:3,e:e,field:field,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","field"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:4,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EObjectDecl: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,EArrayDecl: ($_=function(values) { return {_hx_index:6,values:values,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["values"],$_)
	,ECall: ($_=function(e,params) { return {_hx_index:7,e:e,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","params"],$_)
	,ENew: ($_=function(t,params) { return {_hx_index:8,t:t,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["t","params"],$_)
	,EUnop: ($_=function(op,postFix,e) { return {_hx_index:9,op:op,postFix:postFix,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["op","postFix","e"],$_)
	,EVars: ($_=function(vars) { return {_hx_index:10,vars:vars,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["vars"],$_)
	,EFunction: ($_=function(kind,f) { return {_hx_index:11,kind:kind,f:f,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["kind","f"],$_)
	,EBlock: ($_=function(exprs) { return {_hx_index:12,exprs:exprs,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["exprs"],$_)
	,EFor: ($_=function(it,expr) { return {_hx_index:13,it:it,expr:expr,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["it","expr"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:14,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","eif","eelse"],$_)
	,EWhile: ($_=function(econd,e,normalWhile) { return {_hx_index:15,econd:econd,e:e,normalWhile:normalWhile,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","e","normalWhile"],$_)
	,ESwitch: ($_=function(e,cases,edef) { return {_hx_index:16,e:e,cases:cases,edef:edef,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","cases","edef"],$_)
	,ETry: ($_=function(e,catches) { return {_hx_index:17,e:e,catches:catches,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","catches"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:18,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EBreak: {_hx_index:19,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EContinue: {_hx_index:20,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EUntyped: ($_=function(e) { return {_hx_index:21,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,EThrow: ($_=function(e) { return {_hx_index:22,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e"],$_)
	,ECast: ($_=function(e,t) { return {_hx_index:23,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","t"],$_)
	,EDisplay: ($_=function(e,displayKind) { return {_hx_index:24,e:e,displayKind:displayKind,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","displayKind"],$_)
	,EDisplayNew: ($_=function(t) { return {_hx_index:25,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["t"],$_)
	,ETernary: ($_=function(econd,eif,eelse) { return {_hx_index:26,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["econd","eif","eelse"],$_)
	,ECheckType: ($_=function(e,t) { return {_hx_index:27,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["e","t"],$_)
	,EMeta: ($_=function(s,e) { return {_hx_index:28,s:s,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_.__params__ = ["s","e"],$_)
};
var haxe_macro_DisplayKind = $hxEnums["haxe.macro.DisplayKind"] = { __ename__ : true, __constructs__ : ["DKCall","DKDot","DKStructure","DKMarked","DKPattern"]
	,DKCall: {_hx_index:0,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKDot: {_hx_index:1,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKStructure: {_hx_index:2,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKMarked: {_hx_index:3,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKPattern: ($_=function(outermost) { return {_hx_index:4,outermost:outermost,__enum__:"haxe.macro.DisplayKind",toString:$estr}; },$_.__params__ = ["outermost"],$_)
};
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__ : true, __constructs__ : ["TPath","TFunction","TAnonymous","TParent","TExtend","TOptional","TNamed","TIntersection"]
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["tl"],$_)
};
var haxe_zip_Compress = function() { };
haxe_zip_Compress.__name__ = true;
haxe_zip_Compress.run = function(s,level) {
	throw haxe_Exception.thrown("Not implemented for this platform");
};
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__ : true, __constructs__ : ["Found","NeedBit","NeedBits"]
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["n","table"],$_)
};
var haxe_zip_HuffTools = function() {
};
haxe_zip_HuffTools.__name__ = true;
haxe_zip_HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var b = t.right;
			var a = t.left;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g = t.table;
			var _g = t.n;
			throw haxe_Exception.thrown("assert");
		}
	}
	,treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var b = t.right;
				var a = t.left;
				return haxe_zip_Huffman.NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	,treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var b = t.right;
			var a = t.left;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	,treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	,make: function(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0));
		}
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var p = lengths[i + pos];
			if(p >= maxbits) {
				throw haxe_Exception.thrown("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g = 1;
		var _g1 = maxbits - 1;
		while(_g < _g1) {
			var i = _g++;
			code = code + counts[i] << 1;
			tmp[i] = code;
		}
		var bits = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var l = lengths[i + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
	,__class__: haxe_zip_HuffTools
};
var haxe_zip__$InflateImpl_Window = function(hasCrc) {
	this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
	this.pos = 0;
	if(hasCrc) {
		this.crc = new haxe_crypto_Adler32();
	}
};
haxe_zip__$InflateImpl_Window.__name__ = true;
haxe_zip__$InflateImpl_Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	,addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	,addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	,getLastChar: function() {
		return this.buffer.b[this.pos - 1];
	}
	,available: function() {
		return this.pos;
	}
	,checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
	,__class__: haxe_zip__$InflateImpl_Window
};
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__ : true, __constructs__ : ["Head","Block","CData","Flat","Crc","Dist","DistOne","Done"]
	,Head: {_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
var haxe_zip_InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new haxe_zip_HuffTools();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new haxe_zip__$InflateImpl_Window(crc);
};
haxe_zip_InflateImpl.__name__ = true;
haxe_zip_InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
	var output = new haxe_io_BytesBuffer();
	var inflate = new haxe_zip_InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
};
haxe_zip_InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	,readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	,getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	,getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	,getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	,resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	}
	,addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	,addByte: function(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	,addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	}
	,addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	,applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var b = h.right;
			var a = h.left;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var tbl = h.table;
			var n = h.n;
			return this.applyHuffman(tbl[this.getBits(n)]);
		}
	}
	,inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
		}
	}
	,inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw haxe_Exception.thrown("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw haxe_Exception.thrown("Invalid data");
			}
			if(fdict) {
				throw haxe_Exception.thrown("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g = hclen;
				var _g1 = 19;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g = 0;
				var _g1 = hlit + hdist;
				while(_g < _g1) {
					var i = _g++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			var crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw haxe_Exception.thrown("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen);
				this.len -= rlen;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			var rlen = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen);
			this.len -= rlen;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
	,__class__: haxe_zip_InflateImpl
};
var haxe_zip_Uncompress = function() { };
haxe_zip_Uncompress.__name__ = true;
haxe_zip_Uncompress.run = function(src,bufsize) {
	return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__implements = function(o,iface) {
	return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var lexer_Helper = function() { };
lexer_Helper.__name__ = true;
lexer_Helper.isLinebreak = function(s) {
	return new EReg("\r\n|\r|\n","").match(s);
};
lexer_Helper.isAscii = function(s) {
	return new EReg("^[a-zA-Z0-9_]+$","").match(s);
};
lexer_Helper.isNumber = function(s) {
	return new EReg("^[0-9]+$","").match(s);
};
var lexer_TokenType = $hxEnums["lexer.TokenType"] = { __ename__ : true, __constructs__ : ["Illegal","Eof","Ident","Number","String","Assign","PlusAssign","MinusAssign","AsteriskAssign","SlashAssign","PercentAssign","Plus","Minus","Asterisk","Slash","Percent","Pow","Bang","Equals","NotEquals","LogicAnd","LogicOr","GreaterThan","LessThan","GreaterThanOrEqual","LessThanOrEqual","BitAnd","BitOr","ConcatString","Comma","Semicolon","Dot","Colon","LParen","RParen","LBrace","RBrace","LBracket","RBracket","ExclusiveRange","InclusiveRange","Function","Let","Mut","True","False","If","Else","While","Return","Import","Break","Null","For","In"]
	,Illegal: {_hx_index:0,__enum__:"lexer.TokenType",toString:$estr}
	,Eof: {_hx_index:1,__enum__:"lexer.TokenType",toString:$estr}
	,Ident: {_hx_index:2,__enum__:"lexer.TokenType",toString:$estr}
	,Number: {_hx_index:3,__enum__:"lexer.TokenType",toString:$estr}
	,String: {_hx_index:4,__enum__:"lexer.TokenType",toString:$estr}
	,Assign: {_hx_index:5,__enum__:"lexer.TokenType",toString:$estr}
	,PlusAssign: {_hx_index:6,__enum__:"lexer.TokenType",toString:$estr}
	,MinusAssign: {_hx_index:7,__enum__:"lexer.TokenType",toString:$estr}
	,AsteriskAssign: {_hx_index:8,__enum__:"lexer.TokenType",toString:$estr}
	,SlashAssign: {_hx_index:9,__enum__:"lexer.TokenType",toString:$estr}
	,PercentAssign: {_hx_index:10,__enum__:"lexer.TokenType",toString:$estr}
	,Plus: {_hx_index:11,__enum__:"lexer.TokenType",toString:$estr}
	,Minus: {_hx_index:12,__enum__:"lexer.TokenType",toString:$estr}
	,Asterisk: {_hx_index:13,__enum__:"lexer.TokenType",toString:$estr}
	,Slash: {_hx_index:14,__enum__:"lexer.TokenType",toString:$estr}
	,Percent: {_hx_index:15,__enum__:"lexer.TokenType",toString:$estr}
	,Pow: {_hx_index:16,__enum__:"lexer.TokenType",toString:$estr}
	,Bang: {_hx_index:17,__enum__:"lexer.TokenType",toString:$estr}
	,Equals: {_hx_index:18,__enum__:"lexer.TokenType",toString:$estr}
	,NotEquals: {_hx_index:19,__enum__:"lexer.TokenType",toString:$estr}
	,LogicAnd: {_hx_index:20,__enum__:"lexer.TokenType",toString:$estr}
	,LogicOr: {_hx_index:21,__enum__:"lexer.TokenType",toString:$estr}
	,GreaterThan: {_hx_index:22,__enum__:"lexer.TokenType",toString:$estr}
	,LessThan: {_hx_index:23,__enum__:"lexer.TokenType",toString:$estr}
	,GreaterThanOrEqual: {_hx_index:24,__enum__:"lexer.TokenType",toString:$estr}
	,LessThanOrEqual: {_hx_index:25,__enum__:"lexer.TokenType",toString:$estr}
	,BitAnd: {_hx_index:26,__enum__:"lexer.TokenType",toString:$estr}
	,BitOr: {_hx_index:27,__enum__:"lexer.TokenType",toString:$estr}
	,ConcatString: {_hx_index:28,__enum__:"lexer.TokenType",toString:$estr}
	,Comma: {_hx_index:29,__enum__:"lexer.TokenType",toString:$estr}
	,Semicolon: {_hx_index:30,__enum__:"lexer.TokenType",toString:$estr}
	,Dot: {_hx_index:31,__enum__:"lexer.TokenType",toString:$estr}
	,Colon: {_hx_index:32,__enum__:"lexer.TokenType",toString:$estr}
	,LParen: {_hx_index:33,__enum__:"lexer.TokenType",toString:$estr}
	,RParen: {_hx_index:34,__enum__:"lexer.TokenType",toString:$estr}
	,LBrace: {_hx_index:35,__enum__:"lexer.TokenType",toString:$estr}
	,RBrace: {_hx_index:36,__enum__:"lexer.TokenType",toString:$estr}
	,LBracket: {_hx_index:37,__enum__:"lexer.TokenType",toString:$estr}
	,RBracket: {_hx_index:38,__enum__:"lexer.TokenType",toString:$estr}
	,ExclusiveRange: {_hx_index:39,__enum__:"lexer.TokenType",toString:$estr}
	,InclusiveRange: {_hx_index:40,__enum__:"lexer.TokenType",toString:$estr}
	,Function: {_hx_index:41,__enum__:"lexer.TokenType",toString:$estr}
	,Let: {_hx_index:42,__enum__:"lexer.TokenType",toString:$estr}
	,Mut: {_hx_index:43,__enum__:"lexer.TokenType",toString:$estr}
	,True: {_hx_index:44,__enum__:"lexer.TokenType",toString:$estr}
	,False: {_hx_index:45,__enum__:"lexer.TokenType",toString:$estr}
	,If: {_hx_index:46,__enum__:"lexer.TokenType",toString:$estr}
	,Else: {_hx_index:47,__enum__:"lexer.TokenType",toString:$estr}
	,While: {_hx_index:48,__enum__:"lexer.TokenType",toString:$estr}
	,Return: {_hx_index:49,__enum__:"lexer.TokenType",toString:$estr}
	,Import: {_hx_index:50,__enum__:"lexer.TokenType",toString:$estr}
	,Break: {_hx_index:51,__enum__:"lexer.TokenType",toString:$estr}
	,Null: {_hx_index:52,__enum__:"lexer.TokenType",toString:$estr}
	,For: {_hx_index:53,__enum__:"lexer.TokenType",toString:$estr}
	,In: {_hx_index:54,__enum__:"lexer.TokenType",toString:$estr}
};
var lexer_Keyword = function() { };
lexer_Keyword.__name__ = true;
lexer_Keyword.isKeyword = function(ident) {
	return lexer_Keyword.keywords.h[ident] != null;
};
lexer_Keyword.getKeyword = function(ident) {
	return lexer_Keyword.keywords.h[ident];
};
var lexer_Lexer = function(filename,code) {
	this.inString = false;
	this.position = 0;
	this.currentChar = " ";
	this.filename = haxe_io_Path.normalize(filename);
	this.code = code;
};
lexer_Lexer.__name__ = true;
lexer_Lexer.prototype = {
	readChar: function() {
		this.currentChar = this.position >= this.code.length ? "\x00" : this.code.charAt(this.position);
		this.position++;
		this.eatComment();
	}
	,peekChar: function() {
		if(this.position >= this.code.length) {
			return "\x00";
		} else {
			return this.code.charAt(this.position);
		}
	}
	,peekCharN: function(n) {
		var lastPosition = this.position;
		var lastChar = this.currentChar;
		var chars = [];
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var _ = _g++;
			this.readChar();
			chars.push(this.currentChar);
		}
		this.position = lastPosition;
		this.currentChar = lastChar;
		return chars;
	}
	,readIdent: function() {
		var startPosition = this.position;
		while(true) {
			var s = this.peekChar();
			if(!(new EReg("^[a-zA-Z0-9_]+$","").match(s) || this.peekChar() == "_")) {
				break;
			}
			this.readChar();
		}
		return this.code.substring(startPosition - 1,this.position);
	}
	,readString: function() {
		this.inString = true;
		this.readChar();
		var string_b = "";
		while(this.currentChar != "\"" && this.currentChar != "\x00") {
			if(this.currentChar == "\\") {
				this.readChar();
			}
			string_b += Std.string(this.currentChar);
			this.readChar();
		}
		this.inString = false;
		return string_b;
	}
	,readNumber: function() {
		var startPosition = this.position;
		var peek = this.peekCharN(2);
		while(new EReg("^[0-9]+$","").match(peek[0]) || peek[0] == "." && peek[1] != ".") {
			this.readChar();
			peek = this.peekCharN(2);
		}
		return this.code.substring(startPosition - 1,this.position);
	}
	,eatWhitespace: function() {
		while(true) {
			var tmp;
			if(this.currentChar != " ") {
				var s = this.currentChar;
				tmp = new EReg("\r\n|\r|\n","").match(s);
			} else {
				tmp = true;
			}
			if(!(tmp || this.currentChar == "\t")) {
				break;
			}
			this.readChar();
		}
	}
	,eatComment: function() {
		if(!this.inString && this.currentChar == "/" && this.peekChar() == "/") {
			while(true) {
				var s = this.currentChar;
				if(!(!new EReg("\r\n|\r|\n","").match(s) && this.currentChar != "\x00")) {
					break;
				}
				this.readChar();
			}
		}
	}
	,tokenize: function() {
		while(this.currentChar != "\x00") {
			var token = this.readToken();
			console.log("src/lexer/Lexer.hx:107:","" + token.position + " " + Std.string(token.type) + " " + token.literal);
		}
	}
	,peekToken: function() {
		var lastPostion = this.position;
		var token = this.readToken();
		this.position = lastPostion;
		return token;
	}
	,peekTokenN: function(n) {
		var lastPostion = this.position;
		var tokens = [];
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var _ = _g++;
			tokens.push(this.readToken());
		}
		this.position = lastPostion;
		return tokens;
	}
	,readToken: function() {
		this.readChar();
		this.eatWhitespace();
		switch(this.currentChar) {
		case "\x00":
			return new lexer_Token(lexer_TokenType.Eof,this.position,this.currentChar);
		case "!":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.NotEquals,this.position,"!=");
			} else {
				return new lexer_Token(lexer_TokenType.Bang,this.position,"!");
			}
			break;
		case "\"":
			var string = this.readString();
			return new lexer_Token(lexer_TokenType.String,this.position - 1,string);
		case "%":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.PercentAssign,this.position,"%=");
			} else {
				return new lexer_Token(lexer_TokenType.Percent,this.position,"%");
			}
			break;
		case "&":
			if(this.peekChar() == "&") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.LogicAnd,this.position,"&&");
			} else {
				return new lexer_Token(lexer_TokenType.BitAnd,this.position,"&");
			}
			break;
		case "(":
			return new lexer_Token(lexer_TokenType.LParen,this.position,"(");
		case ")":
			return new lexer_Token(lexer_TokenType.RParen,this.position,")");
		case "*":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.AsteriskAssign,this.position,"*=");
			} else {
				return new lexer_Token(lexer_TokenType.Asterisk,this.position,"*");
			}
			break;
		case "+":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.PlusAssign,this.position,"+=");
			} else {
				return new lexer_Token(lexer_TokenType.Plus,this.position,"+");
			}
			break;
		case ",":
			return new lexer_Token(lexer_TokenType.Comma,this.position,",");
		case "-":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.MinusAssign,this.position,"-=");
			} else {
				return new lexer_Token(lexer_TokenType.Minus,this.position,"-");
			}
			break;
		case ".":
			var _g = this.peekCharN(2);
			if(_g.length == 2) {
				if(_g[0] == ".") {
					if(_g[1] == ".") {
						this.readChar();
						this.readChar();
						return new lexer_Token(lexer_TokenType.ExclusiveRange,this.position,"...");
					} else {
						this.readChar();
						return new lexer_Token(lexer_TokenType.InclusiveRange,this.position,"..");
					}
				} else {
					return new lexer_Token(lexer_TokenType.Dot,this.position,".");
				}
			} else {
				return new lexer_Token(lexer_TokenType.Dot,this.position,".");
			}
			break;
		case "/":
			new lexer_Token(lexer_TokenType.Slash,this.position,"/");
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.SlashAssign,this.position,"/=");
			} else {
				return new lexer_Token(lexer_TokenType.Slash,this.position,"/");
			}
			break;
		case ":":
			return new lexer_Token(lexer_TokenType.Colon,this.position,":");
		case ";":
			return new lexer_Token(lexer_TokenType.Semicolon,this.position,";");
		case "<":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.LessThanOrEqual,this.position,"<=");
			} else {
				return new lexer_Token(lexer_TokenType.LessThan,this.position,"<");
			}
			break;
		case "=":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.Equals,this.position,"==");
			} else {
				return new lexer_Token(lexer_TokenType.Assign,this.position,"=");
			}
			break;
		case ">":
			switch(this.peekChar()) {
			case "<":
				this.readChar();
				return new lexer_Token(lexer_TokenType.ConcatString,this.position,"><");
			case "=":
				this.readChar();
				return new lexer_Token(lexer_TokenType.GreaterThanOrEqual,this.position,">=");
			default:
				return new lexer_Token(lexer_TokenType.GreaterThan,this.position,">");
			}
			break;
		case "[":
			return new lexer_Token(lexer_TokenType.LBracket,this.position,"[");
		case "]":
			return new lexer_Token(lexer_TokenType.RBracket,this.position,"]");
		case "{":
			return new lexer_Token(lexer_TokenType.LBrace,this.position,"{");
		case "|":
			if(this.peekChar() == "|") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.LogicOr,this.position,"|");
			} else {
				return new lexer_Token(lexer_TokenType.BitOr,this.position,"|");
			}
			break;
		case "}":
			return new lexer_Token(lexer_TokenType.RBrace,this.position,"}");
		default:
			var s = this.currentChar;
			if(new EReg("^[0-9]+$","").match(s)) {
				var number = this.readNumber();
				return new lexer_Token(lexer_TokenType.Number,this.position,number);
			}
			var s = this.currentChar;
			if(new EReg("^[a-zA-Z0-9_]+$","").match(s)) {
				var ident = this.readIdent();
				if(lexer_Keyword.isKeyword(ident)) {
					return new lexer_Token(lexer_Keyword.getKeyword(ident),this.position,ident);
				} else {
					return new lexer_Token(lexer_TokenType.Ident,this.position,ident);
				}
			}
			return new lexer_Token(lexer_TokenType.Illegal,this.position,this.currentChar);
		}
	}
	,__class__: lexer_Lexer
};
var lexer_Token = function(type,position,literal) {
	this.type = type;
	this.position = position - literal.length;
	this.literal = literal;
};
lexer_Token.__name__ = true;
lexer_Token.prototype = {
	__class__: lexer_Token
};
var std_lib_MemberObject = function(evaluator) {
	this.members = new haxe_ds_StringMap();
	this.evaluator = evaluator;
};
std_lib_MemberObject.__name__ = true;
std_lib_MemberObject.prototype = {
	getMembers: function() {
		return new object_HashObj(this.members,this.evaluator);
	}
	,addFunctionMember: function(memberName,parametersCount,memberFunction) {
		var _this = this.members;
		var value = new object_ClosureObj(new object_BuiltInFunctionObj(memberFunction,parametersCount,this.evaluator),this.evaluator.currentFrame,this.evaluator);
		_this.h[memberName] = value;
	}
	,callFunctionFunction: function(name,parameters) {
		var func = js_Boot.__cast(this.members.h[name] , object_ClosureObj);
		this.evaluator.callFunction(func,parameters);
	}
	,addObjectMember: function(name,object) {
		this.members.h[name] = object;
	}
	,error: function(message) {
		this.evaluator.error.error(message);
	}
	,assertParameterType: function(p,expected) {
		if(p.type != expected) {
			this.error("expected " + Std.string(expected) + ", got " + Std.string(p.type));
		}
	}
	,__class__: std_lib_MemberObject
};
var object__$ArrayObj_ArrayIterator = function(evaluator,value) {
	std_lib_MemberObject.call(this,evaluator);
	var index = -1;
	this.addFunctionMember("next",0,function(p) {
		index += 1;
		return value[index];
	});
	this.addFunctionMember("hasNext",0,function(p) {
		return new object_NumberObj(index < value.length - 1 ? 1 : 0,evaluator);
	});
};
object__$ArrayObj_ArrayIterator.__name__ = true;
object__$ArrayObj_ArrayIterator.__super__ = std_lib_MemberObject;
object__$ArrayObj_ArrayIterator.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: object__$ArrayObj_ArrayIterator
});
var object_Object = function(type,evaluator) {
	std_lib_MemberObject.call(this,evaluator);
	this.type = type;
};
object_Object.__name__ = true;
object_Object.__super__ = std_lib_MemberObject;
object_Object.prototype = $extend(std_lib_MemberObject.prototype,{
	toString: function() {
		return "#object";
	}
	,__class__: object_Object
});
var object_ArrayObj = function(value,evaluator) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Array,evaluator);
	this.value = value;
	if(evaluator == null) {
		return;
	}
	this.addFunctionMember("Iterator",0,function(p) {
		return new object__$ArrayObj_ArrayIterator(evaluator,value).getMembers();
	});
	this.addFunctionMember("length",0,function(p) {
		return new object_NumberObj(_gthis.value.length,evaluator);
	});
	this.addFunctionMember("toString",0,function(p) {
		return new object_StringObj(_gthis.value.toString(),evaluator);
	});
	this.addFunctionMember("push",1,function(p) {
		_gthis.value.push(p[0]);
		return new object_NumberObj(_gthis.value.length,evaluator);
	});
	this.addFunctionMember("pop",0,function(p) {
		return _gthis.value.pop();
	});
	this.addFunctionMember("map",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Closure);
		var callback = js_Boot.__cast(p[0] , object_ClosureObj);
		var _g_current = 0;
		var _g_array = _gthis.value;
		while(_g_current < _g_array.length) {
			var _g1_value = _g_array[_g_current];
			var _g1_key = _g_current++;
			var k = _g1_key;
			var v = _g1_value;
			_gthis.value[k] = evaluator.callFunction(callback,[v]);
		}
		return new object_NullObj(evaluator);
	});
};
object_ArrayObj.__name__ = true;
object_ArrayObj.__super__ = object_Object;
object_ArrayObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		var _this = this.value;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].toString();
		}
		return result.toString();
	}
	,__class__: object_ArrayObj
});
var object_Function = function(type,parametersCount,evaluator) {
	object_Object.call(this,type,evaluator);
	this.parametersCount = parametersCount;
};
object_Function.__name__ = true;
object_Function.__super__ = object_Object;
object_Function.prototype = $extend(object_Object.prototype,{
	__class__: object_Function
});
var object_BuiltInFunctionObj = function(func,parametersCount,evaluator) {
	object_Function.call(this,object_ObjectType.BuiltInFunction,parametersCount,evaluator);
	this.func = func;
	if(evaluator == null) {
		return;
	}
};
object_BuiltInFunctionObj.__name__ = true;
object_BuiltInFunctionObj.__super__ = object_Function;
object_BuiltInFunctionObj.prototype = $extend(object_Function.prototype,{
	toString: function() {
		return "#func(BuiltIn)";
	}
	,__class__: object_BuiltInFunctionObj
});
var object_ClosureObj = function(func,context,evaluator) {
	object_Object.call(this,object_ObjectType.Closure,evaluator);
	this.func = func;
	this.context = context;
};
object_ClosureObj.__name__ = true;
object_ClosureObj.__super__ = object_Object;
object_ClosureObj.prototype = $extend(object_Object.prototype,{
	getMembers: function() {
		return this.func.getMembers();
	}
	,toString: function() {
		return "#closure(" + this.func.toString() + ")";
	}
	,__class__: object_ClosureObj
});
var object__$HashObj_HashIterator = function(evaluator,value) {
	std_lib_MemberObject.call(this,evaluator);
	var iterator_map;
	var iterator_keys;
	var map = value;
	iterator_map = map;
	iterator_keys = map.keys();
	this.addFunctionMember("next",0,function(p) {
		var key = iterator_keys.next();
		var next_value = iterator_map.get(key);
		var next_key = key;
		return new object_ArrayObj([new object_StringObj(next_key,evaluator),next_value],evaluator);
	});
	this.addFunctionMember("hasNext",0,function(p) {
		return new object_NumberObj(iterator_keys.hasNext() ? 1 : 0,evaluator);
	});
};
object__$HashObj_HashIterator.__name__ = true;
object__$HashObj_HashIterator.__super__ = std_lib_MemberObject;
object__$HashObj_HashIterator.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: object__$HashObj_HashIterator
});
var object_HashObj = function(value,evaluator) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Hash,evaluator);
	this.value = value;
	if(evaluator == null) {
		return;
	}
	this.addFunctionMember("Iterator",0,function(p) {
		return new object__$HashObj_HashIterator(evaluator,value).getMembers();
	});
	this.addFunctionMember("toString",0,function(p) {
		return new object_StringObj(_gthis.toString(),evaluator);
	});
	this.addFunctionMember("length",0,function(p) {
		return new object_NumberObj(Lambda.count(_gthis.value),evaluator);
	});
};
object_HashObj.__name__ = true;
object_HashObj.__super__ = object_Object;
object_HashObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		var buffer_b = "";
		buffer_b += "{";
		var map = this.value;
		var iterator_map = map;
		var iterator_keys = map.keys();
		while(iterator_keys.hasNext()) {
			var key = iterator_keys.next();
			var _g = { value : iterator_map.get(key), key : key};
			var k = _g.key;
			var v = _g.value;
			buffer_b += k == null ? "null" : "" + k;
			buffer_b += ": ";
			buffer_b += Std.string(v.toString());
			if(iterator_keys.hasNext()) {
				buffer_b += ", ";
			}
		}
		buffer_b += "}";
		return buffer_b;
	}
	,__class__: object_HashObj
});
var object_NullObj = function(evaluator) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Null,evaluator);
	if(evaluator == null) {
		return;
	}
	this.addFunctionMember("toString",0,function(p) {
		return new object_StringObj(_gthis.toString(),evaluator);
	});
};
object_NullObj.__name__ = true;
object_NullObj.__super__ = object_Object;
object_NullObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		return "null";
	}
	,__class__: object_NullObj
});
var object_NumberObj = function(value,evaluator) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Number,evaluator);
	this.value = value;
	if(evaluator == null) {
		return;
	}
	this.addFunctionMember("toString",0,function(p) {
		return new object_StringObj(_gthis.toString(),evaluator);
	});
};
object_NumberObj.__name__ = true;
object_NumberObj.__super__ = object_Object;
object_NumberObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		return Std.string(this.value);
	}
	,__class__: object_NumberObj
});
var object_ObjectType = $hxEnums["object.ObjectType"] = { __ename__ : true, __constructs__ : ["Number","String","Array","Hash","BuiltInFunction","UserFunction","Closure","Null"]
	,Number: {_hx_index:0,__enum__:"object.ObjectType",toString:$estr}
	,String: {_hx_index:1,__enum__:"object.ObjectType",toString:$estr}
	,Array: {_hx_index:2,__enum__:"object.ObjectType",toString:$estr}
	,Hash: {_hx_index:3,__enum__:"object.ObjectType",toString:$estr}
	,BuiltInFunction: {_hx_index:4,__enum__:"object.ObjectType",toString:$estr}
	,UserFunction: {_hx_index:5,__enum__:"object.ObjectType",toString:$estr}
	,Closure: {_hx_index:6,__enum__:"object.ObjectType",toString:$estr}
	,Null: {_hx_index:7,__enum__:"object.ObjectType",toString:$estr}
};
var object_StringObj = function(value,evaluator) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.String,evaluator);
	this.value = value;
	if(evaluator == null) {
		return;
	}
	this.addFunctionMember("toString",0,function(p) {
		return new object_StringObj(_gthis.toString(),evaluator);
	});
	this.addFunctionMember("length",0,function(p) {
		return new object_NumberObj(_gthis.value.length,evaluator);
	});
	this.addFunctionMember("charAt",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Number);
		var index = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var v = _gthis.value.charAt(index);
		if(v == null) {
			return new object_NullObj(evaluator);
		} else {
			return new object_StringObj(v,evaluator);
		}
	});
	this.addFunctionMember("split",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.String);
		var separator = (js_Boot.__cast(p[0] , object_StringObj)).value;
		var arr = [];
		var _g = 0;
		var _g1 = _gthis.value.split(separator);
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			arr.push(new object_StringObj(v,evaluator));
		}
		return new object_ArrayObj(arr,evaluator);
	});
};
object_StringObj.__name__ = true;
object_StringObj.__super__ = object_Object;
object_StringObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		return this.value;
	}
	,__class__: object_StringObj
});
var object_UserFunctionObj = function(position,parametersCount,evaluator) {
	var _gthis = this;
	object_Function.call(this,object_ObjectType.UserFunction,parametersCount,evaluator);
	this.position = position;
	if(evaluator == null) {
		return;
	}
	this.addFunctionMember("toString",0,function(p) {
		return new object_StringObj(_gthis.toString(),evaluator);
	});
};
object_UserFunctionObj.__name__ = true;
object_UserFunctionObj.__super__ = object_Function;
object_UserFunctionObj.prototype = $extend(object_Function.prototype,{
	toString: function() {
		return "func(" + this.position + ", UserDefined)";
	}
	,__class__: object_UserFunctionObj
});
var parser_ExpressionParser = function(parser,lexer) {
	this.parser = parser;
	this.lexer = lexer;
};
parser_ExpressionParser.__name__ = true;
parser_ExpressionParser.prototype = {
	parseExpression: function() {
		return new ast_nodes_ExpressionNode(this.parser.currentToken.position,this.disjunction());
	}
	,disjunction: function() {
		var left = this.conjunction();
		while(this.parser.currentToken.type == lexer_TokenType.LogicOr) {
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.conjunction();
			left = new ast_nodes_OperatorNode(nodePos,ast_NodeType.LogicOr,left,right);
		}
		return left;
	}
	,conjunction: function() {
		var left = this.comparison();
		while(this.parser.currentToken.type == lexer_TokenType.LogicAnd) {
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.comparison();
			left = new ast_nodes_OperatorNode(nodePos,ast_NodeType.LogicAnd,left,right);
		}
		return left;
	}
	,comparison: function() {
		var left = this.range();
		var type;
		switch(this.parser.currentToken.type._hx_index) {
		case 18:
			type = ast_NodeType.Equals;
			break;
		case 19:
			type = ast_NodeType.NotEquals;
			break;
		case 22:
			type = ast_NodeType.GreaterThan;
			break;
		case 23:
			type = ast_NodeType.LessThan;
			break;
		case 24:
			type = ast_NodeType.GreaterThanOrEqual;
			break;
		case 25:
			type = ast_NodeType.LessThanOrEqual;
			break;
		default:
			return left;
		}
		this.parser.nextToken();
		var nodePos = this.parser.currentToken.position;
		var right = this.range();
		return new ast_nodes_OperatorNode(nodePos,type,left,right);
	}
	,range: function() {
		var start = new ast_nodes_ExpressionNode(this.parser.currentToken.position,this.numeric());
		_hx_loop1: while(true) {
			var inclusive;
			switch(this.parser.currentToken.type._hx_index) {
			case 39:
				inclusive = false;
				break;
			case 40:
				inclusive = true;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var end = new ast_nodes_ExpressionNode(nodePos,this.numeric());
			start = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_RangeNode(nodePos,start,end,inclusive));
		}
		return start;
	}
	,numeric: function() {
		var left = this.term();
		_hx_loop1: while(true) {
			var type;
			switch(this.parser.currentToken.type._hx_index) {
			case 11:
				type = ast_NodeType.Add;
				break;
			case 12:
				type = ast_NodeType.Subtract;
				break;
			case 28:
				type = ast_NodeType.ConcatString;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.term();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,term: function() {
		var left = this.signedFactor();
		_hx_loop1: while(true) {
			var type;
			switch(this.parser.currentToken.type._hx_index) {
			case 13:
				type = ast_NodeType.Multiply;
				break;
			case 14:
				type = ast_NodeType.Divide;
				break;
			case 15:
				type = ast_NodeType.Modulo;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.term();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,signedFactor: function() {
		switch(this.parser.currentToken.type._hx_index) {
		case 12:
			this.parser.nextToken();
			var right = this.access();
			return new ast_nodes_OperatorNode(this.parser.currentToken.position,ast_NodeType.Negate,null,right);
		case 17:
			this.parser.nextToken();
			var right = this.access();
			return new ast_nodes_OperatorNode(this.parser.currentToken.position,ast_NodeType.Not,null,right);
		default:
			return this.access();
		}
	}
	,access: function() {
		var left = new ast_nodes_ExpressionNode(this.parser.currentToken.position,this.factor());
		_hx_loop1: while(true) switch(this.parser.currentToken.type._hx_index) {
		case 31:
			left = this.parser.parseIndex(left);
			break;
		case 33:
			left = this.parser.parseCall(left);
			break;
		case 37:
			left = this.parser.parseIndex(left);
			break;
		default:
			break _hx_loop1;
		}
		return left;
	}
	,factor: function() {
		switch(this.parser.currentToken.type._hx_index) {
		case 2:
			var ident = new ast_nodes_IdentNode(this.parser.currentToken.position,this.parser.currentToken.literal);
			this.parser.nextToken();
			return ident;
		case 3:
			return this.parser.parseNumber();
		case 4:
			var string = new ast_nodes_datatypes_StringNode(this.parser.currentToken.position,this.parser.currentToken.literal);
			this.parser.nextToken();
			return string;
		case 33:
			this.parser.nextToken();
			var disjunction = this.disjunction();
			if(this.parser.currentToken.type != lexer_TokenType.RParen) {
				this.parser.error.unexpectedToken(this.parser.currentToken,"`)`");
			}
			this.parser.nextToken();
			return disjunction;
		case 35:
			return this.parser.parseHash();
		case 37:
			return this.parser.parseArray();
		case 41:
			this.parser.nextToken();
			return this.parser.parseFunction();
		case 44:
			var boolean = new ast_nodes_BooleanNode(this.parser.currentToken.position,true);
			this.parser.nextToken();
			return boolean;
		case 45:
			var boolean = new ast_nodes_BooleanNode(this.parser.currentToken.position,false);
			this.parser.nextToken();
			return boolean;
		case 46:
			var ifN = this.parser.parseIf();
			return ifN;
		case 52:
			var nullN = new ast_nodes_datatypes_NullNode(this.parser.currentToken.position);
			this.parser.nextToken();
			return nullN;
		default:
			this.parser.error.unexpectedToken(this.parser.currentToken,"expression");
			return new ast_nodes_Node(-1,ast_NodeType.Ident);
		}
	}
	,__class__: parser_ExpressionParser
};
var parser_Parser = function(lexer) {
	this.lexer = lexer;
	this.ast = new ast_nodes_FileNode(1,lexer.filename,lexer.code);
	this.error = new error_CompileError(lexer.filename,lexer.code);
	this.expressionParser = new parser_ExpressionParser(this,lexer);
	this.currentToken = lexer.readToken();
};
parser_Parser.__name__ = true;
parser_Parser.prototype = {
	generateAst: function() {
		while(this.currentToken.type != lexer_TokenType.Eof) this.parseToken(this.ast);
	}
	,writeAst: function() {
	}
	,nextToken: function() {
		this.currentToken = this.lexer.readToken();
	}
	,parseNumber: function() {
		var nodePos = this.currentToken.position;
		var n = parseFloat(this.currentToken.literal);
		this.nextToken();
		return new ast_nodes_datatypes_FloatNode(nodePos,n);
	}
	,parseBlock: function() {
		this.nextToken();
		var block = new ast_nodes_BlockNode(this.currentToken.position);
		while(this.currentToken.type != lexer_TokenType.RBrace) {
			if(this.currentToken.type == lexer_TokenType.Eof) {
				this.error.unexpectedEof(this.currentToken);
			}
			this.parseToken(block);
		}
		return block;
	}
	,parseFunction: function() {
		var nodePos = this.currentToken.position;
		this.assertToken(lexer_TokenType.LParen,"`(`");
		this.nextToken();
		var parameters = [];
		while(this.currentToken.type != lexer_TokenType.RParen) {
			if(this.currentToken.type == lexer_TokenType.Ident) {
				parameters.push(new ast_nodes_IdentNode(this.currentToken.position,this.currentToken.literal));
				if(this.lexer.peekToken().type != lexer_TokenType.Comma && this.lexer.peekToken().type != lexer_TokenType.RParen) {
					this.error.unexpectedToken(this.currentToken,"`,` or `)`");
				}
			} else if(this.currentToken.type == lexer_TokenType.Comma && this.lexer.peekToken().type == lexer_TokenType.RParen) {
				this.error.unexpectedToken(this.currentToken,"identifier or `)`");
			} else {
				this.assertToken(lexer_TokenType.Comma,"identifier");
			}
			this.nextToken();
		}
		this.nextToken();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var block = this.parseBlock();
		this.nextToken();
		return new ast_nodes_datatypes_FunctionNode(nodePos,block,parameters);
	}
	,parseCall: function(target) {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var callParameters = [];
		while(this.currentToken.type != lexer_TokenType.RParen) {
			callParameters.push(this.expressionParser.parseExpression());
			if(this.currentToken.type == lexer_TokenType.Comma && this.lexer.peekToken().type == lexer_TokenType.RParen) {
				this.error.unexpectedToken(this.currentToken,"identifier or `)`");
			} else if(this.currentToken.type == lexer_TokenType.Comma) {
				this.nextToken();
			} else {
				this.assertToken(lexer_TokenType.RParen,"`,` or `)`");
			}
		}
		this.nextToken();
		return new ast_nodes_ExpressionNode(nodePos,new ast_nodes_CallNode(nodePos,target,callParameters));
	}
	,parseIndex: function(target) {
		var nodePos = this.currentToken.position;
		var index;
		switch(this.currentToken.type._hx_index) {
		case 31:
			this.nextToken();
			this.assertToken(lexer_TokenType.Ident,"identifier");
			var eIndex = new ast_nodes_ExpressionNode(this.currentToken.position,new ast_nodes_datatypes_StringNode(this.currentToken.position,this.currentToken.literal));
			this.nextToken();
			index = eIndex;
			break;
		case 37:
			this.nextToken();
			var eIndex = this.expressionParser.parseExpression();
			this.assertToken(lexer_TokenType.RBracket,"`]`");
			this.nextToken();
			index = eIndex;
			break;
		default:
			this.error.unexpectedToken(this.currentToken,"`[` or `.`");
			index = null;
		}
		var indexNode = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_IndexNode(nodePos,target,index));
		if(this.currentToken.type == lexer_TokenType.Assign) {
			this.nextToken();
			var value = this.expressionParser.parseExpression();
			return new ast_nodes_ExpressionNode(nodePos,new ast_nodes_IndexAssignNode(nodePos,indexNode,value));
		} else {
			return indexNode;
		}
	}
	,parseArray: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var values = [];
		while(this.currentToken.type != lexer_TokenType.RBracket) {
			values.push(this.expressionParser.parseExpression());
			if(this.currentToken.type == lexer_TokenType.Comma && this.lexer.peekToken().type == lexer_TokenType.RBracket) {
				this.error.unexpectedToken(this.currentToken,"expression or `]`");
			} else if(this.currentToken.type == lexer_TokenType.Comma) {
				this.nextToken();
			} else {
				this.assertToken(lexer_TokenType.RBracket,"`,` or `]`");
			}
		}
		this.nextToken();
		return new ast_nodes_ArrayNode(nodePos,values);
	}
	,parseHash: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var values = new haxe_ds_ObjectMap();
		while(this.currentToken.type != lexer_TokenType.RBrace) {
			var key;
			if(this.currentToken.type == lexer_TokenType.LBracket) {
				this.nextToken();
				var eKey = this.expressionParser.parseExpression();
				this.assertToken(lexer_TokenType.RBracket,"`]");
				this.nextToken();
				key = eKey;
			} else if(this.currentToken.type == lexer_TokenType.Ident || this.currentToken.type == lexer_TokenType.String) {
				var eKey1 = new ast_nodes_ExpressionNode(this.currentToken.position,new ast_nodes_datatypes_StringNode(this.currentToken.position,this.currentToken.literal));
				this.nextToken();
				key = eKey1;
			} else {
				this.error.unexpectedToken(this.currentToken,"identifier or string");
				key = null;
			}
			this.assertToken(lexer_TokenType.Colon,"`:`");
			this.nextToken();
			var value = this.expressionParser.parseExpression();
			if(this.currentToken.type != lexer_TokenType.Comma && this.currentToken.type != lexer_TokenType.RBrace) {
				this.error.unexpectedToken(this.currentToken,"`,` or `}`");
			} else if(this.currentToken.type == lexer_TokenType.Comma) {
				this.nextToken();
			}
			values.set(key,value);
		}
		this.nextToken();
		return new ast_nodes_HashNode(nodePos,values);
	}
	,parseVariableName: function() {
		var nodePos = this.currentToken.position;
		switch(this.currentToken.type._hx_index) {
		case 2:
			return new ast_nodes_IdentNode(nodePos,this.currentToken.literal);
		case 35:case 37:
			var names = [];
			this.nextToken();
			while(this.currentToken.type != lexer_TokenType.RBracket && this.currentToken.type != lexer_TokenType.RBrace) {
				names.push(this.currentToken.literal);
				this.nextToken();
				if(this.currentToken.type != lexer_TokenType.Comma && this.currentToken.type != lexer_TokenType.RBracket && this.currentToken.type != lexer_TokenType.RBrace) {
					this.error.unexpectedToken(this.currentToken,"`,`");
				}
				if(this.currentToken.type == lexer_TokenType.Comma) {
					this.nextToken();
				}
			}
			if(this.currentToken.type == lexer_TokenType.RBracket) {
				return new ast_nodes_DestructureArrayNode(nodePos,names);
			} else {
				return new ast_nodes_DestructureHashNode(nodePos,names);
			}
			break;
		default:
			this.error.unexpectedToken(this.currentToken,"identifier or `{`");
			return null;
		}
	}
	,parseVariable: function() {
		var nodePos = this.currentToken.position;
		var mutable = this.currentToken.type == lexer_TokenType.Mut;
		this.nextToken();
		var name = this.parseVariableName();
		this.nextToken();
		this.assertToken(lexer_TokenType.Assign,"`=`");
		this.nextToken();
		var value = this.expressionParser.parseExpression();
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_VariableNode(nodePos,name,value,mutable);
	}
	,parseReturn: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var returnValue = this.currentToken.type != lexer_TokenType.Semicolon ? this.expressionParser.parseExpression() : null;
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_ReturnNode(nodePos,returnValue);
	}
	,parseBreak: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_BreakNode(nodePos);
	}
	,parseIf: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var condition = this.expressionParser.parseExpression();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var consequence = this.parseBlock();
		var alternative = null;
		if(this.lexer.peekToken().type == lexer_TokenType.Else) {
			this.nextToken();
			this.nextToken();
			if(this.currentToken.type == lexer_TokenType.If) {
				alternative = this.parseIf();
			} else {
				this.assertToken(lexer_TokenType.LBrace,"`{`");
				var block = this.parseBlock();
				this.nextToken();
				alternative = block;
			}
		} else {
			this.nextToken();
		}
		return new ast_nodes_IfNode(nodePos,condition,consequence,alternative);
	}
	,parseWhile: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var condition = this.expressionParser.parseExpression();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var block = this.parseBlock();
		this.nextToken();
		return new ast_nodes_WhileNode(nodePos,condition,block);
	}
	,parseFor: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var variable;
		if(this.currentToken.type == lexer_TokenType.Let || this.currentToken.type == lexer_TokenType.Mut) {
			var mutable = this.currentToken.type == lexer_TokenType.Mut;
			this.nextToken();
			var variableName = this.parseVariableName();
			this.nextToken();
			this.assertToken(lexer_TokenType.In,"`in`");
			this.nextToken();
			variable = new ast_nodes_VariableNode(nodePos,variableName,null,mutable);
		} else {
			variable = null;
		}
		var iterator = this.expressionParser.parseExpression();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var block = this.parseBlock();
		this.nextToken();
		return new ast_nodes_ForNode(nodePos,variable,iterator,block);
	}
	,parseVariableAssign: function() {
		var nodePos = this.currentToken.position;
		var name = new ast_nodes_IdentNode(nodePos,this.currentToken.literal);
		this.nextToken();
		this.assertToken(lexer_TokenType.Assign,"`=`");
		this.nextToken();
		var value = this.expressionParser.parseExpression();
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_VariableAssignNode(nodePos,name,value);
	}
	,parseVariableAssignOp: function() {
		var nodePos = this.currentToken.position;
		var name = new ast_nodes_IdentNode(nodePos,this.currentToken.literal);
		this.nextToken();
		var op = this.currentToken;
		this.nextToken();
		var value = this.expressionParser.parseExpression();
		this.assertSemicolon();
		this.nextToken();
		var tmp;
		switch(op.type._hx_index) {
		case 6:
			tmp = new ast_nodes_OperatorNode(nodePos,ast_NodeType.Add,name,value);
			break;
		case 7:
			tmp = new ast_nodes_OperatorNode(nodePos,ast_NodeType.Subtract,name,value);
			break;
		case 8:
			tmp = new ast_nodes_OperatorNode(nodePos,ast_NodeType.Multiply,name,value);
			break;
		case 9:
			tmp = new ast_nodes_OperatorNode(nodePos,ast_NodeType.Divide,name,value);
			break;
		case 10:
			tmp = new ast_nodes_OperatorNode(nodePos,ast_NodeType.Modulo,name,value);
			break;
		default:
			this.error.unexpectedToken(op,"operator assign");
			tmp = null;
		}
		return new ast_nodes_VariableAssignOpNode(nodePos,name,tmp);
	}
	,parseStatement: function() {
		var nodePos = this.currentToken.position;
		var expression = this.expressionParser.parseExpression();
		var statement;
		if(this.currentToken.type == lexer_TokenType.RBrace) {
			statement = expression;
		} else {
			this.assertSemicolon();
			this.nextToken();
			statement = new ast_nodes_StatementNode(nodePos,expression);
		}
		return statement;
	}
	,parseImport: function() {
		this.nextToken();
		this.assertToken(lexer_TokenType.String,"string containing path to source file");
		var filename = "" + this.currentToken.literal + ".snek";
		this.nextToken();
		this.assertSemicolon();
		this.nextToken();
		var code = "";
		throw haxe_Exception.thrown("Imports not supported on this target");
	}
	,assertToken: function(type,expected) {
		if(this.currentToken.type != type) {
			this.error.unexpectedToken(this.currentToken,expected);
		}
	}
	,assertSemicolon: function() {
		if(this.currentToken.type != lexer_TokenType.Semicolon) {
			this.error.missingSemicolon(this.currentToken);
		}
	}
	,parseToken: function(block) {
		switch(this.currentToken.type._hx_index) {
		case 0:
			this.error.illegalToken(this.currentToken);
			break;
		case 2:
			switch(this.lexer.peekToken().type._hx_index) {
			case 5:
				block.addNode(this.parseVariableAssign());
				break;
			case 6:case 7:case 8:case 9:case 10:
				block.addNode(this.parseVariableAssignOp());
				break;
			default:
				block.addNode(this.parseStatement());
			}
			break;
		case 35:
			block.addNode(this.parseBlock());
			this.nextToken();
			break;
		case 42:case 43:
			block.addNode(this.parseVariable());
			break;
		case 46:
			block.addNode(this.parseIf());
			break;
		case 48:
			block.addNode(this.parseWhile());
			break;
		case 49:
			block.addNode(this.parseReturn());
			break;
		case 51:
			block.addNode(this.parseBreak());
			break;
		case 53:
			block.addNode(this.parseFor());
			break;
		default:
			block.addNode(this.parseStatement());
		}
	}
	,__class__: parser_Parser
};
var std_BuiltInTable = function(evaluator) {
	this.evaluator = evaluator;
	this.namespaces = [new std_lib_namespaces_SysNamespace(evaluator),new std_lib_namespaces_MathNamespace(evaluator),new std_lib_namespaces_StringNamespace(evaluator),new std_lib_namespaces_ObjectNamespace(evaluator),new std_lib_namespaces_RangeNamespace(evaluator)];
};
std_BuiltInTable.__name__ = true;
std_BuiltInTable.resolveName = function(name) {
	return [std_lib_namespaces_SysNamespace.$name,std_lib_namespaces_MathNamespace.$name,std_lib_namespaces_StringNamespace.$name,std_lib_namespaces_ObjectNamespace.$name,std_lib_namespaces_RangeNamespace.$name].indexOf(name);
};
std_BuiltInTable.prototype = {
	resolveIndex: function(index) {
		return this.namespaces[index].getMembers();
	}
	,callFunction: function(func) {
		var parameters = [];
		var _g = 0;
		var _g1 = func.parametersCount;
		while(_g < _g1) {
			var _ = _g++;
			var _this = this.evaluator.stack;
			var k = _this.head;
			var parameter;
			if(k == null) {
				parameter = null;
			} else {
				_this.head = k.next;
				parameter = k.elt;
			}
			parameters.push(parameter);
		}
		var returnValue = func.func(parameters);
		var _this = this.evaluator.stack;
		_this.head = new haxe_ds_GenericCell(returnValue,_this.head);
		var _this = this.evaluator.frames;
		var k = _this.head;
		if(k != null) {
			_this.head = k.next;
		}
		var _this = this.evaluator.frames;
		this.evaluator.currentFrame = _this.head == null ? null : _this.head.elt;
	}
	,__class__: std_BuiltInTable
};
var std_lib_namespaces_MathNamespace = function(evaluator) {
	var _gthis = this;
	std_lib_MemberObject.call(this,evaluator);
	this.addObjectMember("PI",new object_NumberObj(Math.PI,evaluator));
	this.addFunctionMember("abs",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Number);
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		return new object_NumberObj(Math.abs(value),evaluator);
	});
	this.addFunctionMember("floor",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Number);
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		return new object_NumberObj(Math.floor(value),evaluator);
	});
	this.addFunctionMember("sqrt",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Number);
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		return new object_NumberObj(Math.sqrt(value),evaluator);
	});
};
std_lib_namespaces_MathNamespace.__name__ = true;
std_lib_namespaces_MathNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_MathNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_MathNamespace
});
var std_lib_namespaces_ObjectNamespace = function(evaluator) {
	std_lib_MemberObject.call(this,evaluator);
	this.addFunctionMember("typeof",1,function(parameters) {
		return new object_StringObj(Std.string(parameters[0].type),evaluator);
	});
};
std_lib_namespaces_ObjectNamespace.__name__ = true;
std_lib_namespaces_ObjectNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_ObjectNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_ObjectNamespace
});
var std_lib_namespaces__$RangeNamespace_ExclusiveRange = function(evaluator,start,end) {
	std_lib_MemberObject.call(this,evaluator);
	var current = start - 1;
	this.addFunctionMember("next",0,function(p) {
		current += 1;
		return new object_NumberObj(current,evaluator);
	});
	this.addFunctionMember("hasNext",0,function(p) {
		return new object_NumberObj(current + 1 < end ? 1 : 0,evaluator);
	});
	this.addFunctionMember("Iterator",0,function(p) {
		return new std_lib_namespaces__$RangeNamespace_ExclusiveRange(evaluator,start,end).getMembers();
	});
};
std_lib_namespaces__$RangeNamespace_ExclusiveRange.__name__ = true;
std_lib_namespaces__$RangeNamespace_ExclusiveRange.__super__ = std_lib_MemberObject;
std_lib_namespaces__$RangeNamespace_ExclusiveRange.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces__$RangeNamespace_ExclusiveRange
});
var std_lib_namespaces_RangeNamespace = function(evaluator) {
	var _gthis = this;
	std_lib_MemberObject.call(this,evaluator);
	this.addFunctionMember("Exclusive",2,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Number);
		_gthis.assertParameterType(p[1],object_ObjectType.Number);
		var start = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		var end = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		return new std_lib_namespaces__$RangeNamespace_ExclusiveRange(evaluator,start,end).getMembers();
	});
	this.addFunctionMember("Inclusive",2,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.Number);
		_gthis.assertParameterType(p[1],object_ObjectType.Number);
		var start = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		var end = (js_Boot.__cast(p[1] , object_NumberObj)).value + 1;
		return new std_lib_namespaces__$RangeNamespace_ExclusiveRange(evaluator,start,end).getMembers();
	});
};
std_lib_namespaces_RangeNamespace.__name__ = true;
std_lib_namespaces_RangeNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_RangeNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_RangeNamespace
});
var std_lib_namespaces_StringNamespace = function(evaluator) {
	var _gthis = this;
	std_lib_MemberObject.call(this,evaluator);
	this.addFunctionMember("parse",1,function(p) {
		_gthis.assertParameterType(p[0],object_ObjectType.String);
		var value = (js_Boot.__cast(p[0] , object_StringObj)).value;
		return new object_NumberObj(parseFloat(value),evaluator);
	});
};
std_lib_namespaces_StringNamespace.__name__ = true;
std_lib_namespaces_StringNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_StringNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_StringNamespace
});
var std_lib_namespaces_SysNamespace = function(evaluator) {
	std_lib_MemberObject.call(this,evaluator);
	this.addFunctionMember("println",1,function(p) {
		$global.console.log(p[0].toString());
		return new object_NullObj(evaluator);
	});
	this.addFunctionMember("print",1,function(p) {
		$global.console.log(p[0].toString());
		return new object_NullObj(evaluator);
	});
	this.addFunctionMember("readLine",0,function(p) {
		var input = "";
		throw haxe_Exception.thrown("Read line not supported on this target");
	});
};
std_lib_namespaces_SysNamespace.__name__ = true;
std_lib_namespaces_SysNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_SysNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_SysNamespace
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b,gray>><//> ";
Console.warnPrefix = "<b,yellow>><//> ";
Console.errorPrefix = "<b,red>></b> ";
Console.successPrefix = "<b,light_green>><//> ";
Console.debugPrefix = "<b,magenta>><//> ";
Console.argSeparator = " ";
Console.unicodeCompatibilityMode = 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
FormatFlag.RESET = "reset";
FormatFlag.BOLD = "bold";
FormatFlag.ITALIC = "italic";
FormatFlag.DIM = "dim";
FormatFlag.UNDERLINE = "underline";
FormatFlag.BLINK = "blink";
FormatFlag.INVERT = "invert";
FormatFlag.HIDDEN = "hidden";
FormatFlag.BLACK = "black";
FormatFlag.RED = "red";
FormatFlag.GREEN = "green";
FormatFlag.YELLOW = "yellow";
FormatFlag.BLUE = "blue";
FormatFlag.MAGENTA = "magenta";
FormatFlag.CYAN = "cyan";
FormatFlag.WHITE = "white";
FormatFlag.LIGHT_BLACK = "light_black";
FormatFlag.LIGHT_RED = "light_red";
FormatFlag.LIGHT_GREEN = "light_green";
FormatFlag.LIGHT_YELLOW = "light_yellow";
FormatFlag.LIGHT_BLUE = "light_blue";
FormatFlag.LIGHT_MAGENTA = "light_magenta";
FormatFlag.LIGHT_CYAN = "light_cyan";
FormatFlag.LIGHT_WHITE = "light_white";
FormatFlag.BG_BLACK = "bg_black";
FormatFlag.BG_RED = "bg_red";
FormatFlag.BG_GREEN = "bg_green";
FormatFlag.BG_YELLOW = "bg_yellow";
FormatFlag.BG_BLUE = "bg_blue";
FormatFlag.BG_MAGENTA = "bg_magenta";
FormatFlag.BG_CYAN = "bg_cyan";
FormatFlag.BG_WHITE = "bg_white";
FormatFlag.BG_LIGHT_BLACK = "bg_light_black";
FormatFlag.BG_LIGHT_RED = "bg_light_red";
FormatFlag.BG_LIGHT_GREEN = "bg_light_green";
FormatFlag.BG_LIGHT_YELLOW = "bg_light_yellow";
FormatFlag.BG_LIGHT_BLUE = "bg_light_blue";
FormatFlag.BG_LIGHT_MAGENTA = "bg_light_magenta";
FormatFlag.BG_LIGHT_CYAN = "bg_light_cyan";
FormatFlag.BG_LIGHT_WHITE = "bg_light_white";
code_OpCode.Constant = 0;
code_OpCode.Pop = 1;
code_OpCode.Jump = 2;
code_OpCode.JumpNot = 3;
code_OpCode.JumpPeek = 4;
code_OpCode.Add = 5;
code_OpCode.Subtract = 6;
code_OpCode.Multiply = 7;
code_OpCode.Divide = 8;
code_OpCode.Modulo = 9;
code_OpCode.Equals = 10;
code_OpCode.LessThan = 11;
code_OpCode.GreaterThan = 12;
code_OpCode.Negate = 13;
code_OpCode.Not = 14;
code_OpCode.ConcatString = 15;
code_OpCode.Load = 16;
code_OpCode.Store = 17;
code_OpCode.LoadBuiltIn = 18;
code_OpCode.Call = 19;
code_OpCode.Return = 20;
code_OpCode.Array = 21;
code_OpCode.Hash = 22;
code_OpCode.LoadIndex = 23;
code_OpCode.StoreIndex = 24;
code_OpCode.DestructureArray = 25;
code_OpCode.DestructureHash = 26;
compiler_constant_ConstantType.Float = 0;
compiler_constant_ConstantType.String = 1;
compiler_constant_ConstantType.UserFunction = 2;
compiler_constant_ConstantType.Null = 3;
error_CompileError.init = Console.logPrefix = "";
haxe_io_FPHelper.i64tmp = (function($this) {
	var $r;
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	$r = this1;
	return $r;
}(this));
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
lexer_Keyword.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["func"] = lexer_TokenType.Function;
	_g.h["let"] = lexer_TokenType.Let;
	_g.h["mut"] = lexer_TokenType.Mut;
	_g.h["true"] = lexer_TokenType.True;
	_g.h["false"] = lexer_TokenType.False;
	_g.h["if"] = lexer_TokenType.If;
	_g.h["else"] = lexer_TokenType.Else;
	_g.h["while"] = lexer_TokenType.While;
	_g.h["return"] = lexer_TokenType.Return;
	_g.h["import"] = lexer_TokenType.Import;
	_g.h["break"] = lexer_TokenType.Break;
	_g.h["null"] = lexer_TokenType.Null;
	_g.h["for"] = lexer_TokenType.For;
	_g.h["in"] = lexer_TokenType.In;
	$r = _g;
	return $r;
}(this));
std_lib_namespaces_MathNamespace.$name = "Math";
std_lib_namespaces_ObjectNamespace.$name = "Object";
std_lib_namespaces_RangeNamespace.$name = "Range";
std_lib_namespaces_StringNamespace.$name = "Number";
std_lib_namespaces_SysNamespace.$name = "Sys";
Snekky.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
