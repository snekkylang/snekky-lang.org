// Generated by Haxe 4.2.0
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var Console = function() { };
Console.__name__ = true;
Console.printlnFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	Console.printFormatted(s + "\n",outputStream);
};
Console.println = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	Console.print(s + "\n",outputStream);
};
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	s += "<//>";
	var activeFormatFlagStack = [];
	var groupedProceedingTags = [];
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var open = e.matched(1) == null;
		var tags = e.matched(2).split(",");
		if(!open && tags.length == 1) {
			if(tags[0] == "") {
				var last = activeFormatFlagStack[activeFormatFlagStack.length - 1];
				var i = activeFormatFlagStack.indexOf(last);
				if(i != -1) {
					var proceedingTags = groupedProceedingTags[i];
					activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
					groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
				}
			} else if(FormatFlag.fromString(tags[0]) == "reset") {
				activeFormatFlagStack = [];
				groupedProceedingTags = [];
			} else {
				var flag = FormatFlag.fromString(tags[0]);
				if(flag != null) {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
						groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
					}
				}
			}
		} else {
			var proceedingTags = 0;
			var _g = 0;
			while(_g < tags.length) {
				var tag = tags[_g];
				++_g;
				var flag = FormatFlag.fromString(tag);
				if(flag == null) {
					return e.matched(0);
				}
				if(open) {
					activeFormatFlagStack.push(flag);
					groupedProceedingTags.push(proceedingTags);
					++proceedingTags;
				} else {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags1 = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags1,proceedingTags1 + 1);
						groupedProceedingTags.splice(i - proceedingTags1,proceedingTags1 + 1);
					}
				}
			}
		}
		switch(Console.formatMode) {
		case 1:
			var browserFormatArguments1 = browserFormatArguments;
			var result = new Array(activeFormatFlagStack.length);
			var _g = 0;
			var _g1 = activeFormatFlagStack.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = Console.getBrowserFormat(activeFormatFlagStack[i]);
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = result;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v != null) {
					_g.push(v);
				}
			}
			browserFormatArguments1.push(_g.join(";"));
			return "%c";
		case 2:
			return "";
		}
	});
	if(Console.formatMode == 1) {
		var logArgs = [result].concat(browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(Console.printIntercept != null) {
		var allowDefaultPrint = Console.printIntercept(s,outputStream);
		if(!allowDefaultPrint) {
			return;
		}
	}
	switch(outputStream) {
	case 1:
		console.warn(s);
		break;
	case 2:
		console.error(s);
		break;
	case 0:case 3:
		console.log(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[38;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex = HxOverrides.substr(flag,3,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[48;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return "";
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g = 0;
		var _g1 = set.length;
		while(_g < _g1) {
			var i = _g++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var ier = Math.abs(r - colorSteps[ir]);
	var ieg = Math.abs(g - colorSteps[ig]);
	var ieb = Math.abs(b - colorSteps[ib]);
	var averageColorError = ier + ieg + ieb;
	var jr = Math.round((r - 8) / 10);
	var jg = Math.round((g - 8) / 10);
	var jb = Math.round((b - 8) / 10);
	var jer = Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8));
	var jeg = Math.abs(g - Math.max(Math.min(jg * 10 + 8,238),8));
	var jeb = Math.abs(b - Math.max(Math.min(jb * 10 + 8,238),8));
	var averageGrayError = jer + jeg + jeb;
	if(averageGrayError < averageColorError && r == g && g == b) {
		var grayIndex = jr + 232;
		return grayIndex;
	} else {
		var colorIndex = 16 + ir * 36 + ig * 6 + ib;
		return colorIndex;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return "";
	}
};
Console.determineConsoleFormatMode = function() {
	var hasWindowObject = typeof(window) != "undefined";
	if(hasWindowObject) {
		return 1;
	}
	return 2;
};
Console.joinArgs = function(rest) {
	var msg = { expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString("",haxe_macro_StringLiteralKind.SingleQuotes)), pos : { file : "/opt/hostedtoolcache/haxe/4.2.0/x64/lib/console,hx/0,2,12/Console.hx", min : 19027, max : 19029}};
	var _g = 0;
	var _g1 = rest.length;
	while(_g < _g1) {
		var i = _g++;
		var e = rest[i];
		msg = { expr : haxe_macro_ExprDef.EBinop(haxe_macro_Binop.OpAdd,msg,e), pos : { file : "/opt/hostedtoolcache/haxe/4.2.0/x64/lib/console,hx/0,2,12/Console.hx", min : 19095, max : 19104}};
		if(i != rest.length - 1) {
			msg = { expr : haxe_macro_ExprDef.EBinop(haxe_macro_Binop.OpAdd,msg,{ expr : haxe_macro_ExprDef.EConst(haxe_macro_Constant.CString("$argSeparator",haxe_macro_StringLiteralKind.SingleQuotes)), pos : { file : "/opt/hostedtoolcache/haxe/4.2.0/x64/lib/console,hx/0,2,12/Console.hx", min : 19159, max : 19174}}), pos : { file : "/opt/hostedtoolcache/haxe/4.2.0/x64/lib/console,hx/0,2,12/Console.hx", min : 19152, max : 19174}};
		}
	}
	return msg;
};
var FormatFlag = {};
FormatFlag.fromString = function(str) {
	str = str.toLowerCase();
	if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
		var hIdx = str.indexOf("#");
		var hex = HxOverrides.substr(str,hIdx + 1,null);
		if(hex.length == 3) {
			var a = hex.split("");
			hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
		}
		if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
			return "";
		}
		var normalized = str.substring(0,hIdx) + "#" + hex;
		return normalized;
	}
	switch(str) {
	case "!":
		return "invert";
	case "/":
		return "reset";
	case "b":
		return "bold";
	case "bg_gray":
		return "bg_light_black";
	case "gray":
		return "light_black";
	case "i":
		return "italic";
	case "u":
		return "underline";
	default:
		return str;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Math.__name__ = true;
var Snekky = $hx_exports["Snekky"] = function() { };
Snekky.__name__ = true;
Snekky.tokenizeString = function(filename,code) {
	return new lexer_Lexer(filename,code);
};
Snekky.compileString = function(filename,code,debug,compress,warnings) {
	var lexer = new lexer_Lexer(filename,code);
	var parser = new parser_Parser(lexer,false);
	parser.generateAst();
	var compiler = new compiler_Compiler(debug,warnings);
	compiler.compile(parser.ast);
	var byteCode = compiler.getByteCode(compress);
	return byteCode;
};
Snekky.evaluateBytes = function(byteCode) {
	var vm = new vm_VirtualMachine(byteCode);
	vm.eval();
};
Snekky.main = function() {
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
StringBuf.prototype = {
	toString: function() {
		return this.b;
	}
	,__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var ast_NodeType = $hxEnums["ast.NodeType"] = { __ename__:true,__constructs__:null
	,File: {_hx_name:"File",_hx_index:0,__enum__:"ast.NodeType",toString:$estr}
	,Block: {_hx_name:"Block",_hx_index:1,__enum__:"ast.NodeType",toString:$estr}
	,Expression: {_hx_name:"Expression",_hx_index:2,__enum__:"ast.NodeType",toString:$estr}
	,Statement: {_hx_name:"Statement",_hx_index:3,__enum__:"ast.NodeType",toString:$estr}
	,Variable: {_hx_name:"Variable",_hx_index:4,__enum__:"ast.NodeType",toString:$estr}
	,VariableAssign: {_hx_name:"VariableAssign",_hx_index:5,__enum__:"ast.NodeType",toString:$estr}
	,DestructureArray: {_hx_name:"DestructureArray",_hx_index:6,__enum__:"ast.NodeType",toString:$estr}
	,DestructureHash: {_hx_name:"DestructureHash",_hx_index:7,__enum__:"ast.NodeType",toString:$estr}
	,Ident: {_hx_name:"Ident",_hx_index:8,__enum__:"ast.NodeType",toString:$estr}
	,FunctionCall: {_hx_name:"FunctionCall",_hx_index:9,__enum__:"ast.NodeType",toString:$estr}
	,Add: {_hx_name:"Add",_hx_index:10,__enum__:"ast.NodeType",toString:$estr}
	,Subtract: {_hx_name:"Subtract",_hx_index:11,__enum__:"ast.NodeType",toString:$estr}
	,Multiply: {_hx_name:"Multiply",_hx_index:12,__enum__:"ast.NodeType",toString:$estr}
	,Divide: {_hx_name:"Divide",_hx_index:13,__enum__:"ast.NodeType",toString:$estr}
	,Modulo: {_hx_name:"Modulo",_hx_index:14,__enum__:"ast.NodeType",toString:$estr}
	,Or: {_hx_name:"Or",_hx_index:15,__enum__:"ast.NodeType",toString:$estr}
	,And: {_hx_name:"And",_hx_index:16,__enum__:"ast.NodeType",toString:$estr}
	,LessThan: {_hx_name:"LessThan",_hx_index:17,__enum__:"ast.NodeType",toString:$estr}
	,LessThanOrEqual: {_hx_name:"LessThanOrEqual",_hx_index:18,__enum__:"ast.NodeType",toString:$estr}
	,GreaterThan: {_hx_name:"GreaterThan",_hx_index:19,__enum__:"ast.NodeType",toString:$estr}
	,GreaterThanOrEqual: {_hx_name:"GreaterThanOrEqual",_hx_index:20,__enum__:"ast.NodeType",toString:$estr}
	,ConcatString: {_hx_name:"ConcatString",_hx_index:21,__enum__:"ast.NodeType",toString:$estr}
	,Equals: {_hx_name:"Equals",_hx_index:22,__enum__:"ast.NodeType",toString:$estr}
	,NotEquals: {_hx_name:"NotEquals",_hx_index:23,__enum__:"ast.NodeType",toString:$estr}
	,Negate: {_hx_name:"Negate",_hx_index:24,__enum__:"ast.NodeType",toString:$estr}
	,Not: {_hx_name:"Not",_hx_index:25,__enum__:"ast.NodeType",toString:$estr}
	,BitAnd: {_hx_name:"BitAnd",_hx_index:26,__enum__:"ast.NodeType",toString:$estr}
	,BitOr: {_hx_name:"BitOr",_hx_index:27,__enum__:"ast.NodeType",toString:$estr}
	,BitXor: {_hx_name:"BitXor",_hx_index:28,__enum__:"ast.NodeType",toString:$estr}
	,BitNot: {_hx_name:"BitNot",_hx_index:29,__enum__:"ast.NodeType",toString:$estr}
	,BitShiftLeft: {_hx_name:"BitShiftLeft",_hx_index:30,__enum__:"ast.NodeType",toString:$estr}
	,BitShiftRight: {_hx_name:"BitShiftRight",_hx_index:31,__enum__:"ast.NodeType",toString:$estr}
	,Float: {_hx_name:"Float",_hx_index:32,__enum__:"ast.NodeType",toString:$estr}
	,String: {_hx_name:"String",_hx_index:33,__enum__:"ast.NodeType",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:34,__enum__:"ast.NodeType",toString:$estr}
	,Boolean: {_hx_name:"Boolean",_hx_index:35,__enum__:"ast.NodeType",toString:$estr}
	,Array: {_hx_name:"Array",_hx_index:36,__enum__:"ast.NodeType",toString:$estr}
	,Hash: {_hx_name:"Hash",_hx_index:37,__enum__:"ast.NodeType",toString:$estr}
	,Null: {_hx_name:"Null",_hx_index:38,__enum__:"ast.NodeType",toString:$estr}
	,Return: {_hx_name:"Return",_hx_index:39,__enum__:"ast.NodeType",toString:$estr}
	,Break: {_hx_name:"Break",_hx_index:40,__enum__:"ast.NodeType",toString:$estr}
	,Continue: {_hx_name:"Continue",_hx_index:41,__enum__:"ast.NodeType",toString:$estr}
	,If: {_hx_name:"If",_hx_index:42,__enum__:"ast.NodeType",toString:$estr}
	,While: {_hx_name:"While",_hx_index:43,__enum__:"ast.NodeType",toString:$estr}
	,For: {_hx_name:"For",_hx_index:44,__enum__:"ast.NodeType",toString:$estr}
	,When: {_hx_name:"When",_hx_index:45,__enum__:"ast.NodeType",toString:$estr}
	,Range: {_hx_name:"Range",_hx_index:46,__enum__:"ast.NodeType",toString:$estr}
	,Regex: {_hx_name:"Regex",_hx_index:47,__enum__:"ast.NodeType",toString:$estr}
	,Index: {_hx_name:"Index",_hx_index:48,__enum__:"ast.NodeType",toString:$estr}
	,IndexAssign: {_hx_name:"IndexAssign",_hx_index:49,__enum__:"ast.NodeType",toString:$estr}
};
ast_NodeType.__constructs__ = [ast_NodeType.File,ast_NodeType.Block,ast_NodeType.Expression,ast_NodeType.Statement,ast_NodeType.Variable,ast_NodeType.VariableAssign,ast_NodeType.DestructureArray,ast_NodeType.DestructureHash,ast_NodeType.Ident,ast_NodeType.FunctionCall,ast_NodeType.Add,ast_NodeType.Subtract,ast_NodeType.Multiply,ast_NodeType.Divide,ast_NodeType.Modulo,ast_NodeType.Or,ast_NodeType.And,ast_NodeType.LessThan,ast_NodeType.LessThanOrEqual,ast_NodeType.GreaterThan,ast_NodeType.GreaterThanOrEqual,ast_NodeType.ConcatString,ast_NodeType.Equals,ast_NodeType.NotEquals,ast_NodeType.Negate,ast_NodeType.Not,ast_NodeType.BitAnd,ast_NodeType.BitOr,ast_NodeType.BitXor,ast_NodeType.BitNot,ast_NodeType.BitShiftLeft,ast_NodeType.BitShiftRight,ast_NodeType.Float,ast_NodeType.String,ast_NodeType.Function,ast_NodeType.Boolean,ast_NodeType.Array,ast_NodeType.Hash,ast_NodeType.Null,ast_NodeType.Return,ast_NodeType.Break,ast_NodeType.Continue,ast_NodeType.If,ast_NodeType.While,ast_NodeType.For,ast_NodeType.When,ast_NodeType.Range,ast_NodeType.Regex,ast_NodeType.Index,ast_NodeType.IndexAssign];
var ast_nodes_Node = function(position,type) {
	this.position = position;
	this.type = type;
};
ast_nodes_Node.__name__ = true;
ast_nodes_Node.prototype = {
	__class__: ast_nodes_Node
};
var ast_nodes_BlockNode = function(position) {
	this.body = [];
	ast_nodes_Node.call(this,position,ast_NodeType.Block);
};
ast_nodes_BlockNode.__name__ = true;
ast_nodes_BlockNode.__super__ = ast_nodes_Node;
ast_nodes_BlockNode.prototype = $extend(ast_nodes_Node.prototype,{
	addNode: function(node) {
		this.body.push(node);
	}
	,__class__: ast_nodes_BlockNode
});
var ast_nodes_BreakNode = function(position) {
	ast_nodes_Node.call(this,position,ast_NodeType.Break);
};
ast_nodes_BreakNode.__name__ = true;
ast_nodes_BreakNode.__super__ = ast_nodes_Node;
ast_nodes_BreakNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_BreakNode
});
var ast_nodes_CallNode = function(position,target,parameters) {
	ast_nodes_Node.call(this,position,ast_NodeType.FunctionCall);
	this.target = target;
	this.parameters = parameters;
};
ast_nodes_CallNode.__name__ = true;
ast_nodes_CallNode.__super__ = ast_nodes_Node;
ast_nodes_CallNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_CallNode
});
var ast_nodes_ContinueNode = function(position) {
	ast_nodes_Node.call(this,position,ast_NodeType.Continue);
};
ast_nodes_ContinueNode.__name__ = true;
ast_nodes_ContinueNode.__super__ = ast_nodes_Node;
ast_nodes_ContinueNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ContinueNode
});
var ast_nodes_DestructureArrayNode = function(position,names) {
	ast_nodes_Node.call(this,position,ast_NodeType.DestructureArray);
	this.names = names;
};
ast_nodes_DestructureArrayNode.__name__ = true;
ast_nodes_DestructureArrayNode.__super__ = ast_nodes_Node;
ast_nodes_DestructureArrayNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_DestructureArrayNode
});
var ast_nodes_DestructureHashNode = function(position,names) {
	ast_nodes_Node.call(this,position,ast_NodeType.DestructureHash);
	this.names = names;
};
ast_nodes_DestructureHashNode.__name__ = true;
ast_nodes_DestructureHashNode.__super__ = ast_nodes_Node;
ast_nodes_DestructureHashNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_DestructureHashNode
});
var ast_nodes_ExpressionNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Expression);
	this.value = value;
};
ast_nodes_ExpressionNode.__name__ = true;
ast_nodes_ExpressionNode.__super__ = ast_nodes_Node;
ast_nodes_ExpressionNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ExpressionNode
});
var ast_nodes_FileNode = function(position,filename,code) {
	ast_nodes_BlockNode.call(this,position);
	this.filename = filename;
	this.code = code;
	this.type = ast_NodeType.File;
};
ast_nodes_FileNode.__name__ = true;
ast_nodes_FileNode.__super__ = ast_nodes_BlockNode;
ast_nodes_FileNode.prototype = $extend(ast_nodes_BlockNode.prototype,{
	__class__: ast_nodes_FileNode
});
var ast_nodes_ForNode = function(position,variable,iterator,block) {
	ast_nodes_Node.call(this,position,ast_NodeType.For);
	this.variable = variable;
	this.iterator = iterator;
	this.block = block;
};
ast_nodes_ForNode.__name__ = true;
ast_nodes_ForNode.__super__ = ast_nodes_Node;
ast_nodes_ForNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ForNode
});
var ast_nodes_IdentNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Ident);
	this.value = value;
};
ast_nodes_IdentNode.__name__ = true;
ast_nodes_IdentNode.__super__ = ast_nodes_Node;
ast_nodes_IdentNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IdentNode
});
var ast_nodes_IfNode = function(position,condition,consequence,alternative) {
	ast_nodes_Node.call(this,position,ast_NodeType.If);
	this.condition = condition;
	this.consequence = consequence;
	this.alternative = alternative;
};
ast_nodes_IfNode.__name__ = true;
ast_nodes_IfNode.__super__ = ast_nodes_Node;
ast_nodes_IfNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IfNode
});
var ast_nodes_IndexAssignNode = function(position,index,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.IndexAssign);
	this.index = index;
	this.value = value;
};
ast_nodes_IndexAssignNode.__name__ = true;
ast_nodes_IndexAssignNode.__super__ = ast_nodes_Node;
ast_nodes_IndexAssignNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IndexAssignNode
});
var ast_nodes_IndexNode = function(position,target,index) {
	ast_nodes_Node.call(this,position,ast_NodeType.Index);
	this.target = target;
	this.index = index;
};
ast_nodes_IndexNode.__name__ = true;
ast_nodes_IndexNode.__super__ = ast_nodes_Node;
ast_nodes_IndexNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_IndexNode
});
var ast_nodes_OperatorNode = function(position,type,left,right) {
	ast_nodes_Node.call(this,position,type);
	this.left = left;
	this.right = right;
};
ast_nodes_OperatorNode.__name__ = true;
ast_nodes_OperatorNode.__super__ = ast_nodes_Node;
ast_nodes_OperatorNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_OperatorNode
});
var ast_nodes_RangeNode = function(position,start,end,inclusive) {
	ast_nodes_Node.call(this,position,ast_NodeType.Range);
	this.start = start;
	this.end = end;
	this.inclusive = inclusive;
};
ast_nodes_RangeNode.__name__ = true;
ast_nodes_RangeNode.__super__ = ast_nodes_Node;
ast_nodes_RangeNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_RangeNode
});
var ast_nodes_RegexNode = function(position,pattern,flags) {
	ast_nodes_Node.call(this,position,ast_NodeType.Regex);
	this.pattern = pattern;
	this.flags = flags;
};
ast_nodes_RegexNode.__name__ = true;
ast_nodes_RegexNode.__super__ = ast_nodes_Node;
ast_nodes_RegexNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_RegexNode
});
var ast_nodes_ReturnNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Return);
	this.value = value;
};
ast_nodes_ReturnNode.__name__ = true;
ast_nodes_ReturnNode.__super__ = ast_nodes_Node;
ast_nodes_ReturnNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_ReturnNode
});
var ast_nodes_StatementNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Statement);
	this.value = value;
};
ast_nodes_StatementNode.__name__ = true;
ast_nodes_StatementNode.__super__ = ast_nodes_Node;
ast_nodes_StatementNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_StatementNode
});
var ast_nodes_VariableAssignNode = function(position,name,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.VariableAssign);
	this.name = name;
	this.value = value;
};
ast_nodes_VariableAssignNode.__name__ = true;
ast_nodes_VariableAssignNode.__super__ = ast_nodes_Node;
ast_nodes_VariableAssignNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_VariableAssignNode
});
var ast_nodes_VariableNode = function(position,name,value,mutable) {
	ast_nodes_Node.call(this,position,ast_NodeType.Variable);
	this.name = name;
	this.value = value;
	this.mutable = mutable;
};
ast_nodes_VariableNode.__name__ = true;
ast_nodes_VariableNode.__super__ = ast_nodes_Node;
ast_nodes_VariableNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_VariableNode
});
var ast_nodes_WhenNode = function(position,condition,cases,elseCase) {
	ast_nodes_Node.call(this,position,ast_NodeType.When);
	this.condition = condition;
	this.cases = cases;
	this.elseCase = elseCase;
};
ast_nodes_WhenNode.__name__ = true;
ast_nodes_WhenNode.__super__ = ast_nodes_Node;
ast_nodes_WhenNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_WhenNode
});
var ast_nodes_WhileNode = function(position,condition,block) {
	ast_nodes_Node.call(this,position,ast_NodeType.While);
	this.condition = condition;
	this.block = block;
};
ast_nodes_WhileNode.__name__ = true;
ast_nodes_WhileNode.__super__ = ast_nodes_Node;
ast_nodes_WhileNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_WhileNode
});
var ast_nodes_datatypes_ArrayNode = function(position,values) {
	ast_nodes_Node.call(this,position,ast_NodeType.Array);
	this.values = values;
};
ast_nodes_datatypes_ArrayNode.__name__ = true;
ast_nodes_datatypes_ArrayNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_ArrayNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_ArrayNode
});
var ast_nodes_datatypes_BooleanNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Boolean);
	this.value = value;
};
ast_nodes_datatypes_BooleanNode.__name__ = true;
ast_nodes_datatypes_BooleanNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_BooleanNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_BooleanNode
});
var ast_nodes_datatypes_FloatNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.Float);
	this.value = value;
};
ast_nodes_datatypes_FloatNode.__name__ = true;
ast_nodes_datatypes_FloatNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_FloatNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_FloatNode
});
var ast_nodes_datatypes_FunctionNode = function(position,block,parameters) {
	ast_nodes_Node.call(this,position,ast_NodeType.Function);
	this.parameters = parameters;
	this.block = block;
};
ast_nodes_datatypes_FunctionNode.__name__ = true;
ast_nodes_datatypes_FunctionNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_FunctionNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_FunctionNode
});
var ast_nodes_datatypes_HashNode = function(position,values) {
	ast_nodes_Node.call(this,position,ast_NodeType.Hash);
	this.values = values;
};
ast_nodes_datatypes_HashNode.__name__ = true;
ast_nodes_datatypes_HashNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_HashNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_HashNode
});
var ast_nodes_datatypes_NullNode = function(position) {
	ast_nodes_Node.call(this,position,ast_NodeType.Null);
};
ast_nodes_datatypes_NullNode.__name__ = true;
ast_nodes_datatypes_NullNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_NullNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_NullNode
});
var ast_nodes_datatypes_StringNode = function(position,value) {
	ast_nodes_Node.call(this,position,ast_NodeType.String);
	this.value = value;
};
ast_nodes_datatypes_StringNode.__name__ = true;
ast_nodes_datatypes_StringNode.__super__ = ast_nodes_Node;
ast_nodes_datatypes_StringNode.prototype = $extend(ast_nodes_Node.prototype,{
	__class__: ast_nodes_datatypes_StringNode
});
var build_Version = function() { };
build_Version.__name__ = true;
build_Version.getFormattedData = function() {
	var date = new Date();
	var dd = StringTools.lpad(Std.string(date.getDate()),"0",2);
	var mm = StringTools.lpad(Std.string(date.getMonth() + 1),"0",2);
	var yyyy = date.getFullYear();
	return "" + yyyy + "-" + mm + "-" + dd;
};
var code_Code = function() { };
code_Code.__name__ = true;
code_Code.make = function(op,operands) {
	var instruction = new haxe_io_BytesOutput();
	instruction.writeByte(op);
	var _g = 0;
	while(_g < operands.length) {
		var operand = operands[_g];
		++_g;
		instruction.writeInt32(operand);
	}
	return instruction.getBytes();
};
var code_OpCode = function() { };
code_OpCode.__name__ = true;
var compiler_Compiler = function(debug,warnings) {
	this.functionDepth = 0;
	this.loopPositions = new haxe_ds_GenericStack();
	this.breakPositions = new haxe_ds_GenericStack();
	this.error = new error_CompileError("","");
	this.filenameTable = new compiler_debug_FilenameTable();
	this.symbolTable = new compiler_symbol_SymbolTable();
	this.variableTable = new compiler_debug_VariableTable();
	this.lineNumberTable = new compiler_debug_LineNumberTable();
	this.instructions = new haxe_io_BytesOutput();
	this.constantPool = new compiler_constant_ConstantPool();
	this.debug = debug;
	this.warnings = warnings;
};
compiler_Compiler.__name__ = true;
compiler_Compiler.prototype = {
	getByteCode: function(compress) {
		var program = new haxe_io_BytesOutput();
		program.write(this.filenameTable.toByteCode());
		program.write(this.lineNumberTable.toByteCode());
		program.write(this.variableTable.toByteCode());
		program.write(this.constantPool.toByteCode());
		var instructionsByteCode = this.instructions.getBytes();
		this.instructions = new haxe_io_BytesOutput();
		this.instructions.write(instructionsByteCode);
		program.writeInt32(instructionsByteCode.length);
		program.write(instructionsByteCode);
		var output = new haxe_io_BytesOutput();
		output.writeByte(compress ? 1 : 0);
		if(compress) {
			output.write(haxe_zip_Compress.run(program.getBytes(),9));
		} else {
			output.write(program.getBytes());
		}
		return output.getBytes();
	}
	,compileFile: function(node) {
		var pFilename = this.error.filename;
		var pCode = this.error.code;
		this.error.filename = node.filename;
		this.error.code = node.code;
		var startIndex = this.instructions.b.pos;
		var _g = 0;
		var _g1 = node.body;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			this.compile(n);
		}
		this.error.filename = pFilename;
		this.error.code = pCode;
		if(this.debug) {
			this.filenameTable.define(startIndex,this.instructions.b.pos,node.filename);
		}
	}
	,compileBlock: function(node) {
		this.symbolTable.newScope();
		var _g = 0;
		var _g1 = node.body;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			this.compile(n);
		}
		this.symbolTable.setParent();
	}
	,compileHash: function(node) {
		var length = 0;
		var map = node.values;
		var _g_map = map;
		var _g_keys = map.keys();
		while(_g_keys.hasNext()) {
			var key = _g_keys.next();
			var _g1_value = _g_map.get(key);
			var _g1_key = key;
			var key1 = _g1_key;
			var value = _g1_value;
			this.compile(key1);
			this.compile(value);
			++length;
		}
		this.emit(30,node.position,[length]);
	}
	,compileArray: function(node) {
		var i = node.values.length;
		while(--i >= 0) this.compile(node.values[i]);
		this.emit(29,node.position,[node.values.length]);
	}
	,compileRange: function(node) {
		this.compile(node.end);
		this.compile(node.start);
		this.emit(26,node.position,[std_BuiltInTable.resolveName("Range")]);
		var constantIndex = node.inclusive ? this.constantPool.addConstant(new object_StringObj("inclusive",null)) : this.constantPool.addConstant(new object_StringObj("exclusive",null));
		this.emit(0,node.position,[constantIndex]);
		this.emit(31,node.position,[]);
		this.emit(27,node.position,[2]);
	}
	,compileRegex: function(node) {
		this.compile(node.flags);
		this.compile(node.pattern);
		this.emit(26,node.position,[std_BuiltInTable.resolveName("Regex")]);
		this.emit(0,node.position,[this.constantPool.addConstant(new object_StringObj("compile",null))]);
		this.emit(31,node.position,[]);
		this.emit(27,node.position,[2]);
	}
	,compileIndex: function(node) {
		this.compile(node.target);
		this.compile(node.index);
		this.emit(31,node.position,[]);
	}
	,compileIndexAssign: function(node) {
		this.compile(node.index);
		this.removeLastInstruction();
		this.compile(node.value);
		this.emit(32,node.position,[]);
	}
	,compileBreak: function(node) {
		if(this.loopPositions.head == null) {
			this.error.illegalBreak(node.position);
		}
		var _this = this.breakPositions;
		_this.head = new haxe_ds_GenericCell(this.instructions.b.pos,_this.head);
		this.emit(2,node.position,[0]);
	}
	,compileContinue: function(node) {
		if(this.loopPositions.head == null) {
			this.error.illegalContinue(node.position);
		}
		var _this = this.loopPositions;
		this.emit(2,node.position,[_this.head == null ? null : _this.head.elt]);
	}
	,compileStatement: function(node) {
		this.compile(node.value.value);
		this.emit(1,node.position,[]);
	}
	,compileExpression: function(node) {
		this.compile(node.value);
	}
	,compileOr: function(node) {
		this.compile(node.left);
		var jumpPeekInstructionPos = this.instructions.b.pos;
		this.emit(4,node.position,[0]);
		this.emit(1,node.position,[]);
		this.compile(node.right);
		this.overwriteInstruction(jumpPeekInstructionPos,[this.instructions.b.pos]);
	}
	,compileAnd: function(node) {
		this.compile(node.left);
		this.emit(22,node.position,[]);
		var jumpPeekInstructionPos = this.instructions.b.pos;
		this.emit(4,node.position,[0]);
		this.emit(1,node.position,[]);
		this.compile(node.right);
		var jumpInstructionPos = this.instructions.b.pos;
		this.emit(2,node.position,[0]);
		this.overwriteInstruction(jumpPeekInstructionPos,[this.instructions.b.pos]);
		this.emit(22,node.position,[]);
		this.overwriteInstruction(jumpInstructionPos,[this.instructions.b.pos]);
	}
	,compileAdd: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(5,node.position,[]);
	}
	,compileSubtract: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(6,node.position,[]);
	}
	,compileMultiply: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(7,node.position,[]);
	}
	,compileDivide: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(8,node.position,[]);
	}
	,compileModulo: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(15,node.position,[]);
	}
	,compileEquals: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(16,node.position,[]);
	}
	,compileNotEquals: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(16,node.position,[]);
		this.emit(22,node.position,[]);
	}
	,compileLessThan: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(17,node.position,[]);
	}
	,compileGreaterThan: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(19,node.position,[]);
	}
	,compileLessThanOrEqual: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(18,node.position,[]);
	}
	,compileGreaterThanOrEqual: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(20,node.position,[]);
	}
	,compileConcatString: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(23,node.position,[]);
	}
	,compileBitAnd: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(9,node.position,[]);
	}
	,compileBitOr: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(10,node.position,[]);
	}
	,compileBitShiftLeft: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(12,node.position,[]);
	}
	,compileBitShiftRight: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(13,node.position,[]);
	}
	,compileBitXor: function(node) {
		this.compile(node.left);
		this.compile(node.right);
		this.emit(11,node.position,[]);
	}
	,compileNot: function(node) {
		this.compile(node.right);
		this.emit(22,node.position,[]);
	}
	,compileNegate: function(node) {
		this.compile(node.right);
		this.emit(21,node.position,[]);
	}
	,compileBitNot: function(node) {
		this.compile(node.right);
		this.emit(14,node.position,[]);
	}
	,compileVariable: function(node) {
		var _gthis = this;
		if(node.name.type == ast_NodeType.Ident) {
			var cVariableName = (js_Boot.__cast(node.name , ast_nodes_IdentNode)).value;
			var variableStart = this.instructions.b.pos;
			if(node.value != null) {
				this.compile(node.value);
			}
			var mutable = node.mutable;
			if(_gthis.warnings && cVariableName.indexOf("$") != -1) {
				_gthis.error.dollarVariableName(node.position,cVariableName);
			}
			if(_gthis.symbolTable.currentScope.exists(cVariableName)) {
				_gthis.error.redeclareVariable(node.position,cVariableName);
			}
			var symbol = _gthis.symbolTable.define(cVariableName,mutable);
			this.emit(25,node.position,[symbol.index]);
			if(this.debug) {
				this.variableTable.define(symbol.index,variableStart,this.instructions.b.pos,cVariableName);
			}
		} else if(node.name.type == ast_NodeType.DestructureArray) {
			var cVariableName = js_Boot.__cast(node.name , ast_nodes_DestructureArrayNode);
			if(node.value != null) {
				this.compile(node.value);
			}
			var target = this.symbolTable.defineInternal();
			this.emit(25,node.position,[target]);
			var _g_current = 0;
			var _g_array = cVariableName.names;
			while(_g_current < _g_array.length) {
				var _g1_value = _g_array[_g_current];
				var _g1_key = _g_current++;
				var i = _g1_key;
				var varName = _g1_value;
				var variableStart = this.instructions.b.pos;
				var mutable = node.mutable;
				if(_gthis.warnings && varName.indexOf("$") != -1) {
					_gthis.error.dollarVariableName(node.position,varName);
				}
				if(_gthis.symbolTable.currentScope.exists(varName)) {
					_gthis.error.redeclareVariable(node.position,varName);
				}
				var symbol = _gthis.symbolTable.define(varName,mutable);
				this.emit(24,node.position,[target]);
				this.emit(0,node.position,[this.constantPool.addConstant(new object_NumberObj(i,null))]);
				this.emit(31,node.position,[]);
				this.emit(25,node.position,[symbol.index]);
				if(this.debug) {
					this.variableTable.define(symbol.index,variableStart,this.instructions.b.pos,varName);
				}
			}
		} else {
			var cVariableName = js_Boot.__cast(node.name , ast_nodes_DestructureHashNode);
			if(node.value != null) {
				this.compile(node.value);
			}
			var target = this.symbolTable.defineInternal();
			this.emit(25,node.position,[target]);
			var _g = 0;
			var _g1 = cVariableName.names;
			while(_g < _g1.length) {
				var varName = _g1[_g];
				++_g;
				var variableStart = this.instructions.b.pos;
				var mutable = node.mutable;
				if(_gthis.warnings && varName.indexOf("$") != -1) {
					_gthis.error.dollarVariableName(node.position,varName);
				}
				if(_gthis.symbolTable.currentScope.exists(varName)) {
					_gthis.error.redeclareVariable(node.position,varName);
				}
				var symbol = _gthis.symbolTable.define(varName,mutable);
				this.emit(24,node.position,[target]);
				this.emit(0,node.position,[this.constantPool.addConstant(new object_StringObj(varName,null))]);
				this.emit(31,node.position,[]);
				this.emit(25,node.position,[symbol.index]);
				if(this.debug) {
					this.variableTable.define(symbol.index,variableStart,this.instructions.b.pos,varName);
				}
			}
		}
	}
	,compileVariableAssign: function(node) {
		var variableStart = this.instructions.b.pos;
		var symbol = this.symbolTable.resolve(node.name.value);
		if(symbol == null) {
			this.error.symbolUndefined(node.position,node.name.value);
		} else if(!symbol.mutable) {
			this.error.symbolImmutable(node.position,node.name.value);
		}
		this.compile(node.value);
		this.emit(25,node.position,[symbol.index]);
		if(this.debug) {
			this.variableTable.define(symbol.index,variableStart,this.instructions.b.pos,node.name.value);
		}
	}
	,compileIdent: function(node) {
		var symbol = this.symbolTable.resolve(node.value);
		if(symbol == null) {
			var builtInIndex = std_BuiltInTable.resolveName(node.value);
			if(builtInIndex != -1) {
				this.emit(26,node.position,[builtInIndex]);
			} else {
				this.error.symbolUndefined(node.position,node.value);
			}
		} else {
			this.emit(24,node.position,[symbol.index]);
		}
	}
	,compileFunction: function(node) {
		this.emit(0,node.position,[this.constantPool.getSize()]);
		var jumpInstructionPos = this.instructions.b.pos;
		this.emit(2,node.position,[0]);
		this.functionDepth++;
		this.constantPool.addConstant(new object_UserFunctionObj(this.instructions.b.pos,node.parameters.length,null));
		this.symbolTable.newScope();
		var _g = 0;
		var _g1 = node.parameters;
		while(_g < _g1.length) {
			var parameter = _g1[_g];
			++_g;
			var variableStart = this.instructions.b.pos;
			var symbol = this.symbolTable.define(parameter.value,true);
			this.emit(25,node.position,[symbol.index]);
			if(this.debug) {
				this.variableTable.define(symbol.index,variableStart,this.instructions.b.pos,parameter.value);
			}
		}
		this.compile(node.block);
		this.emit(28,node.position,[]);
		this.overwriteInstruction(jumpInstructionPos,[this.instructions.b.pos]);
		this.symbolTable.setParent();
		this.functionDepth--;
	}
	,compileFunctionCall: function(node) {
		var i = node.parameters.length;
		while(--i >= 0) this.compile(node.parameters[i]);
		this.compile(node.target);
		this.emit(27,node.position,[node.parameters.length]);
	}
	,compileReturn: function(node) {
		if(this.functionDepth <= 0) {
			this.error.illegalReturn(node.position);
		}
		if(node.value != null) {
			this.compile(node.value);
		}
		this.emit(28,node.position,[]);
	}
	,compileIf: function(node) {
		this.compile(node.condition);
		var jumpNotInstructionPos = this.instructions.b.pos;
		this.emit(3,node.position,[0]);
		this.compile(node.consequence);
		var jumpInstructionPos = this.instructions.b.pos;
		this.emit(2,node.position,[0]);
		var jumpNotPos = this.instructions.b.pos;
		if(node.alternative != null) {
			this.compile(node.alternative);
		}
		var jumpPos = this.instructions.b.pos;
		this.overwriteInstruction(jumpNotInstructionPos,[jumpNotPos]);
		this.overwriteInstruction(jumpInstructionPos,[jumpPos]);
	}
	,compileWhen: function(node) {
		var condition = 0;
		if(node.condition != null) {
			this.compile(node.condition);
			condition = this.symbolTable.defineInternal();
			this.emit(25,node.position,[condition]);
		}
		var jumpPositions = [];
		var _g = 0;
		var _g1 = node.cases;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			this.compile(c.condition);
			if(node.condition != null) {
				this.emit(24,node.position,[condition]);
				this.emit(16,node.position,[]);
			}
			var jumpNotPos = this.instructions.b.pos;
			this.emit(3,node.position,[0]);
			this.compile(c.consequence);
			jumpPositions.push(this.instructions.b.pos);
			this.emit(2,node.position,[0]);
			this.overwriteInstruction(jumpNotPos,[this.instructions.b.pos]);
		}
		if(node.elseCase != null) {
			this.compile(node.elseCase);
		}
		var _g = 0;
		while(_g < jumpPositions.length) {
			var pos = jumpPositions[_g];
			++_g;
			this.overwriteInstruction(pos,[this.instructions.b.pos]);
		}
	}
	,compileFor: function(node) {
		this.compile(node.iterator);
		this.emit(0,node.position,[this.constantPool.addConstant(new object_StringObj("Iterator",null))]);
		this.emit(31,node.position,[]);
		this.emit(27,node.position,[0]);
		var iterator = this.symbolTable.defineInternal();
		this.emit(25,node.position,[iterator]);
		var jumpPos = this.instructions.b.pos;
		var _this = this.loopPositions;
		_this.head = new haxe_ds_GenericCell(jumpPos,_this.head);
		this.emit(24,node.position,[iterator]);
		this.emit(0,node.position,[this.constantPool.addConstant(new object_StringObj("hasNext",null))]);
		this.emit(31,node.position,[]);
		this.emit(27,node.position,[0]);
		var jumpNotPos = this.instructions.b.pos;
		this.emit(3,node.position,[0]);
		this.emit(24,node.position,[iterator]);
		this.emit(0,node.position,[this.constantPool.addConstant(new object_StringObj("next",null))]);
		this.emit(31,node.position,[]);
		this.emit(27,node.position,[0]);
		this.symbolTable.newScope();
		if(node.variable != null) {
			this.compile(node.variable);
		} else {
			this.emit(1,node.position,[]);
		}
		this.compile(node.block);
		this.symbolTable.setParent();
		this.emit(2,node.position,[jumpPos]);
		while(this.breakPositions.head != null) {
			var _this = this.breakPositions;
			var k = _this.head;
			var tmp;
			if(k == null) {
				tmp = null;
			} else {
				_this.head = k.next;
				tmp = k.elt;
			}
			this.overwriteInstruction(tmp,[this.instructions.b.pos]);
		}
		var _this = this.loopPositions;
		var k = _this.head;
		if(k != null) {
			_this.head = k.next;
		}
		this.overwriteInstruction(jumpNotPos,[this.instructions.b.pos]);
	}
	,compileWhile: function(node) {
		var jumpPos = this.instructions.b.pos;
		var _this = this.loopPositions;
		_this.head = new haxe_ds_GenericCell(jumpPos,_this.head);
		this.compile(node.condition);
		var jumpNotInstructionPos = this.instructions.b.pos;
		this.emit(3,node.position,[0]);
		this.compile(node.block);
		this.emit(2,node.position,[jumpPos]);
		while(this.breakPositions.head != null) {
			var _this = this.breakPositions;
			var k = _this.head;
			var tmp;
			if(k == null) {
				tmp = null;
			} else {
				_this.head = k.next;
				tmp = k.elt;
			}
			this.overwriteInstruction(tmp,[this.instructions.b.pos]);
		}
		var _this = this.loopPositions;
		var k = _this.head;
		if(k != null) {
			_this.head = k.next;
		}
		this.overwriteInstruction(jumpNotInstructionPos,[this.instructions.b.pos]);
	}
	,compile: function(node) {
		switch(node.type._hx_index) {
		case 0:
			this.compileFile(js_Boot.__cast(node , ast_nodes_FileNode));
			break;
		case 1:
			this.compileBlock(js_Boot.__cast(node , ast_nodes_BlockNode));
			break;
		case 2:
			this.compileExpression(js_Boot.__cast(node , ast_nodes_ExpressionNode));
			break;
		case 3:
			this.compileStatement(js_Boot.__cast(node , ast_nodes_StatementNode));
			break;
		case 4:
			this.compileVariable(js_Boot.__cast(node , ast_nodes_VariableNode));
			break;
		case 5:
			this.compileVariableAssign(js_Boot.__cast(node , ast_nodes_VariableAssignNode));
			break;
		case 8:
			this.compileIdent(js_Boot.__cast(node , ast_nodes_IdentNode));
			break;
		case 9:
			this.compileFunctionCall(js_Boot.__cast(node , ast_nodes_CallNode));
			break;
		case 10:
			this.compileAdd(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 11:
			this.compileSubtract(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 12:
			this.compileMultiply(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 13:
			this.compileDivide(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 14:
			this.compileModulo(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 15:
			this.compileOr(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 16:
			this.compileAnd(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 17:
			this.compileLessThan(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 18:
			this.compileLessThanOrEqual(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 19:
			this.compileGreaterThan(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 20:
			this.compileGreaterThanOrEqual(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 21:
			this.compileConcatString(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 22:
			this.compileEquals(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 23:
			this.compileNotEquals(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 24:
			this.compileNegate(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 25:
			this.compileNot(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 26:
			this.compileBitAnd(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 27:
			this.compileBitOr(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 28:
			this.compileBitXor(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 29:
			this.compileBitNot(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 30:
			this.compileBitShiftLeft(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 31:
			this.compileBitShiftRight(js_Boot.__cast(node , ast_nodes_OperatorNode));
			break;
		case 34:
			this.compileFunction(js_Boot.__cast(node , ast_nodes_datatypes_FunctionNode));
			break;
		case 36:
			this.compileArray(js_Boot.__cast(node , ast_nodes_datatypes_ArrayNode));
			break;
		case 37:
			this.compileHash(js_Boot.__cast(node , ast_nodes_datatypes_HashNode));
			break;
		case 32:case 33:case 35:case 38:
			var constantIndex;
			switch(node.type._hx_index) {
			case 32:
				constantIndex = this.constantPool.addConstant(new object_NumberObj((js_Boot.__cast(node , ast_nodes_datatypes_FloatNode)).value,null));
				break;
			case 33:
				constantIndex = this.constantPool.addConstant(new object_StringObj((js_Boot.__cast(node , ast_nodes_datatypes_StringNode)).value,null));
				break;
			case 35:
				constantIndex = this.constantPool.addConstant(new object_BooleanObj((js_Boot.__cast(node , ast_nodes_datatypes_BooleanNode)).value,null));
				break;
			case 38:
				constantIndex = this.constantPool.addConstant(new object_NullObj(null));
				break;
			default:
				constantIndex = 0;
			}
			this.emit(0,node.position,[constantIndex]);
			break;
		case 39:
			this.compileReturn(js_Boot.__cast(node , ast_nodes_ReturnNode));
			break;
		case 40:
			this.compileBreak(js_Boot.__cast(node , ast_nodes_BreakNode));
			break;
		case 41:
			this.compileContinue(js_Boot.__cast(node , ast_nodes_ContinueNode));
			break;
		case 42:
			this.compileIf(js_Boot.__cast(node , ast_nodes_IfNode));
			break;
		case 43:
			this.compileWhile(js_Boot.__cast(node , ast_nodes_WhileNode));
			break;
		case 44:
			this.compileFor(js_Boot.__cast(node , ast_nodes_ForNode));
			break;
		case 45:
			this.compileWhen(js_Boot.__cast(node , ast_nodes_WhenNode));
			break;
		case 46:
			this.compileRange(js_Boot.__cast(node , ast_nodes_RangeNode));
			break;
		case 47:
			this.compileRegex(js_Boot.__cast(node , ast_nodes_RegexNode));
			break;
		case 48:
			this.compileIndex(js_Boot.__cast(node , ast_nodes_IndexNode));
			break;
		case 49:
			this.compileIndexAssign(js_Boot.__cast(node , ast_nodes_IndexAssignNode));
			break;
		default:
		}
	}
	,removeLastInstruction: function() {
		var currentBytes = this.instructions.getBytes();
		this.instructions = new haxe_io_BytesOutput();
		this.instructions.writeBytes(currentBytes,0,currentBytes.length - 1);
	}
	,overwriteInstruction: function(pos,operands) {
		var currentBytes = this.instructions.getBytes();
		currentBytes.setInt32(pos + 1,operands[0]);
		this.instructions = new haxe_io_BytesOutput();
		this.instructions.write(currentBytes);
	}
	,emit: function(op,position,operands) {
		if(this.debug) {
			this.lineNumberTable.define(this.instructions.b.pos,position);
		}
		var instruction = code_Code.make(op,operands);
		this.instructions.write(instruction);
	}
	,__class__: compiler_Compiler
};
var compiler_constant_ConstantPool = function() {
	this.constants = [];
};
compiler_constant_ConstantPool.__name__ = true;
compiler_constant_ConstantPool.fromByteCode = function(byteCode,vm) {
	var pool = [];
	var poolSize = byteCode.readInt32();
	var startPosition = byteCode.pos;
	while(byteCode.pos < startPosition + poolSize) {
		var type = byteCode.readByte();
		switch(type) {
		case 0:
			var value = byteCode.readDouble();
			pool.push(new object_NumberObj(value,vm));
			break;
		case 1:
			var length = byteCode.readInt32();
			var value1 = byteCode.readString(length);
			pool.push(new object_StringObj(value1,vm));
			break;
		case 2:
			var position = byteCode.readInt32();
			var parametersCount = byteCode.readInt16();
			pool.push(new object_UserFunctionObj(position,parametersCount,vm));
			break;
		case 3:
			pool.push(new object_NullObj(vm));
			break;
		case 4:
			var value2 = byteCode.readByte();
			pool.push(new object_BooleanObj(value2 != 0,vm));
			break;
		default:
		}
	}
	return pool;
};
compiler_constant_ConstantPool.prototype = {
	addConstant: function(obj) {
		var _g_current = 0;
		var _g_array = this.constants;
		while(_g_current < _g_array.length) {
			var _g1_value = _g_array[_g_current];
			var _g1_key = _g_current++;
			var i = _g1_key;
			var c = _g1_value;
			if(c.equals(obj)) {
				return i;
			}
		}
		return this.constants.push(obj) - 1;
	}
	,getSize: function() {
		return this.constants.length;
	}
	,toByteCode: function() {
		var constantsBytes = new haxe_io_BytesOutput();
		var _g = 0;
		var _g1 = this.constants;
		while(_g < _g1.length) {
			var $const = _g1[_g];
			++_g;
			switch($const.type._hx_index) {
			case 0:
				var cNumber = js_Boot.__cast($const , object_NumberObj);
				constantsBytes.writeByte(0);
				constantsBytes.writeDouble(cNumber.value);
				break;
			case 1:
				var cBoolean = js_Boot.__cast($const , object_BooleanObj);
				constantsBytes.writeByte(4);
				constantsBytes.writeByte(cBoolean.value ? 1 : 0);
				break;
			case 2:
				var cString = js_Boot.__cast($const , object_StringObj);
				constantsBytes.writeByte(1);
				constantsBytes.writeInt32(haxe_io_Bytes.ofString(cString.value).length);
				constantsBytes.writeString(cString.value);
				break;
			case 6:
				var cUserFunction = js_Boot.__cast($const , object_UserFunctionObj);
				constantsBytes.writeByte(2);
				constantsBytes.writeInt32(cUserFunction.position);
				constantsBytes.writeInt16(cUserFunction.parametersCount);
				break;
			case 8:
				constantsBytes.writeByte(3);
				break;
			default:
			}
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(constantsBytes.b.pos);
		output.write(constantsBytes.getBytes());
		return output.getBytes();
	}
	,__class__: compiler_constant_ConstantPool
};
var compiler_constant_ConstantType = function() { };
compiler_constant_ConstantType.__name__ = true;
var compiler_debug_FilenameTable = function() {
	this.table = [];
};
compiler_debug_FilenameTable.__name__ = true;
compiler_debug_FilenameTable.prototype = {
	define: function(start,end,filename) {
		this.table.push({ start : start, end : end, filename : filename});
	}
	,resolve: function(byteIndex) {
		var prev = null;
		var _g = 0;
		var _g1 = this.table;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.start <= byteIndex && entry.end >= byteIndex) {
				if(prev == null) {
					prev = entry;
					continue;
				}
				if(entry.start >= prev.start && entry.end <= prev.end) {
					prev = entry;
				}
			}
		}
		if(prev == null) {
			return null;
		} else {
			return prev.filename;
		}
	}
	,toByteCode: function() {
		var tableBytes = new haxe_io_BytesOutput();
		var _g = 0;
		var _g1 = this.table;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			tableBytes.writeInt32(entry.start);
			tableBytes.writeInt32(entry.end);
			tableBytes.writeInt32(haxe_io_Bytes.ofString(entry.filename).length);
			tableBytes.writeString(entry.filename);
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(tableBytes.b.pos);
		output.write(tableBytes.getBytes());
		return output.getBytes();
	}
	,fromByteCode: function(byteCode) {
		var tableSize = byteCode.readInt32();
		var startPosition = byteCode.pos;
		while(byteCode.pos < startPosition + tableSize) {
			var start = byteCode.readInt32();
			var end = byteCode.readInt32();
			var filenameLength = byteCode.readInt32();
			var filename = byteCode.readString(filenameLength);
			this.table.push({ start : start, end : end, filename : filename});
		}
		return this;
	}
	,__class__: compiler_debug_FilenameTable
};
var compiler_debug_LineNumberTable = function() {
	this.table = new haxe_ds_IntMap();
};
compiler_debug_LineNumberTable.__name__ = true;
compiler_debug_LineNumberTable.prototype = {
	define: function(byteIndex,sourcePosition) {
		this.table.h[byteIndex] = sourcePosition;
	}
	,resolve: function(byteIndex) {
		if(byteIndex < 0) {
			return null;
		}
		var position = this.table.h[byteIndex];
		if(position != null) {
			return position;
		} else {
			return this.resolve(byteIndex - 1);
		}
	}
	,toByteCode: function() {
		var tableBytes = new haxe_io_BytesOutput();
		var map = this.table;
		var _g_map = map;
		var _g_keys = map.keys();
		while(_g_keys.hasNext()) {
			var key = _g_keys.next();
			var _g1_value = _g_map.get(key);
			var _g1_key = key;
			var byteIndex = _g1_key;
			var position = _g1_value;
			tableBytes.writeInt32(byteIndex);
			tableBytes.writeInt32(position.line);
			tableBytes.writeInt32(position.lineOffset);
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(tableBytes.b.pos);
		output.write(tableBytes.getBytes());
		return output.getBytes();
	}
	,fromByteCode: function(byteCode) {
		var tableSize = byteCode.readInt32();
		var startPosition = byteCode.pos;
		while(byteCode.pos < startPosition + tableSize) {
			var byteIndex = byteCode.readInt32();
			var line = byteCode.readInt32();
			var lineOffset = byteCode.readInt32();
			var this1 = this.table;
			var value = new lexer_Position(1,line,lineOffset);
			this1.h[byteIndex] = value;
		}
		return this;
	}
	,__class__: compiler_debug_LineNumberTable
};
var compiler_debug_VariableTable = function() {
	this.table = [];
};
compiler_debug_VariableTable.__name__ = true;
compiler_debug_VariableTable.prototype = {
	define: function(index,start,end,name) {
		this.table.push({ index : index, start : start, end : end, name : name});
	}
	,resolve: function(byteIndex) {
		var prev = null;
		var _g = 0;
		var _g1 = this.table;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			if(entry.start < byteIndex && entry.end >= byteIndex) {
				if(prev == null) {
					prev = entry;
					continue;
				}
				if(entry.start >= prev.start && entry.end <= prev.end) {
					prev = entry;
				}
			}
		}
		if(prev == null) {
			return null;
		} else {
			return prev.name;
		}
	}
	,toByteCode: function() {
		var tableBytes = new haxe_io_BytesOutput();
		var _g = 0;
		var _g1 = this.table;
		while(_g < _g1.length) {
			var entry = _g1[_g];
			++_g;
			tableBytes.writeInt32(entry.index);
			tableBytes.writeInt32(entry.start);
			tableBytes.writeInt32(entry.end);
			tableBytes.writeInt32(haxe_io_Bytes.ofString(entry.name).length);
			tableBytes.writeString(entry.name);
		}
		var output = new haxe_io_BytesOutput();
		output.writeInt32(tableBytes.b.pos);
		output.write(tableBytes.getBytes());
		return output.getBytes();
	}
	,fromByteCode: function(byteCode) {
		var tableSize = byteCode.readInt32();
		var startPosition = byteCode.pos;
		while(byteCode.pos < startPosition + tableSize) {
			var index = byteCode.readInt32();
			var start = byteCode.readInt32();
			var end = byteCode.readInt32();
			var nameLength = byteCode.readInt32();
			var name = byteCode.readString(nameLength);
			this.table.push({ index : index, start : start, end : end, name : name});
		}
		return this;
	}
	,__class__: compiler_debug_VariableTable
};
var compiler_symbol_Symbol = function(index,mutable) {
	this.index = index;
	this.mutable = mutable;
};
compiler_symbol_Symbol.__name__ = true;
compiler_symbol_Symbol.prototype = {
	__class__: compiler_symbol_Symbol
};
var compiler_symbol_SymbolScope = function(parent) {
	this.symbols = new haxe_ds_StringMap();
	this.parent = null;
	this.parent = parent;
};
compiler_symbol_SymbolScope.__name__ = true;
compiler_symbol_SymbolScope.prototype = {
	resolve: function(name) {
		return this.symbols.h[name];
	}
	,define: function(name,value) {
		this.symbols.h[name] = value;
	}
	,exists: function(name) {
		return this.resolve(name) != null;
	}
	,__class__: compiler_symbol_SymbolScope
};
var compiler_symbol_SymbolTable = function() {
	this.currentScope = new compiler_symbol_SymbolScope(null);
	this.symbolIndex = 0;
};
compiler_symbol_SymbolTable.__name__ = true;
compiler_symbol_SymbolTable.prototype = {
	newScope: function() {
		this.currentScope = new compiler_symbol_SymbolScope(this.currentScope);
	}
	,setParent: function() {
		this.currentScope = this.currentScope.parent;
	}
	,define: function(name,mutable) {
		var symbol = new compiler_symbol_Symbol(this.symbolIndex,mutable);
		this.currentScope.define(name,symbol);
		this.symbolIndex++;
		return symbol;
	}
	,defineInternal: function() {
		return this.symbolIndex++;
	}
	,resolve: function(name) {
		var cScope = this.currentScope;
		while(cScope != null && !cScope.exists(name)) cScope = cScope.parent;
		if(cScope == null) {
			return null;
		}
		return cScope.resolve(name);
	}
	,__class__: compiler_symbol_SymbolTable
};
var error_CompileError = function(filename,code) {
	this.filename = filename;
	this.code = code;
};
error_CompileError.__name__ = true;
error_CompileError.prototype = {
	getMinIndentation: function(code) {
		var min = 2147483647;
		var _g = 0;
		while(_g < code.length) {
			var line = code[_g];
			++_g;
			var tmp;
			if(line.length != 0) {
				var s = line.charAt(0);
				tmp = new EReg("\r\n|\r|\n","").match(s);
			} else {
				tmp = true;
			}
			if(tmp) {
				continue;
			}
			var spaces = 0;
			var _g1 = 0;
			var _g2 = line.length;
			while(_g1 < _g2) {
				var i = _g1++;
				if(line.charAt(i) == " ") {
					++spaces;
				} else {
					break;
				}
			}
			if(spaces < min) {
				min = spaces;
			}
		}
		return min;
	}
	,printCode: function(position,errorLinePosEnd,message) {
		var codePreviewFull = this.code.split("\n");
		var previewStart = error_ErrorHelper.clamp(1,position.line - 2,position.line - 2);
		var previewEnd = error_ErrorHelper.clamp(1,codePreviewFull.length + 1,position.line + 3);
		var codePreview = codePreviewFull.slice(previewStart - 1,previewEnd);
		var minIndentation = this.getMinIndentation(codePreview);
		var lineCountWidth = Std.string(position.line + 3).length;
		var _g = previewStart;
		var _g1 = previewEnd;
		while(_g < _g1) {
			var i = _g++;
			var lineCount = StringTools.rpad(i == null ? "null" : "" + i," ",lineCountWidth);
			var codeLine = codePreviewFull[i - 1].substring(minIndentation);
			if(i == position.line) {
				if(errorLinePosEnd == -1) {
					var highlightPosition = new StringBuf();
					var x = "" + error_ErrorHelper.repeatString(position.lineOffset - minIndentation," ") + "^ ";
					highlightPosition.b += Std.string(x);
					if(message != null) {
						highlightPosition.b += message == null ? "null" : "" + message;
					}
					var outputStream = 0;
					if(outputStream == null) {
						outputStream = 0;
					}
					Console.printFormatted(Console.logPrefix + ("" + ("   " + lineCount + " | " + codeLine)) + "\n",outputStream);
					var s = Console.logPrefix;
					var s1 = "   " + error_ErrorHelper.repeatString(lineCountWidth," ") + " | <#DE4A3F>";
					var outputStream1 = 0;
					if(outputStream1 == null) {
						outputStream1 = 0;
					}
					Console.printFormatted(s + ("" + (s1 + Std.string(highlightPosition) + "</>")) + "\n",outputStream1);
				} else {
					var literalLength = errorLinePosEnd - position.lineOffset;
					var codeLineHighlighted_b = "";
					codeLineHighlighted_b += Std.string(codeLine.substring(0,position.lineOffset - minIndentation));
					codeLineHighlighted_b += "<#DE4A3F>";
					codeLineHighlighted_b += Std.string(HxOverrides.substr(codeLine,position.lineOffset - minIndentation,literalLength));
					codeLineHighlighted_b += "</>";
					codeLineHighlighted_b += Std.string(HxOverrides.substr(codeLine,position.lineOffset - minIndentation + literalLength,null));
					var outputStream2 = 0;
					if(outputStream2 == null) {
						outputStream2 = 0;
					}
					Console.printFormatted(Console.logPrefix + ("" + ("   " + lineCount + " | " + codeLineHighlighted_b)) + "\n",outputStream2);
					var underline = "" + error_ErrorHelper.repeatString(position.lineOffset - minIndentation," ") + error_ErrorHelper.repeatString(literalLength,"~");
					var s2 = Console.logPrefix + ("" + ("   " + error_ErrorHelper.repeatString(lineCountWidth," ") + " | <#DE4A3F>" + underline + "</>"));
					var outputStream3 = 0;
					if(outputStream3 == null) {
						outputStream3 = 0;
					}
					Console.printFormatted(s2 + "\n",outputStream3);
				}
			} else {
				var outputStream4 = 0;
				if(outputStream4 == null) {
					outputStream4 = 0;
				}
				Console.printFormatted(Console.logPrefix + ("" + ("   " + lineCount + " | " + codeLine)) + "\n",outputStream4);
			}
		}
	}
	,printErrorHead: function(position,message) {
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + this.filename + ":" + position.line + ":" + (position.lineOffset + 1) + "</> <#DE4A3F>error:</> " + message)) + "\n",outputStream);
	}
	,printWarnHead: function(position,message) {
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + this.filename + ":" + position.line + ":" + (position.lineOffset + 1) + "</> <#F39C11>warning:</> " + message)) + "\n",outputStream);
	}
	,unexpectedToken: function(token,expected) {
		this.printErrorHead(token.position,"unexpected token `" + token.literal + "` (" + Std.string(token.type) + ")");
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("Expected " + expected + ".")) + "\n",outputStream);
		this.printCode(token.position,token.position.lineOffset + token.literal.length);
		error_ErrorHelper.exit();
	}
	,missingSemicolon: function(token) {
		this.printErrorHead(token.position,"missing semicolon");
		this.printCode(token.position,token.position.lineOffset + token.literal.length);
		error_ErrorHelper.exit();
	}
	,unexpectedEof: function(token) {
		this.printErrorHead(token.position,"unexpcted end of file");
		this.printCode(token.position,token.position.lineOffset + token.literal.length);
		error_ErrorHelper.exit();
	}
	,illegalToken: function(token) {
		this.printErrorHead(token.position,"illegal token `" + token.literal + "` (" + Std.string(token.type) + ")");
		this.printCode(token.position,token.position.lineOffset + token.literal.length);
		error_ErrorHelper.exit();
	}
	,importFailed: function(token,fileName) {
		this.printErrorHead(token.position,"failed to import file `" + fileName + "`");
		this.printCode(token.position,token.position.lineOffset + token.literal.length);
		error_ErrorHelper.exit();
	}
	,illegalContinue: function(position) {
		this.printErrorHead(position,"illegal continue statement");
		this.printCode(position,-1,"may only be used inside loops");
		error_ErrorHelper.exit();
	}
	,illegalBreak: function(position) {
		this.printErrorHead(position,"illegal break statement");
		this.printCode(position,-1,"may only be used inside loops");
		error_ErrorHelper.exit();
	}
	,illegalReturn: function(position) {
		this.printErrorHead(position,"illegal return statement");
		this.printCode(position,-1,"may only be used inside functions");
		error_ErrorHelper.exit();
	}
	,symbolUndefined: function(position,symbol) {
		this.printErrorHead(position,"cannot find symbol `" + symbol + "` in this scope");
		this.printCode(position,-1,"not found in this scope");
		error_ErrorHelper.exit();
	}
	,symbolImmutable: function(position,symbol) {
		this.printErrorHead(position,"cannot re-assign to immutable variable `" + symbol + "`");
		this.printCode(position,-1,"cannot be re-assgined");
		error_ErrorHelper.exit();
	}
	,redeclareVariable: function(position,symbol) {
		this.printErrorHead(position,"cannot re-declare immutable variable `" + symbol + "`");
		this.printCode(position,-1,"has already been declared in this scope");
		error_ErrorHelper.exit();
	}
	,dollarVariableName: function(position,symbol) {
		this.printWarnHead(position,"symbol name `" + symbol + "` contains $ which should be used only in mechanically generated code");
	}
	,__class__: error_CompileError
};
var error_ErrorHelper = function() { };
error_ErrorHelper.__name__ = true;
error_ErrorHelper.repeatString = function(length,s) {
	var buffer_b = "";
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var _ = _g++;
		buffer_b += s == null ? "null" : "" + s;
	}
	return buffer_b;
};
error_ErrorHelper.clamp = function(min,max,value) {
	if(value < min) {
		return min;
	} else if(value > max) {
		return max;
	} else {
		return value;
	}
};
error_ErrorHelper.exit = function() {
	throw haxe_Exception.thrown("");
};
var error_RuntimeError = function(vm) {
	this.vm = vm;
};
error_RuntimeError.__name__ = true;
error_RuntimeError.prototype = {
	printHead: function(message) {
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		Console.printFormatted(Console.logPrefix + ("" + ("<#DE4A3F>error:</> " + message + ".")) + "\n",outputStream);
	}
	,printStackTrace: function() {
		var position = this.vm.lineNumberTable.resolve(this.vm.instructions.pos);
		var filename = this.vm.filenameTable.resolve(this.vm.instructions.pos);
		while(this.vm.frames.head != null) {
			var frame = this.vm.popFrame();
			var functionPosition;
			if(frame.calledFunction != null && frame.calledFunction.type == object_ObjectType.UserFunction) {
				var cUserFunction = js_Boot.__cast(frame.calledFunction , object_UserFunctionObj);
				functionPosition = cUserFunction.position;
			} else {
				functionPosition = -1;
			}
			var functionName = this.vm.variableTable.resolve(functionPosition);
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			Console.printFormatted(Console.logPrefix + ("" + ("   at " + (functionName == null ? "[anonymous]" : functionName) + " (" + filename + ":" + position.line + ":" + (position.lineOffset + 1) + ")")) + "\n",outputStream);
			position = this.vm.lineNumberTable.resolve(frame.returnAddress);
			filename = this.vm.filenameTable.resolve(frame.returnAddress);
		}
	}
	,error: function(message) {
		this.printHead(message);
		this.printStackTrace();
		error_ErrorHelper.exit();
	}
	,__class__: error_RuntimeError
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = true;
haxe__$Int64__$_$_$Int64.prototype = {
	__class__: haxe__$Int64__$_$_$Int64
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
haxe_crypto_Adler32.__name__ = true;
haxe_crypto_Adler32.read = function(i) {
	var a = new haxe_crypto_Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
};
haxe_crypto_Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
	,__class__: haxe_crypto_Adler32
};
var haxe_ds_GenericCell = function(elt,next) {
	this.elt = elt;
	this.next = next;
};
haxe_ds_GenericCell.__name__ = true;
haxe_ds_GenericCell.prototype = {
	__class__: haxe_ds_GenericCell
};
var haxe_ds_GenericStack = function() {
};
haxe_ds_GenericStack.__name__ = true;
haxe_ds_GenericStack.prototype = {
	iterator: function() {
		var l = this.head;
		return { hasNext : function() {
			return l != null;
		}, next : function() {
			var k = l;
			l = k.next;
			return k.elt;
		}};
	}
	,__class__: haxe_ds_GenericStack
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	,iterator: function() {
		return new haxe_ds__$StringMap_StringMapValueIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = true;
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds__$StringMap_StringMapValueIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapValueIterator.__name__ = true;
haxe_ds__$StringMap_StringMapValueIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.h[this.keys[this.current++]];
	}
	,__class__: haxe_ds__$StringMap_StringMapValueIterator
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
haxe_exceptions_PosException.__name__ = true;
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
haxe_exceptions_NotImplementedException.__name__ = true;
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = s.charCodeAt(i * 2);
		var low = s.charCodeAt(i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,setDouble: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
	,setFloat: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,setUInt16: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,toHex: function() {
		var s_b = "";
		var chars = [];
		var str = "0123456789abcdef";
		var _g = 0;
		var _g1 = str.length;
		while(_g < _g1) {
			var i = _g++;
			chars.push(HxOverrides.cca(str,i));
		}
		var _g = 0;
		var _g1 = this.length;
		while(_g < _g1) {
			var i = _g++;
			var c = this.b[i];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,readAll: function(bufsize) {
		if(bufsize == null) {
			bufsize = 16384;
		}
		var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
		var total = new haxe_io_BytesBuffer();
		try {
			while(true) {
				var len = this.readBytes(buf,0,bufsize);
				if(len == 0) {
					throw haxe_Exception.thrown(haxe_io_Error.Blocked);
				}
				total.addBytes(buf,0,len);
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return total.getBytes();
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
	,__class__: haxe_io_Input
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	set_position: function(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	,readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeFloat: function(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	,writeDouble: function(x) {
		var i64 = haxe_io_FPHelper.doubleToI64(x);
		if(this.bigEndian) {
			this.writeInt32(i64.high);
			this.writeInt32(i64.low);
		} else {
			this.writeInt32(i64.low);
			this.writeInt32(i64.high);
		}
	}
	,writeInt8: function(x) {
		if(x < -128 || x >= 128) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		this.writeByte(x & 255);
	}
	,writeInt16: function(x) {
		if(x < -32768 || x >= 32768) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		this.writeUInt16(x & 65535);
	}
	,writeUInt16: function(x) {
		if(x < 0 || x >= 65536) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	,writeInt24: function(x) {
		if(x < -8388608 || x >= 8388608) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		this.writeUInt24(x & 16777215);
	}
	,writeUInt24: function(x) {
		if(x < 0 || x >= 16777216) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 16);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16);
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
haxe_io_FPHelper.doubleToI64 = function(v) {
	var i64 = haxe_io_FPHelper.i64tmp;
	haxe_io_FPHelper.helper.setFloat64(0,v,true);
	i64.low = haxe_io_FPHelper.helper.getInt32(0,true);
	i64.high = haxe_io_FPHelper.helper.getInt32(4,true);
	return i64;
};
var haxe_io_Path = function() { };
haxe_io_Path.__name__ = true;
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__:true,__constructs__:null
	,DoubleQuotes: {_hx_name:"DoubleQuotes",_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_name:"SingleQuotes",_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
haxe_macro_StringLiteralKind.__constructs__ = [haxe_macro_StringLiteralKind.DoubleQuotes,haxe_macro_StringLiteralKind.SingleQuotes];
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__:true,__constructs__:null
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CIdent",$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CRegexp",$_.__params__ = ["r","opt"],$_)
};
haxe_macro_Constant.__constructs__ = [haxe_macro_Constant.CInt,haxe_macro_Constant.CFloat,haxe_macro_Constant.CString,haxe_macro_Constant.CIdent,haxe_macro_Constant.CRegexp];
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:true,__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:true,__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
var haxe_macro_FunctionKind = $hxEnums["haxe.macro.FunctionKind"] = { __ename__:true,__constructs__:null
	,FAnonymous: {_hx_name:"FAnonymous",_hx_index:0,__enum__:"haxe.macro.FunctionKind",toString:$estr}
	,FNamed: ($_=function(name,inlined) { return {_hx_index:1,name:name,inlined:inlined,__enum__:"haxe.macro.FunctionKind",toString:$estr}; },$_._hx_name="FNamed",$_.__params__ = ["name","inlined"],$_)
	,FArrow: {_hx_name:"FArrow",_hx_index:2,__enum__:"haxe.macro.FunctionKind",toString:$estr}
};
haxe_macro_FunctionKind.__constructs__ = [haxe_macro_FunctionKind.FAnonymous,haxe_macro_FunctionKind.FNamed,haxe_macro_FunctionKind.FArrow];
var haxe_macro_ExprDef = $hxEnums["haxe.macro.ExprDef"] = { __ename__:true,__constructs__:null
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EConst",$_.__params__ = ["c"],$_)
	,EArray: ($_=function(e1,e2) { return {_hx_index:1,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EArray",$_.__params__ = ["e1","e2"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:2,op:op,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EBinop",$_.__params__ = ["op","e1","e2"],$_)
	,EField: ($_=function(e,field) { return {_hx_index:3,e:e,field:field,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EField",$_.__params__ = ["e","field"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:4,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EParenthesis",$_.__params__ = ["e"],$_)
	,EObjectDecl: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EObjectDecl",$_.__params__ = ["fields"],$_)
	,EArrayDecl: ($_=function(values) { return {_hx_index:6,values:values,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EArrayDecl",$_.__params__ = ["values"],$_)
	,ECall: ($_=function(e,params) { return {_hx_index:7,e:e,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ECall",$_.__params__ = ["e","params"],$_)
	,ENew: ($_=function(t,params) { return {_hx_index:8,t:t,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ENew",$_.__params__ = ["t","params"],$_)
	,EUnop: ($_=function(op,postFix,e) { return {_hx_index:9,op:op,postFix:postFix,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EUnop",$_.__params__ = ["op","postFix","e"],$_)
	,EVars: ($_=function(vars) { return {_hx_index:10,vars:vars,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EVars",$_.__params__ = ["vars"],$_)
	,EFunction: ($_=function(kind,f) { return {_hx_index:11,kind:kind,f:f,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EFunction",$_.__params__ = ["kind","f"],$_)
	,EBlock: ($_=function(exprs) { return {_hx_index:12,exprs:exprs,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EBlock",$_.__params__ = ["exprs"],$_)
	,EFor: ($_=function(it,expr) { return {_hx_index:13,it:it,expr:expr,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EFor",$_.__params__ = ["it","expr"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:14,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,EWhile: ($_=function(econd,e,normalWhile) { return {_hx_index:15,econd:econd,e:e,normalWhile:normalWhile,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EWhile",$_.__params__ = ["econd","e","normalWhile"],$_)
	,ESwitch: ($_=function(e,cases,edef) { return {_hx_index:16,e:e,cases:cases,edef:edef,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ESwitch",$_.__params__ = ["e","cases","edef"],$_)
	,ETry: ($_=function(e,catches) { return {_hx_index:17,e:e,catches:catches,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ETry",$_.__params__ = ["e","catches"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:18,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EReturn",$_.__params__ = ["e"],$_)
	,EBreak: {_hx_name:"EBreak",_hx_index:19,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EContinue: {_hx_name:"EContinue",_hx_index:20,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EUntyped: ($_=function(e) { return {_hx_index:21,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EUntyped",$_.__params__ = ["e"],$_)
	,EThrow: ($_=function(e) { return {_hx_index:22,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EThrow",$_.__params__ = ["e"],$_)
	,ECast: ($_=function(e,t) { return {_hx_index:23,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ECast",$_.__params__ = ["e","t"],$_)
	,EDisplay: ($_=function(e,displayKind) { return {_hx_index:24,e:e,displayKind:displayKind,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EDisplay",$_.__params__ = ["e","displayKind"],$_)
	,EDisplayNew: ($_=function(t) { return {_hx_index:25,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EDisplayNew",$_.__params__ = ["t"],$_)
	,ETernary: ($_=function(econd,eif,eelse) { return {_hx_index:26,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ETernary",$_.__params__ = ["econd","eif","eelse"],$_)
	,ECheckType: ($_=function(e,t) { return {_hx_index:27,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ECheckType",$_.__params__ = ["e","t"],$_)
	,EMeta: ($_=function(s,e) { return {_hx_index:28,s:s,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EMeta",$_.__params__ = ["s","e"],$_)
	,EIs: ($_=function(e,t) { return {_hx_index:29,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EIs",$_.__params__ = ["e","t"],$_)
};
haxe_macro_ExprDef.__constructs__ = [haxe_macro_ExprDef.EConst,haxe_macro_ExprDef.EArray,haxe_macro_ExprDef.EBinop,haxe_macro_ExprDef.EField,haxe_macro_ExprDef.EParenthesis,haxe_macro_ExprDef.EObjectDecl,haxe_macro_ExprDef.EArrayDecl,haxe_macro_ExprDef.ECall,haxe_macro_ExprDef.ENew,haxe_macro_ExprDef.EUnop,haxe_macro_ExprDef.EVars,haxe_macro_ExprDef.EFunction,haxe_macro_ExprDef.EBlock,haxe_macro_ExprDef.EFor,haxe_macro_ExprDef.EIf,haxe_macro_ExprDef.EWhile,haxe_macro_ExprDef.ESwitch,haxe_macro_ExprDef.ETry,haxe_macro_ExprDef.EReturn,haxe_macro_ExprDef.EBreak,haxe_macro_ExprDef.EContinue,haxe_macro_ExprDef.EUntyped,haxe_macro_ExprDef.EThrow,haxe_macro_ExprDef.ECast,haxe_macro_ExprDef.EDisplay,haxe_macro_ExprDef.EDisplayNew,haxe_macro_ExprDef.ETernary,haxe_macro_ExprDef.ECheckType,haxe_macro_ExprDef.EMeta,haxe_macro_ExprDef.EIs];
var haxe_macro_DisplayKind = $hxEnums["haxe.macro.DisplayKind"] = { __ename__:true,__constructs__:null
	,DKCall: {_hx_name:"DKCall",_hx_index:0,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKDot: {_hx_name:"DKDot",_hx_index:1,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKStructure: {_hx_name:"DKStructure",_hx_index:2,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKMarked: {_hx_name:"DKMarked",_hx_index:3,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKPattern: ($_=function(outermost) { return {_hx_index:4,outermost:outermost,__enum__:"haxe.macro.DisplayKind",toString:$estr}; },$_._hx_name="DKPattern",$_.__params__ = ["outermost"],$_)
};
haxe_macro_DisplayKind.__constructs__ = [haxe_macro_DisplayKind.DKCall,haxe_macro_DisplayKind.DKDot,haxe_macro_DisplayKind.DKStructure,haxe_macro_DisplayKind.DKMarked,haxe_macro_DisplayKind.DKPattern];
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__:true,__constructs__:null
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TPath",$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TFunction",$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TAnonymous",$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TParent",$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TExtend",$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TOptional",$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TNamed",$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TIntersection",$_.__params__ = ["tl"],$_)
};
haxe_macro_ComplexType.__constructs__ = [haxe_macro_ComplexType.TPath,haxe_macro_ComplexType.TFunction,haxe_macro_ComplexType.TAnonymous,haxe_macro_ComplexType.TParent,haxe_macro_ComplexType.TExtend,haxe_macro_ComplexType.TOptional,haxe_macro_ComplexType.TNamed,haxe_macro_ComplexType.TIntersection];
var haxe_zip_Compress = function() { };
haxe_zip_Compress.__name__ = true;
haxe_zip_Compress.run = function(s,level) {
	throw new haxe_exceptions_NotImplementedException("Not implemented for this platform",null,{ fileName : "haxe/zip/Compress.hx", lineNumber : 39, className : "haxe.zip.Compress", methodName : "run"});
};
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__:true,__constructs__:null
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBit",$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBits",$_.__params__ = ["n","table"],$_)
};
haxe_zip_Huffman.__constructs__ = [haxe_zip_Huffman.Found,haxe_zip_Huffman.NeedBit,haxe_zip_Huffman.NeedBits];
var haxe_zip_HuffTools = function() {
};
haxe_zip_HuffTools.__name__ = true;
haxe_zip_HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var a = t.left;
			var b = t.right;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g = t.n;
			var _g = t.table;
			throw haxe_Exception.thrown("assert");
		}
	}
	,treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var a = t.left;
				var b = t.right;
				return haxe_zip_Huffman.NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	,treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var a = t.left;
			var b = t.right;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	,treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	,make: function(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0));
		}
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var p = lengths[i + pos];
			if(p >= maxbits) {
				throw haxe_Exception.thrown("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g = 1;
		var _g1 = maxbits - 1;
		while(_g < _g1) {
			var i = _g++;
			code = code + counts[i] << 1;
			tmp[i] = code;
		}
		var bits = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var l = lengths[i + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
	,__class__: haxe_zip_HuffTools
};
var haxe_zip__$InflateImpl_Window = function(hasCrc) {
	this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
	this.pos = 0;
	if(hasCrc) {
		this.crc = new haxe_crypto_Adler32();
	}
};
haxe_zip__$InflateImpl_Window.__name__ = true;
haxe_zip__$InflateImpl_Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	,addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	,addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	,getLastChar: function() {
		return this.buffer.b[this.pos - 1];
	}
	,available: function() {
		return this.pos;
	}
	,checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
	,__class__: haxe_zip__$InflateImpl_Window
};
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__:true,__constructs__:null
	,Head: {_hx_name:"Head",_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_name:"Block",_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_name:"CData",_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_name:"Flat",_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_name:"Crc",_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_name:"Dist",_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_name:"DistOne",_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_name:"Done",_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
haxe_zip__$InflateImpl_State.__constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
var haxe_zip_InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new haxe_zip_HuffTools();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new haxe_zip__$InflateImpl_Window(crc);
};
haxe_zip_InflateImpl.__name__ = true;
haxe_zip_InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
	var output = new haxe_io_BytesBuffer();
	var inflate = new haxe_zip_InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
};
haxe_zip_InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	,readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	,getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	,getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	,getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	,resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	}
	,addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	,addByte: function(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	,addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	}
	,addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	,applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var a = h.left;
			var b = h.right;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var n = h.n;
			var tbl = h.table;
			return this.applyHuffman(tbl[this.getBits(n)]);
		}
	}
	,inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
		}
	}
	,inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw haxe_Exception.thrown("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw haxe_Exception.thrown("Invalid data");
			}
			if(fdict) {
				throw haxe_Exception.thrown("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g = hclen;
				var _g1 = 19;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g = 0;
				var _g1 = hlit + hdist;
				while(_g < _g1) {
					var i = _g++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			var crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw haxe_Exception.thrown("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen);
				this.len -= rlen;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			var rlen = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen);
			this.len -= rlen;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
	,__class__: haxe_zip_InflateImpl
};
var haxe_zip_Uncompress = function() { };
haxe_zip_Uncompress.__name__ = true;
haxe_zip_Uncompress.run = function(src,bufsize) {
	return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
};
var hxargs_Args = function() { };
hxargs_Args.__name__ = true;
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var lexer_Helper = function() { };
lexer_Helper.__name__ = true;
lexer_Helper.isLinebreak = function(s) {
	return new EReg("\r\n|\r|\n","").match(s);
};
lexer_Helper.isAscii = function(s) {
	return new EReg("^[a-zA-Z0-9_\\$]+$","").match(s);
};
lexer_Helper.isNumber = function(s) {
	return new EReg("^[0-9]+$","").match(s);
};
var lexer_TokenType = $hxEnums["lexer.TokenType"] = { __ename__:true,__constructs__:null
	,Illegal: {_hx_name:"Illegal",_hx_index:0,__enum__:"lexer.TokenType",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:1,__enum__:"lexer.TokenType",toString:$estr}
	,Ident: {_hx_name:"Ident",_hx_index:2,__enum__:"lexer.TokenType",toString:$estr}
	,Number: {_hx_name:"Number",_hx_index:3,__enum__:"lexer.TokenType",toString:$estr}
	,String: {_hx_name:"String",_hx_index:4,__enum__:"lexer.TokenType",toString:$estr}
	,Assign: {_hx_name:"Assign",_hx_index:5,__enum__:"lexer.TokenType",toString:$estr}
	,PlusAssign: {_hx_name:"PlusAssign",_hx_index:6,__enum__:"lexer.TokenType",toString:$estr}
	,MinusAssign: {_hx_name:"MinusAssign",_hx_index:7,__enum__:"lexer.TokenType",toString:$estr}
	,AsteriskAssign: {_hx_name:"AsteriskAssign",_hx_index:8,__enum__:"lexer.TokenType",toString:$estr}
	,SlashAssign: {_hx_name:"SlashAssign",_hx_index:9,__enum__:"lexer.TokenType",toString:$estr}
	,PercentAssign: {_hx_name:"PercentAssign",_hx_index:10,__enum__:"lexer.TokenType",toString:$estr}
	,BitAndAssign: {_hx_name:"BitAndAssign",_hx_index:11,__enum__:"lexer.TokenType",toString:$estr}
	,BitOrAssign: {_hx_name:"BitOrAssign",_hx_index:12,__enum__:"lexer.TokenType",toString:$estr}
	,BitShiftLeftAssign: {_hx_name:"BitShiftLeftAssign",_hx_index:13,__enum__:"lexer.TokenType",toString:$estr}
	,BitShiftRightAssign: {_hx_name:"BitShiftRightAssign",_hx_index:14,__enum__:"lexer.TokenType",toString:$estr}
	,BitXorAssign: {_hx_name:"BitXorAssign",_hx_index:15,__enum__:"lexer.TokenType",toString:$estr}
	,Plus: {_hx_name:"Plus",_hx_index:16,__enum__:"lexer.TokenType",toString:$estr}
	,Minus: {_hx_name:"Minus",_hx_index:17,__enum__:"lexer.TokenType",toString:$estr}
	,Asterisk: {_hx_name:"Asterisk",_hx_index:18,__enum__:"lexer.TokenType",toString:$estr}
	,Slash: {_hx_name:"Slash",_hx_index:19,__enum__:"lexer.TokenType",toString:$estr}
	,Percent: {_hx_name:"Percent",_hx_index:20,__enum__:"lexer.TokenType",toString:$estr}
	,Pow: {_hx_name:"Pow",_hx_index:21,__enum__:"lexer.TokenType",toString:$estr}
	,Bang: {_hx_name:"Bang",_hx_index:22,__enum__:"lexer.TokenType",toString:$estr}
	,Equals: {_hx_name:"Equals",_hx_index:23,__enum__:"lexer.TokenType",toString:$estr}
	,NotEquals: {_hx_name:"NotEquals",_hx_index:24,__enum__:"lexer.TokenType",toString:$estr}
	,And: {_hx_name:"And",_hx_index:25,__enum__:"lexer.TokenType",toString:$estr}
	,Or: {_hx_name:"Or",_hx_index:26,__enum__:"lexer.TokenType",toString:$estr}
	,GreaterThan: {_hx_name:"GreaterThan",_hx_index:27,__enum__:"lexer.TokenType",toString:$estr}
	,LessThan: {_hx_name:"LessThan",_hx_index:28,__enum__:"lexer.TokenType",toString:$estr}
	,GreaterThanOrEqual: {_hx_name:"GreaterThanOrEqual",_hx_index:29,__enum__:"lexer.TokenType",toString:$estr}
	,LessThanOrEqual: {_hx_name:"LessThanOrEqual",_hx_index:30,__enum__:"lexer.TokenType",toString:$estr}
	,BitAnd: {_hx_name:"BitAnd",_hx_index:31,__enum__:"lexer.TokenType",toString:$estr}
	,BitOr: {_hx_name:"BitOr",_hx_index:32,__enum__:"lexer.TokenType",toString:$estr}
	,BitShiftLeft: {_hx_name:"BitShiftLeft",_hx_index:33,__enum__:"lexer.TokenType",toString:$estr}
	,BitShiftRight: {_hx_name:"BitShiftRight",_hx_index:34,__enum__:"lexer.TokenType",toString:$estr}
	,BitXor: {_hx_name:"BitXor",_hx_index:35,__enum__:"lexer.TokenType",toString:$estr}
	,BitNot: {_hx_name:"BitNot",_hx_index:36,__enum__:"lexer.TokenType",toString:$estr}
	,ConcatString: {_hx_name:"ConcatString",_hx_index:37,__enum__:"lexer.TokenType",toString:$estr}
	,Regex: {_hx_name:"Regex",_hx_index:38,__enum__:"lexer.TokenType",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:39,__enum__:"lexer.TokenType",toString:$estr}
	,Semicolon: {_hx_name:"Semicolon",_hx_index:40,__enum__:"lexer.TokenType",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:41,__enum__:"lexer.TokenType",toString:$estr}
	,Colon: {_hx_name:"Colon",_hx_index:42,__enum__:"lexer.TokenType",toString:$estr}
	,LParen: {_hx_name:"LParen",_hx_index:43,__enum__:"lexer.TokenType",toString:$estr}
	,RParen: {_hx_name:"RParen",_hx_index:44,__enum__:"lexer.TokenType",toString:$estr}
	,LBrace: {_hx_name:"LBrace",_hx_index:45,__enum__:"lexer.TokenType",toString:$estr}
	,RBrace: {_hx_name:"RBrace",_hx_index:46,__enum__:"lexer.TokenType",toString:$estr}
	,LBracket: {_hx_name:"LBracket",_hx_index:47,__enum__:"lexer.TokenType",toString:$estr}
	,RBracket: {_hx_name:"RBracket",_hx_index:48,__enum__:"lexer.TokenType",toString:$estr}
	,ExclusiveRange: {_hx_name:"ExclusiveRange",_hx_index:49,__enum__:"lexer.TokenType",toString:$estr}
	,InclusiveRange: {_hx_name:"InclusiveRange",_hx_index:50,__enum__:"lexer.TokenType",toString:$estr}
	,Arrow: {_hx_name:"Arrow",_hx_index:51,__enum__:"lexer.TokenType",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:52,__enum__:"lexer.TokenType",toString:$estr}
	,Let: {_hx_name:"Let",_hx_index:53,__enum__:"lexer.TokenType",toString:$estr}
	,Mut: {_hx_name:"Mut",_hx_index:54,__enum__:"lexer.TokenType",toString:$estr}
	,True: {_hx_name:"True",_hx_index:55,__enum__:"lexer.TokenType",toString:$estr}
	,False: {_hx_name:"False",_hx_index:56,__enum__:"lexer.TokenType",toString:$estr}
	,If: {_hx_name:"If",_hx_index:57,__enum__:"lexer.TokenType",toString:$estr}
	,Else: {_hx_name:"Else",_hx_index:58,__enum__:"lexer.TokenType",toString:$estr}
	,While: {_hx_name:"While",_hx_index:59,__enum__:"lexer.TokenType",toString:$estr}
	,Return: {_hx_name:"Return",_hx_index:60,__enum__:"lexer.TokenType",toString:$estr}
	,Import: {_hx_name:"Import",_hx_index:61,__enum__:"lexer.TokenType",toString:$estr}
	,Break: {_hx_name:"Break",_hx_index:62,__enum__:"lexer.TokenType",toString:$estr}
	,Continue: {_hx_name:"Continue",_hx_index:63,__enum__:"lexer.TokenType",toString:$estr}
	,Null: {_hx_name:"Null",_hx_index:64,__enum__:"lexer.TokenType",toString:$estr}
	,For: {_hx_name:"For",_hx_index:65,__enum__:"lexer.TokenType",toString:$estr}
	,In: {_hx_name:"In",_hx_index:66,__enum__:"lexer.TokenType",toString:$estr}
	,When: {_hx_name:"When",_hx_index:67,__enum__:"lexer.TokenType",toString:$estr}
};
lexer_TokenType.__constructs__ = [lexer_TokenType.Illegal,lexer_TokenType.Eof,lexer_TokenType.Ident,lexer_TokenType.Number,lexer_TokenType.String,lexer_TokenType.Assign,lexer_TokenType.PlusAssign,lexer_TokenType.MinusAssign,lexer_TokenType.AsteriskAssign,lexer_TokenType.SlashAssign,lexer_TokenType.PercentAssign,lexer_TokenType.BitAndAssign,lexer_TokenType.BitOrAssign,lexer_TokenType.BitShiftLeftAssign,lexer_TokenType.BitShiftRightAssign,lexer_TokenType.BitXorAssign,lexer_TokenType.Plus,lexer_TokenType.Minus,lexer_TokenType.Asterisk,lexer_TokenType.Slash,lexer_TokenType.Percent,lexer_TokenType.Pow,lexer_TokenType.Bang,lexer_TokenType.Equals,lexer_TokenType.NotEquals,lexer_TokenType.And,lexer_TokenType.Or,lexer_TokenType.GreaterThan,lexer_TokenType.LessThan,lexer_TokenType.GreaterThanOrEqual,lexer_TokenType.LessThanOrEqual,lexer_TokenType.BitAnd,lexer_TokenType.BitOr,lexer_TokenType.BitShiftLeft,lexer_TokenType.BitShiftRight,lexer_TokenType.BitXor,lexer_TokenType.BitNot,lexer_TokenType.ConcatString,lexer_TokenType.Regex,lexer_TokenType.Comma,lexer_TokenType.Semicolon,lexer_TokenType.Dot,lexer_TokenType.Colon,lexer_TokenType.LParen,lexer_TokenType.RParen,lexer_TokenType.LBrace,lexer_TokenType.RBrace,lexer_TokenType.LBracket,lexer_TokenType.RBracket,lexer_TokenType.ExclusiveRange,lexer_TokenType.InclusiveRange,lexer_TokenType.Arrow,lexer_TokenType.Function,lexer_TokenType.Let,lexer_TokenType.Mut,lexer_TokenType.True,lexer_TokenType.False,lexer_TokenType.If,lexer_TokenType.Else,lexer_TokenType.While,lexer_TokenType.Return,lexer_TokenType.Import,lexer_TokenType.Break,lexer_TokenType.Continue,lexer_TokenType.Null,lexer_TokenType.For,lexer_TokenType.In,lexer_TokenType.When];
var lexer_Keyword = function() { };
lexer_Keyword.__name__ = true;
lexer_Keyword.isKeyword = function(ident) {
	return lexer_Keyword.keywords.h[ident] != null;
};
lexer_Keyword.getKeyword = function(ident) {
	return lexer_Keyword.keywords.h[ident];
};
var lexer_Lexer = function(filename,code) {
	this.lineOffset = -1;
	this.line = 1;
	this.inString = false;
	this.position = 0;
	this.currentChar = " ";
	this.filename = haxe_io_Path.normalize(filename);
	this.code = code;
};
lexer_Lexer.__name__ = true;
lexer_Lexer.prototype = {
	updateLinePosition: function() {
		if(new EReg("\r\n|\n","").match(this.currentChar)) {
			this.line++;
			this.lineOffset = -1;
		} else {
			this.lineOffset++;
		}
	}
	,readChar: function() {
		this.currentChar = this.position >= this.code.length ? "\x00" : this.code.charAt(this.position);
		this.updateLinePosition();
		this.position++;
		this.eatComment();
	}
	,peekChar: function() {
		if(this.position >= this.code.length) {
			return "\x00";
		} else {
			return this.code.charAt(this.position);
		}
	}
	,peekCharN: function(n) {
		var lastPosition = this.position;
		var lastChar = this.currentChar;
		var lastLine = this.line;
		var lastLineOffset = this.lineOffset;
		var chars = [];
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var _ = _g++;
			this.readChar();
			chars.push(this.currentChar);
		}
		this.position = lastPosition;
		this.currentChar = lastChar;
		this.line = lastLine;
		this.lineOffset = lastLineOffset;
		return chars;
	}
	,readIdent: function() {
		var startPosition = this.position;
		while(true) {
			var s = this.peekChar();
			if(!(new EReg("^[a-zA-Z0-9_\\$]+$","").match(s) || this.peekChar() == "_")) {
				break;
			}
			this.readChar();
		}
		return this.code.substring(startPosition - 1,this.position);
	}
	,escapeChar: function() {
		this.readChar();
		switch(this.currentChar) {
		case "\"":
			return "\"";
		case "/":
			return "/";
		case "\\":
			return "\\";
		case "b":
			return "\x08";
		case "f":
			return "\x0C";
		case "n":
			return "\n";
		case "r":
			return "\r";
		case "t":
			return "\t";
		default:
			return "";
		}
	}
	,readString: function() {
		this.inString = true;
		this.readChar();
		var string_b = "";
		while(this.currentChar != "\"" && this.currentChar != "\x00") {
			if(this.currentChar == "\\") {
				string_b += Std.string(this.escapeChar());
			} else {
				string_b += Std.string(this.currentChar);
			}
			this.readChar();
		}
		this.inString = false;
		return string_b;
	}
	,readRegex: function() {
		this.inString = true;
		this.readChar();
		this.readChar();
		var regex_b = "";
		while(this.currentChar != "/" && this.currentChar != "\x00") {
			if(this.currentChar == "\\") {
				this.readChar();
			}
			regex_b += Std.string(this.currentChar);
			this.readChar();
		}
		this.inString = false;
		return regex_b;
	}
	,readNumber: function() {
		var startPosition = this.position;
		var peek = this.peekCharN(2);
		while(new EReg("^[0-9]+$","").match(peek[0]) || peek[0] == "." && peek[1] != ".") {
			this.readChar();
			peek = this.peekCharN(2);
		}
		return this.code.substring(startPosition - 1,this.position);
	}
	,eatWhitespace: function() {
		while(true) {
			var tmp;
			if(this.currentChar != " ") {
				var s = this.currentChar;
				tmp = new EReg("\r\n|\r|\n","").match(s);
			} else {
				tmp = true;
			}
			if(!(tmp || this.currentChar == "\t")) {
				break;
			}
			this.readChar();
		}
	}
	,eatComment: function() {
		if(!this.inString && this.currentChar == "/" && this.peekChar() == "/") {
			while(true) {
				var s = this.currentChar;
				if(!(!new EReg("\r\n|\r|\n","").match(s) && this.currentChar != "\x00")) {
					break;
				}
				this.readChar();
			}
		}
	}
	,tokenize: function() {
		while(this.currentChar != "\x00") {
			var token = this.readToken();
			console.log("src/lexer/Lexer.hx:161:","" + Std.string(token.position) + " " + Std.string(token.type) + " " + token.literal);
		}
	}
	,peekToken: function() {
		var lastPosition = this.position;
		var lastChar = this.currentChar;
		var lastLine = this.line;
		var lastLineOffset = this.lineOffset;
		var token = this.readToken();
		this.position = lastPosition;
		this.currentChar = lastChar;
		this.line = lastLine;
		this.lineOffset = lastLineOffset;
		return token;
	}
	,peekTokenN: function(n) {
		var lastPosition = this.position;
		var lastChar = this.currentChar;
		var lastLine = this.line;
		var lastLineOffset = this.lineOffset;
		var tokens = [];
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var _ = _g++;
			tokens.push(this.readToken());
		}
		this.position = lastPosition;
		this.currentChar = lastChar;
		this.line = lastLine;
		this.lineOffset = lastLineOffset;
		return tokens;
	}
	,readToken: function() {
		this.readChar();
		this.eatWhitespace();
		var tokenPosition = new lexer_Position(this.position - 1,this.line,this.lineOffset);
		switch(this.currentChar) {
		case "\x00":
			return new lexer_Token(lexer_TokenType.Eof,tokenPosition,this.currentChar);
		case "!":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.NotEquals,tokenPosition,"!=");
			} else {
				return new lexer_Token(lexer_TokenType.Bang,tokenPosition,"!");
			}
			break;
		case "\"":
			var string = this.readString();
			return new lexer_Token(lexer_TokenType.String,tokenPosition,string);
		case "%":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.PercentAssign,tokenPosition,"%=");
			} else {
				return new lexer_Token(lexer_TokenType.Percent,tokenPosition,"%");
			}
			break;
		case "&":
			switch(this.peekChar()) {
			case "&":
				this.readChar();
				return new lexer_Token(lexer_TokenType.And,tokenPosition,"&&");
			case "=":
				this.readChar();
				return new lexer_Token(lexer_TokenType.BitAndAssign,tokenPosition,"&=");
			default:
				return new lexer_Token(lexer_TokenType.BitAnd,tokenPosition,"&");
			}
			break;
		case "(":
			return new lexer_Token(lexer_TokenType.LParen,tokenPosition,"(");
		case ")":
			return new lexer_Token(lexer_TokenType.RParen,tokenPosition,")");
		case "*":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.AsteriskAssign,tokenPosition,"*=");
			} else {
				return new lexer_Token(lexer_TokenType.Asterisk,tokenPosition,"*");
			}
			break;
		case "+":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.PlusAssign,tokenPosition,"+=");
			} else {
				return new lexer_Token(lexer_TokenType.Plus,tokenPosition,"+");
			}
			break;
		case ",":
			return new lexer_Token(lexer_TokenType.Comma,tokenPosition,",");
		case "-":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.MinusAssign,tokenPosition,"-=");
			} else {
				return new lexer_Token(lexer_TokenType.Minus,tokenPosition,"-");
			}
			break;
		case ".":
			var _g = this.peekCharN(2);
			if(_g.length == 2) {
				if(_g[0] == ".") {
					if(_g[1] == ".") {
						this.readChar();
						this.readChar();
						return new lexer_Token(lexer_TokenType.ExclusiveRange,tokenPosition,"...");
					} else {
						this.readChar();
						return new lexer_Token(lexer_TokenType.InclusiveRange,tokenPosition,"..");
					}
				} else {
					return new lexer_Token(lexer_TokenType.Dot,tokenPosition,".");
				}
			} else {
				return new lexer_Token(lexer_TokenType.Dot,tokenPosition,".");
			}
			break;
		case "/":
			new lexer_Token(lexer_TokenType.Slash,tokenPosition,"/");
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.SlashAssign,tokenPosition,"/=");
			} else {
				return new lexer_Token(lexer_TokenType.Slash,tokenPosition,"/");
			}
			break;
		case ":":
			return new lexer_Token(lexer_TokenType.Colon,tokenPosition,":");
		case ";":
			return new lexer_Token(lexer_TokenType.Semicolon,tokenPosition,";");
		case "<":
			switch(this.peekChar()) {
			case "<":
				this.readChar();
				if(this.peekChar() == "=") {
					this.readChar();
					return new lexer_Token(lexer_TokenType.BitShiftLeftAssign,tokenPosition,"<<=");
				} else {
					return new lexer_Token(lexer_TokenType.BitShiftLeft,tokenPosition,"<<");
				}
				break;
			case "=":
				this.readChar();
				return new lexer_Token(lexer_TokenType.LessThanOrEqual,tokenPosition,"<=");
			default:
				return new lexer_Token(lexer_TokenType.LessThan,tokenPosition,"<");
			}
			break;
		case "=":
			switch(this.peekChar()) {
			case "=":
				this.readChar();
				return new lexer_Token(lexer_TokenType.Equals,tokenPosition,"==");
			case ">":
				this.readChar();
				return new lexer_Token(lexer_TokenType.Arrow,tokenPosition,"=>");
			default:
				return new lexer_Token(lexer_TokenType.Assign,tokenPosition,"=");
			}
			break;
		case ">":
			switch(this.peekChar()) {
			case "<":
				this.readChar();
				return new lexer_Token(lexer_TokenType.ConcatString,tokenPosition,"><");
			case "=":
				this.readChar();
				return new lexer_Token(lexer_TokenType.GreaterThanOrEqual,tokenPosition,">=");
			case ">":
				this.readChar();
				if(this.peekChar() == "=") {
					this.readChar();
					return new lexer_Token(lexer_TokenType.BitShiftRightAssign,tokenPosition,">>=");
				} else {
					return new lexer_Token(lexer_TokenType.BitShiftRight,tokenPosition,">>");
				}
				break;
			default:
				return new lexer_Token(lexer_TokenType.GreaterThan,tokenPosition,">");
			}
			break;
		case "[":
			return new lexer_Token(lexer_TokenType.LBracket,tokenPosition,"[");
		case "]":
			return new lexer_Token(lexer_TokenType.RBracket,tokenPosition,"]");
		case "^":
			if(this.peekChar() == "=") {
				this.readChar();
				return new lexer_Token(lexer_TokenType.BitXorAssign,tokenPosition,"^=");
			} else {
				return new lexer_Token(lexer_TokenType.BitXor,tokenPosition,"^");
			}
			break;
		case "{":
			return new lexer_Token(lexer_TokenType.LBrace,tokenPosition,"{");
		case "|":
			switch(this.peekChar()) {
			case "=":
				this.readChar();
				return new lexer_Token(lexer_TokenType.BitOrAssign,tokenPosition,"|=");
			case "|":
				this.readChar();
				return new lexer_Token(lexer_TokenType.Or,tokenPosition,"||");
			default:
				return new lexer_Token(lexer_TokenType.BitOr,tokenPosition,"|");
			}
			break;
		case "}":
			return new lexer_Token(lexer_TokenType.RBrace,tokenPosition,"}");
		case "~":
			if(this.peekChar() == "/") {
				var regex = this.readRegex();
				return new lexer_Token(lexer_TokenType.Regex,tokenPosition,regex);
			} else {
				return new lexer_Token(lexer_TokenType.BitNot,tokenPosition,"~");
			}
			break;
		default:
			var s = this.currentChar;
			if(new EReg("^[0-9]+$","").match(s)) {
				var number = this.readNumber();
				return new lexer_Token(lexer_TokenType.Number,tokenPosition,number);
			}
			var s = this.currentChar;
			if(new EReg("^[a-zA-Z0-9_\\$]+$","").match(s)) {
				var ident = this.readIdent();
				if(lexer_Keyword.isKeyword(ident)) {
					return new lexer_Token(lexer_Keyword.getKeyword(ident),tokenPosition,ident);
				} else {
					return new lexer_Token(lexer_TokenType.Ident,tokenPosition,ident);
				}
			}
			return new lexer_Token(lexer_TokenType.Illegal,tokenPosition,this.currentChar);
		}
	}
	,__class__: lexer_Lexer
};
var lexer_Position = function(position,line,lineOffset) {
	this.position = position;
	this.line = line;
	this.lineOffset = lineOffset;
};
lexer_Position.__name__ = true;
lexer_Position.prototype = {
	toString: function() {
		return "(" + this.position + ", " + this.line + ", " + this.lineOffset + ")";
	}
	,__class__: lexer_Position
};
var lexer_Token = function(type,position,literal) {
	this.type = type;
	this.position = position;
	this.literal = literal;
};
lexer_Token.__name__ = true;
lexer_Token.prototype = {
	__class__: lexer_Token
};
var std_lib_MemberObject = function(vm) {
	this.members = new haxe_ds_StringMap();
	this.vm = vm;
};
std_lib_MemberObject.__name__ = true;
std_lib_MemberObject.prototype = {
	getMembers: function() {
		return new object_HashObj(this.members,this.vm);
	}
	,addFunctionMember: function(memberName,parameters,memberFunction) {
		var _this = this.members;
		var value = new object_ClosureObj(new object_BuiltInFunctionObj(memberFunction,parameters,this.vm),this.vm.currentFrame,this.vm);
		_this.h[memberName] = value;
	}
	,callFunctionMember: function(name,parameters) {
		var func = js_Boot.__cast(this.members.h[name] , object_ClosureObj);
		return this.vm.callFunction(func,parameters);
	}
	,addObjectMember: function(name,object) {
		this.members.h[name] = object;
	}
	,error: function(message) {
		this.vm.error.error(message);
	}
	,__class__: std_lib_MemberObject
};
var object__$ArrayObj_ArrayIterator = function(vm,value) {
	std_lib_MemberObject.call(this,vm);
	var index = -1;
	this.addFunctionMember("next",[],function(p) {
		index += 1;
		return new object_ArrayObj([value[index],new object_NumberObj(index,vm)],vm);
	});
	this.addFunctionMember("hasNext",[],function(p) {
		return new object_BooleanObj(index < value.length - 1,vm);
	});
};
object__$ArrayObj_ArrayIterator.__name__ = true;
object__$ArrayObj_ArrayIterator.__super__ = std_lib_MemberObject;
object__$ArrayObj_ArrayIterator.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: object__$ArrayObj_ArrayIterator
});
var object_Object = function(type,vm) {
	std_lib_MemberObject.call(this,vm);
	this.type = type;
};
object_Object.__name__ = true;
object_Object.__super__ = std_lib_MemberObject;
object_Object.prototype = $extend(std_lib_MemberObject.prototype,{
	toString: function() {
		return "#object";
	}
	,equals: function(o) {
		return false;
	}
	,clone: function() {
		return null;
	}
	,__class__: object_Object
});
var object_ArrayObj = function(value,vm) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Array,vm);
	this.value = value;
	if(vm == null) {
		return;
	}
	this.addFunctionMember("Iterator",[],function(p) {
		return new object__$ArrayObj_ArrayIterator(vm,value).getMembers();
	});
	this.addFunctionMember("length",[],function(p) {
		return new object_NumberObj(_gthis.value.length,vm);
	});
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.value.toString(),vm);
	});
	this.addFunctionMember("push",[null],function(p) {
		_gthis.value.push(p[0]);
		return new object_NumberObj(_gthis.value.length,vm);
	});
	this.addFunctionMember("pop",[],function(p) {
		return _gthis.value.pop();
	});
	this.addFunctionMember("unshift",[null],function(p) {
		var v = p[0];
		value.unshift(v);
		return new object_NumberObj(value.length,vm);
	});
	this.addFunctionMember("shift",[],function(p) {
		return value.shift();
	});
	this.addFunctionMember("concat",[object_ObjectType.Array],function(p) {
		var o = (js_Boot.__cast(p[0] , object_ArrayObj)).value;
		return new object_ArrayObj(value.concat(o),vm);
	});
	this.addFunctionMember("every",[object_ObjectType.Closure],function(p) {
		var callback = js_Boot.__cast(p[0] , object_ClosureObj);
		var allPassed = true;
		var _g = 0;
		while(_g < value.length) {
			var v = value[_g];
			++_g;
			var cbResult = vm.callFunction(callback,[v]);
			if(cbResult.type != object_ObjectType.Boolean) {
				_gthis.error("expected callback to return boolean");
			}
			var passed = (js_Boot.__cast(cbResult , object_BooleanObj)).value;
			if(!passed) {
				allPassed = false;
				break;
			}
		}
		return new object_BooleanObj(allPassed,vm);
	});
	this.addFunctionMember("fill",[null,object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var v = p[0];
		var startIndex = (js_Boot.__cast(p[1] , object_NumberObj)).value | 0;
		var endIndex = (js_Boot.__cast(p[2] , object_NumberObj)).value | 0;
		var _g = 0;
		var _g1 = endIndex;
		while(_g < _g1) {
			var i = _g++;
			if(i >= startIndex) {
				value[i] = v;
			} else if(value[i] == null) {
				value[i] = new object_NullObj(vm);
			}
		}
		return _gthis;
	});
	this.addFunctionMember("join",[object_ObjectType.String],function(p) {
		var seperator = (js_Boot.__cast(p[0] , object_StringObj)).value;
		return new object_StringObj(value.join(seperator),vm);
	});
	this.addFunctionMember("contains",[null],function(p) {
		var _g = 0;
		while(_g < value.length) {
			var v = value[_g];
			++_g;
			if(v.equals(p[0])) {
				return new object_BooleanObj(true,vm);
			}
		}
		return new object_BooleanObj(false,vm);
	});
	this.addFunctionMember("map",[object_ObjectType.Closure],function(p) {
		var callback = js_Boot.__cast(p[0] , object_ClosureObj);
		var newArray = [];
		var _g = 0;
		while(_g < value.length) {
			var v = value[_g];
			++_g;
			newArray.push(vm.callFunction(callback,[v]));
		}
		return new object_ArrayObj(newArray,vm);
	});
	this.addFunctionMember("filter",[object_ObjectType.Closure],function(p) {
		var callback = js_Boot.__cast(p[0] , object_ClosureObj);
		var newArray = [];
		var _g = 0;
		while(_g < value.length) {
			var v = value[_g];
			++_g;
			var cbResult = vm.callFunction(callback,[v]);
			if(cbResult.type != object_ObjectType.Boolean) {
				_gthis.error("expected callback to return boolean");
			}
			var include = (js_Boot.__cast(cbResult , object_BooleanObj)).value;
			if(include) {
				newArray.push(v);
			}
		}
		return new object_ArrayObj(newArray,vm);
	});
	this.addFunctionMember("forEach",[object_ObjectType.Closure],function(p) {
		var callback = js_Boot.__cast(p[0] , object_ClosureObj);
		var _g = 0;
		while(_g < value.length) {
			var v = value[_g];
			++_g;
			vm.callFunction(callback,[v]);
		}
		return new object_ArrayObj(value,vm);
	});
	this.addFunctionMember("sort",[object_ObjectType.Closure],function(p) {
		var callback = js_Boot.__cast(p[0] , object_ClosureObj);
		value.sort(function(v1,v2) {
			var cbResult = vm.callFunction(callback,[v1,v2]);
			if(cbResult.type != object_ObjectType.Number) {
				_gthis.error("expected callback to return number");
			}
			var pos = (js_Boot.__cast(cbResult , object_NumberObj)).value | 0;
			return pos;
		});
		return new object_NullObj(vm);
	});
	this.addFunctionMember("clone",[],function(p) {
		return _gthis.clone();
	});
};
object_ArrayObj.__name__ = true;
object_ArrayObj.__super__ = object_Object;
object_ArrayObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		var buffer_b = "";
		buffer_b += "[";
		var iterator_current = 0;
		var iterator_array = this.value;
		while(iterator_current < iterator_array.length) {
			var v = iterator_array[iterator_current++];
			buffer_b += Std.string(v.toString());
			if(iterator_current < iterator_array.length) {
				buffer_b += ", ";
			}
		}
		buffer_b += "]";
		return buffer_b;
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.Array) {
			return false;
		}
		var other = js_Boot.__cast(o , object_ArrayObj);
		if(other.value.length != this.value.length) {
			return false;
		}
		var _g_current = 0;
		var _g_array = this.value;
		while(_g_current < _g_array.length) {
			var _g1_value = _g_array[_g_current];
			var _g1_key = _g_current++;
			var i = _g1_key;
			var v = _g1_value;
			if(!other.value[i].equals(v)) {
				return false;
			}
		}
		return true;
	}
	,clone: function() {
		var clone = new object_ArrayObj([],this.vm);
		var _g_current = 0;
		var _g_array = this.value;
		while(_g_current < _g_array.length) {
			var _g1_value = _g_array[_g_current];
			var _g1_key = _g_current++;
			var i = _g1_key;
			var v = _g1_value;
			clone.value[i] = v.clone();
		}
		return clone;
	}
	,__class__: object_ArrayObj
});
var object_BooleanObj = function(value,vm) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Boolean,vm);
	this.value = value;
	if(vm == null) {
		return;
	}
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.toString(),vm);
	});
};
object_BooleanObj.__name__ = true;
object_BooleanObj.__super__ = object_Object;
object_BooleanObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		if(this.value) {
			return "true";
		} else {
			return "false";
		}
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.Boolean) {
			return false;
		}
		return (js_Boot.__cast(o , object_BooleanObj)).value == this.value;
	}
	,clone: function() {
		return new object_BooleanObj(this.value,this.vm);
	}
	,__class__: object_BooleanObj
});
var object_Function = function(type,parametersCount,vm) {
	object_Object.call(this,type,vm);
	this.parametersCount = parametersCount;
};
object_Function.__name__ = true;
object_Function.__super__ = object_Object;
object_Function.prototype = $extend(object_Object.prototype,{
	__class__: object_Function
});
var object_BuiltInFunctionObj = function(func,parameters,vm) {
	object_Function.call(this,object_ObjectType.BuiltInFunction,parameters.length,vm);
	this.func = func;
	this.parameters = parameters;
};
object_BuiltInFunctionObj.__name__ = true;
object_BuiltInFunctionObj.__super__ = object_Function;
object_BuiltInFunctionObj.prototype = $extend(object_Function.prototype,{
	toString: function() {
		return "#func(BuiltIn)";
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.BuiltInFunction) {
			return false;
		}
		return (js_Boot.__cast(o , object_BuiltInFunctionObj)).func == this.func;
	}
	,__class__: object_BuiltInFunctionObj
});
var object_ClosureObj = function(func,context,vm) {
	object_Object.call(this,object_ObjectType.Closure,vm);
	this.func = func;
	this.context = context;
};
object_ClosureObj.__name__ = true;
object_ClosureObj.__super__ = object_Object;
object_ClosureObj.prototype = $extend(object_Object.prototype,{
	getMembers: function() {
		return this.func.getMembers();
	}
	,toString: function() {
		return "#closure(" + this.func.toString() + ")";
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.Closure) {
			return false;
		}
		return (js_Boot.__cast(o , object_ClosureObj)).func == this.func;
	}
	,clone: function() {
		return new object_ClosureObj(this.func,this.context,this.vm);
	}
	,__class__: object_ClosureObj
});
var object__$HashObj_HashIterator = function(vm,value) {
	std_lib_MemberObject.call(this,vm);
	var iterator_map;
	var iterator_keys;
	var map = value;
	iterator_map = map;
	iterator_keys = map.keys();
	this.addFunctionMember("next",[],function(p) {
		var key = iterator_keys.next();
		var next_value = iterator_map.get(key);
		var next_key = key;
		return new object_ArrayObj([next_value,new object_StringObj(next_key,vm)],vm);
	});
	this.addFunctionMember("hasNext",[],function(p) {
		return new object_BooleanObj(iterator_keys.hasNext(),vm);
	});
};
object__$HashObj_HashIterator.__name__ = true;
object__$HashObj_HashIterator.__super__ = std_lib_MemberObject;
object__$HashObj_HashIterator.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: object__$HashObj_HashIterator
});
var object_HashObj = function(value,vm) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Hash,vm);
	this.value = value;
	if(vm == null) {
		return;
	}
	this.addFunctionMember("Iterator",[],function(p) {
		return new object__$HashObj_HashIterator(vm,value).getMembers();
	});
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.toString(),vm);
	});
	this.addFunctionMember("length",[],function(p) {
		return new object_NumberObj(Lambda.count(_gthis.value),vm);
	});
	this.addFunctionMember("clone",[],function(p) {
		return _gthis.clone();
	});
};
object_HashObj.__name__ = true;
object_HashObj.__super__ = object_Object;
object_HashObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		var buffer_b = "";
		buffer_b += "{";
		var map = this.value;
		var iterator_map = map;
		var iterator_keys = map.keys();
		while(iterator_keys.hasNext()) {
			var key = iterator_keys.next();
			var _g1_value = iterator_map.get(key);
			var _g1_key = key;
			var k = _g1_key;
			var v = _g1_value;
			buffer_b += k == null ? "null" : "" + k;
			buffer_b += ": ";
			buffer_b += Std.string(v.toString());
			if(iterator_keys.hasNext()) {
				buffer_b += ", ";
			}
		}
		buffer_b += "}";
		return buffer_b;
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.Hash) {
			return false;
		}
		var other = js_Boot.__cast(o , object_HashObj);
		var h = this.value.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g1_key = key;
			var _g1_value = _g_h[key];
			var k = _g1_key;
			var v = _g1_value;
			var oValue = other.value.h[k];
			if(oValue == null || !oValue.equals(v)) {
				return false;
			}
		}
		var h = other.value.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g1_key = key;
			var _g1_value = _g_h[key];
			var k = _g1_key;
			var v = _g1_value;
			var oValue = this.value.h[k];
			if(oValue == null || !oValue.equals(v)) {
				return false;
			}
		}
		return true;
	}
	,clone: function() {
		var clone = new object_HashObj(new haxe_ds_StringMap(),this.vm);
		var h = this.value.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g1_key = key;
			var _g1_value = _g_h[key];
			var k = _g1_key;
			var v = _g1_value;
			var _this = clone.value;
			var value = v.clone();
			_this.h[k] = value;
		}
		return clone;
	}
	,__class__: object_HashObj
});
var object_NullObj = function(vm) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Null,vm);
	if(vm == null) {
		return;
	}
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.toString(),vm);
	});
};
object_NullObj.__name__ = true;
object_NullObj.__super__ = object_Object;
object_NullObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		return "null";
	}
	,equals: function(o) {
		return o.type == object_ObjectType.Null;
	}
	,clone: function() {
		return new object_NullObj(this.vm);
	}
	,__class__: object_NullObj
});
var object_NumberObj = function(value,vm) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.Number,vm);
	this.value = value;
	if(vm == null) {
		return;
	}
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.toString(),vm);
	});
};
object_NumberObj.__name__ = true;
object_NumberObj.__super__ = object_Object;
object_NumberObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		return Std.string(this.value);
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.Number) {
			return false;
		}
		return (js_Boot.__cast(o , object_NumberObj)).value == this.value;
	}
	,clone: function() {
		return new object_NumberObj(this.value,this.vm);
	}
	,__class__: object_NumberObj
});
var object_ObjectType = $hxEnums["object.ObjectType"] = { __ename__:true,__constructs__:null
	,Number: {_hx_name:"Number",_hx_index:0,__enum__:"object.ObjectType",toString:$estr}
	,Boolean: {_hx_name:"Boolean",_hx_index:1,__enum__:"object.ObjectType",toString:$estr}
	,String: {_hx_name:"String",_hx_index:2,__enum__:"object.ObjectType",toString:$estr}
	,Array: {_hx_name:"Array",_hx_index:3,__enum__:"object.ObjectType",toString:$estr}
	,Hash: {_hx_name:"Hash",_hx_index:4,__enum__:"object.ObjectType",toString:$estr}
	,BuiltInFunction: {_hx_name:"BuiltInFunction",_hx_index:5,__enum__:"object.ObjectType",toString:$estr}
	,UserFunction: {_hx_name:"UserFunction",_hx_index:6,__enum__:"object.ObjectType",toString:$estr}
	,Closure: {_hx_name:"Closure",_hx_index:7,__enum__:"object.ObjectType",toString:$estr}
	,Null: {_hx_name:"Null",_hx_index:8,__enum__:"object.ObjectType",toString:$estr}
};
object_ObjectType.__constructs__ = [object_ObjectType.Number,object_ObjectType.Boolean,object_ObjectType.String,object_ObjectType.Array,object_ObjectType.Hash,object_ObjectType.BuiltInFunction,object_ObjectType.UserFunction,object_ObjectType.Closure,object_ObjectType.Null];
var object__$StringObj_StringIterator = function(vm,value) {
	std_lib_MemberObject.call(this,vm);
	var index = -1;
	this.addFunctionMember("next",[],function(p) {
		index += 1;
		return new object_StringObj(value.charAt(index),vm);
	});
	this.addFunctionMember("hasNext",[],function(p) {
		return new object_BooleanObj(index < value.length - 1,vm);
	});
};
object__$StringObj_StringIterator.__name__ = true;
object__$StringObj_StringIterator.__super__ = std_lib_MemberObject;
object__$StringObj_StringIterator.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: object__$StringObj_StringIterator
});
var object_StringObj = function(value,vm) {
	var _gthis = this;
	object_Object.call(this,object_ObjectType.String,vm);
	this.value = value;
	if(vm == null) {
		return;
	}
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.toString(),vm);
	});
	this.addFunctionMember("length",[],function(p) {
		return new object_NumberObj(_gthis.value.length,vm);
	});
	this.addFunctionMember("Iterator",[],function(p) {
		return new object__$StringObj_StringIterator(vm,value).getMembers();
	});
	this.addFunctionMember("charAt",[object_ObjectType.Number],function(p) {
		var index = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var v = _gthis.value.charAt(index);
		return new object_StringObj(v,vm);
	});
	this.addFunctionMember("charCodeAt",[object_ObjectType.Number],function(p) {
		var index = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var v = HxOverrides.cca(_gthis.value,index);
		if(v == null) {
			return new object_NullObj(vm);
		} else {
			return new object_NumberObj(v,vm);
		}
	});
	this.addFunctionMember("split",[object_ObjectType.String],function(p) {
		var separator = (js_Boot.__cast(p[0] , object_StringObj)).value;
		var arr = [];
		var _g = 0;
		var _g1 = _gthis.value.split(separator);
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			arr.push(new object_StringObj(v,vm));
		}
		return new object_ArrayObj(arr,vm);
	});
	this.addFunctionMember("contains",[object_ObjectType.String],function(p) {
		var sub = (js_Boot.__cast(p[0] , object_StringObj)).value;
		return new object_BooleanObj(value.indexOf(sub) != -1,vm);
	});
	this.addFunctionMember("indexOf",[object_ObjectType.String,object_ObjectType.Number],function(p) {
		var sub = (js_Boot.__cast(p[0] , object_StringObj)).value;
		var start = (js_Boot.__cast(p[1] , object_NumberObj)).value | 0;
		return new object_NumberObj(value.indexOf(sub,start),vm);
	});
	this.addFunctionMember("substr",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var len = (js_Boot.__cast(p[1] , object_NumberObj)).value | 0;
		return new object_StringObj(HxOverrides.substr(value,pos,len),vm);
	});
	this.addFunctionMember("substring",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var start = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var end = (js_Boot.__cast(p[1] , object_NumberObj)).value | 0;
		return new object_StringObj(value.substring(start,end),vm);
	});
	this.addFunctionMember("replace",[object_ObjectType.String,object_ObjectType.String],function(p) {
		var sub = (js_Boot.__cast(p[0] , object_StringObj)).value;
		var by = (js_Boot.__cast(p[1] , object_StringObj)).value;
		return new object_StringObj(StringTools.replace(value,sub,by),vm);
	});
	this.addFunctionMember("toBytes",[],function(p) {
		return new std_lib_namespaces_io_Bytes(vm,haxe_io_Bytes.ofHex(value)).getMembers();
	});
	this.addFunctionMember("toHex",[],function(p) {
		return new object_StringObj(haxe_io_Bytes.ofString(value).toHex(),vm);
	});
};
object_StringObj.__name__ = true;
object_StringObj.__super__ = object_Object;
object_StringObj.prototype = $extend(object_Object.prototype,{
	toString: function() {
		return this.value;
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.String) {
			return false;
		}
		return (js_Boot.__cast(o , object_StringObj)).value == this.value;
	}
	,clone: function() {
		return new object_StringObj(this.value,this.vm);
	}
	,__class__: object_StringObj
});
var object_UserFunctionObj = function(position,parametersCount,vm) {
	var _gthis = this;
	object_Function.call(this,object_ObjectType.UserFunction,parametersCount,vm);
	this.position = position;
	if(vm == null) {
		return;
	}
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(_gthis.toString(),vm);
	});
};
object_UserFunctionObj.__name__ = true;
object_UserFunctionObj.__super__ = object_Function;
object_UserFunctionObj.prototype = $extend(object_Function.prototype,{
	toString: function() {
		return "#func(" + this.position + ", UserDefined)";
	}
	,equals: function(o) {
		if(o.type != object_ObjectType.UserFunction) {
			return false;
		}
		return (js_Boot.__cast(o , object_UserFunctionObj)).position == this.position;
	}
	,__class__: object_UserFunctionObj
});
var parser_ExpressionParser = function(parser,lexer) {
	this.parser = parser;
	this.lexer = lexer;
};
parser_ExpressionParser.__name__ = true;
parser_ExpressionParser.prototype = {
	parseExpression: function() {
		return new ast_nodes_ExpressionNode(this.parser.currentToken.position,this.disjunction());
	}
	,disjunction: function() {
		var left = this.conjunction();
		while(this.parser.currentToken.type == lexer_TokenType.Or) {
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.conjunction();
			left = new ast_nodes_OperatorNode(nodePos,ast_NodeType.Or,left,right);
		}
		return left;
	}
	,conjunction: function() {
		var left = this.bitOr();
		while(this.parser.currentToken.type == lexer_TokenType.And) {
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.bitOr();
			left = new ast_nodes_OperatorNode(nodePos,ast_NodeType.And,left,right);
		}
		return left;
	}
	,bitOr: function() {
		var left = this.bitXor();
		while(true) {
			var type;
			if(this.parser.currentToken.type._hx_index == 32) {
				type = ast_NodeType.BitOr;
			} else {
				break;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.bitXor();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,bitXor: function() {
		var left = this.bitAnd();
		while(true) {
			var type;
			if(this.parser.currentToken.type._hx_index == 35) {
				type = ast_NodeType.BitXor;
			} else {
				break;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.bitAnd();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,bitAnd: function() {
		var left = this.comparison();
		while(true) {
			var type;
			if(this.parser.currentToken.type._hx_index == 31) {
				type = ast_NodeType.BitAnd;
			} else {
				break;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.comparison();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,comparison: function() {
		var left = this.range();
		_hx_loop1: while(true) {
			var type;
			switch(this.parser.currentToken.type._hx_index) {
			case 23:
				type = ast_NodeType.Equals;
				break;
			case 24:
				type = ast_NodeType.NotEquals;
				break;
			case 27:
				type = ast_NodeType.GreaterThan;
				break;
			case 28:
				type = ast_NodeType.LessThan;
				break;
			case 29:
				type = ast_NodeType.GreaterThanOrEqual;
				break;
			case 30:
				type = ast_NodeType.LessThanOrEqual;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.range();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,range: function() {
		var start = new ast_nodes_ExpressionNode(this.parser.currentToken.position,this.bitShift());
		_hx_loop1: while(true) {
			var inclusive;
			switch(this.parser.currentToken.type._hx_index) {
			case 49:
				inclusive = false;
				break;
			case 50:
				inclusive = true;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var end = new ast_nodes_ExpressionNode(nodePos,this.bitShift());
			start = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_RangeNode(nodePos,start,end,inclusive));
		}
		return start;
	}
	,bitShift: function() {
		var left = this.numeric();
		_hx_loop1: while(true) {
			var type;
			switch(this.parser.currentToken.type._hx_index) {
			case 33:
				type = ast_NodeType.BitShiftLeft;
				break;
			case 34:
				type = ast_NodeType.BitShiftRight;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.numeric();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,numeric: function() {
		var left = this.term();
		_hx_loop1: while(true) {
			var type;
			switch(this.parser.currentToken.type._hx_index) {
			case 16:
				type = ast_NodeType.Add;
				break;
			case 17:
				type = ast_NodeType.Subtract;
				break;
			case 37:
				type = ast_NodeType.ConcatString;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.term();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,term: function() {
		var left = this.signedFactor();
		_hx_loop1: while(true) {
			var type;
			switch(this.parser.currentToken.type._hx_index) {
			case 18:
				type = ast_NodeType.Multiply;
				break;
			case 19:
				type = ast_NodeType.Divide;
				break;
			case 20:
				type = ast_NodeType.Modulo;
				break;
			default:
				break _hx_loop1;
			}
			this.parser.nextToken();
			var nodePos = this.parser.currentToken.position;
			var right = this.signedFactor();
			left = new ast_nodes_OperatorNode(nodePos,type,left,right);
		}
		return left;
	}
	,signedFactor: function() {
		switch(this.parser.currentToken.type._hx_index) {
		case 17:
			this.parser.nextToken();
			var right = this.access();
			return new ast_nodes_OperatorNode(this.parser.currentToken.position,ast_NodeType.Negate,null,right);
		case 22:
			this.parser.nextToken();
			var right = this.access();
			return new ast_nodes_OperatorNode(this.parser.currentToken.position,ast_NodeType.Not,null,right);
		case 36:
			this.parser.nextToken();
			var right = this.access();
			return new ast_nodes_OperatorNode(this.parser.currentToken.position,ast_NodeType.BitNot,null,right);
		default:
			return this.access();
		}
	}
	,access: function() {
		var left = new ast_nodes_ExpressionNode(this.parser.currentToken.position,this.factor());
		_hx_loop1: while(true) switch(this.parser.currentToken.type._hx_index) {
		case 41:
			left = this.parser.parseIndex(left);
			break;
		case 43:
			left = this.parser.parseCall(left);
			break;
		case 47:
			left = this.parser.parseIndex(left);
			break;
		default:
			break _hx_loop1;
		}
		return left;
	}
	,factor: function() {
		switch(this.parser.currentToken.type._hx_index) {
		case 2:
			var ident = new ast_nodes_IdentNode(this.parser.currentToken.position,this.parser.currentToken.literal);
			this.parser.nextToken();
			return ident;
		case 3:
			return this.parser.parseNumber();
		case 4:
			var string = new ast_nodes_datatypes_StringNode(this.parser.currentToken.position,this.parser.currentToken.literal);
			this.parser.nextToken();
			return string;
		case 38:
			return this.parser.parseRegex();
		case 43:
			this.parser.nextToken();
			var disjunction = this.disjunction();
			if(this.parser.currentToken.type != lexer_TokenType.RParen) {
				this.parser.error.unexpectedToken(this.parser.currentToken,"`)`");
			}
			this.parser.nextToken();
			return disjunction;
		case 45:
			if(this.parser.resolveHashBlockAmbiguity() == ast_NodeType.Block) {
				return this.parser.parseBlock();
			} else {
				return this.parser.parseHash();
			}
			break;
		case 47:
			return this.parser.parseArray();
		case 52:
			this.parser.nextToken();
			return this.parser.parseFunction();
		case 55:
			var boolean = new ast_nodes_datatypes_BooleanNode(this.parser.currentToken.position,true);
			this.parser.nextToken();
			return boolean;
		case 56:
			var boolean = new ast_nodes_datatypes_BooleanNode(this.parser.currentToken.position,false);
			this.parser.nextToken();
			return boolean;
		case 57:
			return this.parser.parseIf();
		case 64:
			var nullN = new ast_nodes_datatypes_NullNode(this.parser.currentToken.position);
			this.parser.nextToken();
			return nullN;
		case 67:
			return this.parser.parseWhen();
		default:
			this.parser.error.unexpectedToken(this.parser.currentToken,"expression");
			return null;
		}
	}
	,__class__: parser_ExpressionParser
};
var parser_Parser = function(lexer,isRepl) {
	this.lexer = lexer;
	this.isRepl = isRepl;
	this.ast = new ast_nodes_FileNode(new lexer_Position(1,1,0),lexer.filename,lexer.code);
	this.error = new error_CompileError(lexer.filename,lexer.code);
	this.expressionParser = new parser_ExpressionParser(this,lexer);
	this.currentToken = lexer.readToken();
};
parser_Parser.__name__ = true;
parser_Parser.prototype = {
	generateAst: function() {
		while(this.currentToken.type != lexer_TokenType.Eof) this.parseToken(this.ast);
	}
	,writeAst: function() {
	}
	,nextToken: function() {
		this.currentToken = this.lexer.readToken();
	}
	,resolveHashBlockAmbiguity: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.lexer.peekTokenN(2);
		while(_g1 < _g2.length) {
			var t = _g2[_g1];
			++_g1;
			_g.push(t.type);
		}
		var _g1 = _g;
		if(_g1.length == 2) {
			var _g = _g1[1];
			switch(_g1[0]._hx_index) {
			case 2:case 4:
				if(_g._hx_index == 42) {
					return ast_NodeType.Hash;
				} else {
					return ast_NodeType.Block;
				}
				break;
			case 46:
				return ast_NodeType.Hash;
			default:
				return ast_NodeType.Block;
			}
		} else {
			return ast_NodeType.Block;
		}
	}
	,parseNumber: function() {
		var nodePos = this.currentToken.position;
		var n = parseFloat(this.currentToken.literal);
		this.nextToken();
		return new ast_nodes_datatypes_FloatNode(nodePos,n);
	}
	,parseRegex: function() {
		var nodePos = this.currentToken.position;
		var pattern = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_datatypes_StringNode(nodePos,this.currentToken.literal));
		this.nextToken();
		var flags;
		if(this.currentToken.type == lexer_TokenType.Ident) {
			var flags1 = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_datatypes_StringNode(nodePos,this.currentToken.literal));
			this.nextToken();
			flags = flags1;
		} else {
			flags = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_datatypes_StringNode(nodePos,""));
		}
		return new ast_nodes_RegexNode(nodePos,pattern,flags);
	}
	,parseBlock: function() {
		this.nextToken();
		var block = new ast_nodes_BlockNode(this.currentToken.position);
		while(this.currentToken.type != lexer_TokenType.RBrace) {
			if(this.currentToken.type == lexer_TokenType.Eof) {
				this.error.unexpectedEof(this.currentToken);
			}
			this.parseToken(block);
		}
		this.nextToken();
		return block;
	}
	,parseFunction: function() {
		var nodePos = this.currentToken.position;
		this.assertToken(lexer_TokenType.LParen,"`(`");
		this.nextToken();
		var parameters = [];
		while(this.currentToken.type != lexer_TokenType.RParen) {
			if(this.currentToken.type == lexer_TokenType.Ident) {
				parameters.push(new ast_nodes_IdentNode(this.currentToken.position,this.currentToken.literal));
				if(this.lexer.peekToken().type != lexer_TokenType.Comma && this.lexer.peekToken().type != lexer_TokenType.RParen) {
					this.error.unexpectedToken(this.currentToken,"`,` or `)`");
				}
			} else if(this.currentToken.type == lexer_TokenType.Comma && this.lexer.peekToken().type == lexer_TokenType.RParen) {
				this.error.unexpectedToken(this.currentToken,"identifier or `)`");
			} else {
				this.assertToken(lexer_TokenType.Comma,"identifier");
			}
			this.nextToken();
		}
		this.nextToken();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var block = this.parseBlock();
		return new ast_nodes_datatypes_FunctionNode(nodePos,block,parameters);
	}
	,parseCall: function(target) {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var callParameters = [];
		while(this.currentToken.type != lexer_TokenType.RParen) {
			callParameters.push(this.expressionParser.parseExpression());
			if(this.currentToken.type == lexer_TokenType.Comma && this.lexer.peekToken().type == lexer_TokenType.RParen) {
				this.error.unexpectedToken(this.currentToken,"identifier or `)`");
			} else if(this.currentToken.type == lexer_TokenType.Comma) {
				this.nextToken();
			} else {
				this.assertToken(lexer_TokenType.RParen,"`,` or `)`");
			}
		}
		this.nextToken();
		return new ast_nodes_ExpressionNode(nodePos,new ast_nodes_CallNode(nodePos,target,callParameters));
	}
	,parseIndex: function(target) {
		var nodePos = this.currentToken.position;
		var index;
		switch(this.currentToken.type._hx_index) {
		case 41:
			this.nextToken();
			this.assertToken(lexer_TokenType.Ident,"identifier");
			var eIndex = new ast_nodes_ExpressionNode(this.currentToken.position,new ast_nodes_datatypes_StringNode(this.currentToken.position,this.currentToken.literal));
			this.nextToken();
			index = eIndex;
			break;
		case 47:
			this.nextToken();
			var eIndex = this.expressionParser.parseExpression();
			this.assertToken(lexer_TokenType.RBracket,"`]`");
			this.nextToken();
			index = eIndex;
			break;
		default:
			this.error.unexpectedToken(this.currentToken,"`[` or `.`");
			index = null;
		}
		return new ast_nodes_ExpressionNode(nodePos,new ast_nodes_IndexNode(nodePos,target,index));
	}
	,parseArray: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var values = [];
		while(this.currentToken.type != lexer_TokenType.RBracket) {
			values.push(this.expressionParser.parseExpression());
			if(this.currentToken.type == lexer_TokenType.Comma && this.lexer.peekToken().type == lexer_TokenType.RBracket) {
				this.error.unexpectedToken(this.currentToken,"expression or `]`");
			} else if(this.currentToken.type == lexer_TokenType.Comma) {
				this.nextToken();
			} else {
				this.assertToken(lexer_TokenType.RBracket,"`,` or `]`");
			}
		}
		this.nextToken();
		return new ast_nodes_datatypes_ArrayNode(nodePos,values);
	}
	,parseHash: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var values = new haxe_ds_ObjectMap();
		while(this.currentToken.type != lexer_TokenType.RBrace) {
			var key;
			if(this.currentToken.type == lexer_TokenType.Ident || this.currentToken.type == lexer_TokenType.String) {
				var eKey = new ast_nodes_ExpressionNode(this.currentToken.position,new ast_nodes_datatypes_StringNode(this.currentToken.position,this.currentToken.literal));
				this.nextToken();
				key = eKey;
			} else {
				this.error.unexpectedToken(this.currentToken,"identifier or string");
				key = null;
			}
			this.assertToken(lexer_TokenType.Colon,"`:`");
			this.nextToken();
			var value = this.expressionParser.parseExpression();
			if(this.currentToken.type != lexer_TokenType.Comma && this.currentToken.type != lexer_TokenType.RBrace) {
				this.error.unexpectedToken(this.currentToken,"`,` or `}`");
			} else if(this.currentToken.type == lexer_TokenType.Comma) {
				this.nextToken();
			}
			values.set(key,value);
		}
		this.nextToken();
		return new ast_nodes_datatypes_HashNode(nodePos,values);
	}
	,parseVariableName: function() {
		var nodePos = this.currentToken.position;
		switch(this.currentToken.type._hx_index) {
		case 2:
			return new ast_nodes_IdentNode(nodePos,this.currentToken.literal);
		case 45:case 47:
			var names = [];
			this.nextToken();
			while(this.currentToken.type != lexer_TokenType.RBracket && this.currentToken.type != lexer_TokenType.RBrace) {
				this.assertToken(lexer_TokenType.Ident,"identifier");
				names.push(this.currentToken.literal);
				this.nextToken();
				if(this.currentToken.type != lexer_TokenType.Comma && this.currentToken.type != lexer_TokenType.RBracket && this.currentToken.type != lexer_TokenType.RBrace) {
					this.error.unexpectedToken(this.currentToken,"`,`");
				}
				if(this.currentToken.type == lexer_TokenType.Comma) {
					this.nextToken();
				}
			}
			if(this.currentToken.type == lexer_TokenType.RBracket) {
				return new ast_nodes_DestructureArrayNode(nodePos,names);
			} else {
				return new ast_nodes_DestructureHashNode(nodePos,names);
			}
			break;
		default:
			this.error.unexpectedToken(this.currentToken,"identifier or `{`");
			return null;
		}
	}
	,parseVariable: function() {
		var nodePos = this.currentToken.position;
		var mutable = this.currentToken.type == lexer_TokenType.Mut;
		this.nextToken();
		var name = this.parseVariableName();
		this.nextToken();
		this.assertToken(lexer_TokenType.Assign,"`=`");
		this.nextToken();
		var value = this.expressionParser.parseExpression();
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_VariableNode(nodePos,name,value,mutable);
	}
	,parseReturn: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var returnValue = this.currentToken.type != lexer_TokenType.Semicolon ? this.expressionParser.parseExpression() : null;
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_ReturnNode(nodePos,returnValue);
	}
	,parseBreak: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_BreakNode(nodePos);
	}
	,parseContinue: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_ContinueNode(nodePos);
	}
	,parseIf: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var condition = this.expressionParser.parseExpression();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var consequence = this.parseBlock();
		var alternative = null;
		if(this.currentToken.type == lexer_TokenType.Else) {
			this.nextToken();
			if(this.currentToken.type == lexer_TokenType.If) {
				alternative = this.parseIf();
			} else {
				this.assertToken(lexer_TokenType.LBrace,"`{`");
				alternative = this.parseBlock();
			}
		}
		return new ast_nodes_IfNode(nodePos,condition,consequence,alternative);
	}
	,parseWhile: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var condition = this.expressionParser.parseExpression();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var block = this.parseBlock();
		return new ast_nodes_WhileNode(nodePos,condition,block);
	}
	,parseWhen: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var condition = this.currentToken.type != lexer_TokenType.LBrace ? this.expressionParser.parseExpression() : null;
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		this.nextToken();
		var elseCase = null;
		var cases = [];
		while(this.currentToken.type != lexer_TokenType.RBrace) if(this.currentToken.type == lexer_TokenType.Else) {
			this.nextToken();
			this.assertToken(lexer_TokenType.Arrow,"`=>`");
			this.nextToken();
			var consequence = this.currentToken.type == lexer_TokenType.LBrace ? new ast_nodes_ExpressionNode(this.currentToken.position,this.parseBlock()) : this.expressionParser.parseExpression();
			if(this.currentToken.type == lexer_TokenType.Semicolon) {
				this.nextToken();
				elseCase = new ast_nodes_StatementNode(nodePos,consequence);
			} else {
				elseCase = consequence;
			}
			this.assertToken(lexer_TokenType.RBrace,"`else` entry must be the last in when-expression");
		} else {
			var condition1 = this.expressionParser.parseExpression();
			this.assertToken(lexer_TokenType.Arrow,"`=>`");
			this.nextToken();
			var consequence1 = this.currentToken.type == lexer_TokenType.LBrace ? new ast_nodes_ExpressionNode(this.currentToken.position,this.parseBlock()) : this.expressionParser.parseExpression();
			if(this.currentToken.type == lexer_TokenType.Semicolon) {
				this.nextToken();
				cases.push({ condition : condition1, consequence : new ast_nodes_StatementNode(nodePos,consequence1)});
			} else {
				cases.push({ condition : condition1, consequence : consequence1});
			}
		}
		this.nextToken();
		return new ast_nodes_WhenNode(nodePos,condition,cases,elseCase);
	}
	,parseFor: function() {
		var nodePos = this.currentToken.position;
		this.nextToken();
		var variable;
		if(this.currentToken.type == lexer_TokenType.Let || this.currentToken.type == lexer_TokenType.Mut) {
			var mutable = this.currentToken.type == lexer_TokenType.Mut;
			this.nextToken();
			var variableName = this.parseVariableName();
			this.nextToken();
			this.assertToken(lexer_TokenType.In,"`in`");
			this.nextToken();
			variable = new ast_nodes_VariableNode(nodePos,variableName,null,mutable);
		} else {
			variable = null;
		}
		var iterator = this.expressionParser.parseExpression();
		this.assertToken(lexer_TokenType.LBrace,"`{`");
		var block = this.parseBlock();
		return new ast_nodes_ForNode(nodePos,variable,iterator,block);
	}
	,parseVariableAssign: function() {
		var _gthis = this;
		var nodePos = this.currentToken.position;
		var name = new ast_nodes_IdentNode(nodePos,this.currentToken.literal);
		this.nextToken();
		var value;
		switch(this.currentToken.type._hx_index) {
		case 5:
			_gthis.nextToken();
			value = _gthis.expressionParser.parseExpression();
			break;
		case 6:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Add,name,_gthis.expressionParser.parseExpression()));
			break;
		case 7:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Subtract,name,_gthis.expressionParser.parseExpression()));
			break;
		case 8:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Multiply,name,_gthis.expressionParser.parseExpression()));
			break;
		case 9:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Divide,name,_gthis.expressionParser.parseExpression()));
			break;
		case 10:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Modulo,name,_gthis.expressionParser.parseExpression()));
			break;
		case 11:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitAnd,name,_gthis.expressionParser.parseExpression()));
			break;
		case 12:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitOr,name,_gthis.expressionParser.parseExpression()));
			break;
		case 13:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitShiftLeft,name,_gthis.expressionParser.parseExpression()));
			break;
		case 14:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitShiftRight,name,_gthis.expressionParser.parseExpression()));
			break;
		case 15:
			_gthis.nextToken();
			value = new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitXor,name,_gthis.expressionParser.parseExpression()));
			break;
		default:
			this.assertToken(lexer_TokenType.Assign,"`=`");
			value = null;
		}
		this.assertSemicolon();
		this.nextToken();
		return new ast_nodes_VariableAssignNode(nodePos,name,value);
	}
	,parseStatement: function() {
		var _gthis = this;
		var nodePos = this.currentToken.position;
		var expression = this.expressionParser.parseExpression();
		var statement;
		switch(this.currentToken.type._hx_index) {
		case 5:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,value);
			break;
		case 6:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Add,expression,value)));
			break;
		case 7:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Subtract,expression,value)));
			break;
		case 8:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Multiply,expression,value)));
			break;
		case 9:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Divide,expression,value)));
			break;
		case 10:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.Modulo,expression,value)));
			break;
		case 11:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitAnd,expression,value)));
			break;
		case 12:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitOr,expression,value)));
			break;
		case 13:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitShiftLeft,expression,value)));
			break;
		case 14:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitShiftRight,expression,value)));
			break;
		case 15:
			_gthis.nextToken();
			var value = _gthis.expressionParser.parseExpression();
			_gthis.assertSemicolon();
			_gthis.nextToken();
			statement = new ast_nodes_IndexAssignNode(nodePos,expression,new ast_nodes_ExpressionNode(nodePos,new ast_nodes_OperatorNode(nodePos,ast_NodeType.BitXor,expression,value)));
			break;
		default:
			if(this.currentToken.type == lexer_TokenType.RBrace || this.isRepl && this.currentToken.type == lexer_TokenType.Eof) {
				statement = expression;
			} else {
				this.assertSemicolon();
				this.nextToken();
				statement = new ast_nodes_StatementNode(nodePos,expression);
			}
		}
		return statement;
	}
	,parseImport: function() {
		this.nextToken();
		this.assertToken(lexer_TokenType.String,"string containing path to source file");
		var fileName = "" + this.currentToken.literal + ".snek";
		this.nextToken();
		this.assertSemicolon();
		this.nextToken();
		var code = "";
		throw haxe_Exception.thrown("Imports not supported on this target");
	}
	,assertToken: function(type,expected) {
		if(this.currentToken.type != type) {
			this.error.unexpectedToken(this.currentToken,expected);
		}
	}
	,assertSemicolon: function() {
		if(this.currentToken.type != lexer_TokenType.Semicolon) {
			this.error.missingSemicolon(this.currentToken);
		}
	}
	,parseToken: function(block) {
		switch(this.currentToken.type._hx_index) {
		case 0:
			this.error.illegalToken(this.currentToken);
			break;
		case 2:
			switch(this.lexer.peekToken().type._hx_index) {
			case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				block.addNode(this.parseVariableAssign());
				break;
			default:
				block.addNode(this.parseStatement());
			}
			break;
		case 45:
			if(this.resolveHashBlockAmbiguity() == ast_NodeType.Block) {
				block.addNode(this.parseBlock());
			} else {
				block.addNode(this.parseStatement());
			}
			break;
		case 53:case 54:
			block.addNode(this.parseVariable());
			break;
		case 57:
			block.addNode(this.parseIf());
			break;
		case 59:
			block.addNode(this.parseWhile());
			break;
		case 60:
			block.addNode(this.parseReturn());
			break;
		case 62:
			block.addNode(this.parseBreak());
			break;
		case 63:
			block.addNode(this.parseContinue());
			break;
		case 65:
			block.addNode(this.parseFor());
			break;
		case 67:
			block.addNode(this.parseWhen());
			break;
		default:
			block.addNode(this.parseStatement());
		}
	}
	,__class__: parser_Parser
};
var std_BuiltInTable = function(vm) {
	this.vm = vm;
	this.namespaces = [new std_lib_namespaces_SysNamespace(vm),new std_lib_namespaces_MathNamespace(vm),new std_lib_namespaces_NumberNamespace(vm),new std_lib_namespaces_ObjectNamespace(vm),new std_lib_namespaces_RangeNamespace(vm),new std_lib_namespaces_RegexNamespace(vm),new std_lib_namespaces_json_JsonNamespace(vm),new std_lib_namespaces_io_IoNamespace(vm),new std_lib_namespaces_StringNamespace(vm)];
};
std_BuiltInTable.__name__ = true;
std_BuiltInTable.resolveName = function(name) {
	return [std_lib_namespaces_SysNamespace.$name,std_lib_namespaces_MathNamespace.$name,std_lib_namespaces_NumberNamespace.$name,std_lib_namespaces_ObjectNamespace.$name,std_lib_namespaces_RangeNamespace.$name,std_lib_namespaces_RegexNamespace.$name,std_lib_namespaces_json_JsonNamespace.$name,std_lib_namespaces_io_IoNamespace.$name,std_lib_namespaces_StringNamespace.$name].indexOf(name);
};
std_BuiltInTable.prototype = {
	resolveIndex: function(index) {
		return this.namespaces[index].getMembers();
	}
	,callFunction: function(func) {
		var parameters = [];
		var _g = 0;
		var _g1 = func.parametersCount;
		while(_g < _g1) {
			var i = _g++;
			var _this = this.vm;
			var _this1 = _this.stack;
			var k = _this1.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this1.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				_this.error.error("failed to evaluate expression");
			}
			var parameter = o;
			if(func.parameters[i] != null && parameter.type != func.parameters[i]) {
				this.vm.error.error("expected " + Std.string(func.parameters[i]) + ", got " + Std.string(parameter.type));
			}
			parameters.push(parameter);
		}
		var returnValue = func.func(parameters);
		var _this = this.vm.stack;
		_this.head = new haxe_ds_GenericCell(returnValue,_this.head);
		this.vm.popFrame();
	}
	,__class__: std_BuiltInTable
};
var std_lib_namespaces_MathNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addObjectMember("PI",new object_NumberObj(Math.PI,vm));
	this.addFunctionMember("abs",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		return new object_NumberObj(Math.abs(value),vm);
	});
	this.addFunctionMember("floor",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		return new object_NumberObj(Math.floor(value),vm);
	});
	this.addFunctionMember("sqrt",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		return new object_NumberObj(Math.sqrt(value),vm);
	});
	this.addFunctionMember("random",[],function(p) {
		return new object_NumberObj(Math.random(),vm);
	});
	this.addFunctionMember("pow",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value;
		var exponent = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		return new object_NumberObj(Math.pow(value,exponent),vm);
	});
};
std_lib_namespaces_MathNamespace.__name__ = true;
std_lib_namespaces_MathNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_MathNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_MathNamespace
});
var std_lib_namespaces_NumberNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("parse",[object_ObjectType.String],function(p) {
		var value = (js_Boot.__cast(p[0] , object_StringObj)).value;
		return new object_NumberObj(parseFloat(value),vm);
	});
};
std_lib_namespaces_NumberNamespace.__name__ = true;
std_lib_namespaces_NumberNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_NumberNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_NumberNamespace
});
var std_lib_namespaces_ObjectNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("typeof",[null],function(parameters) {
		return new object_StringObj(Std.string(parameters[0].type),vm);
	});
};
std_lib_namespaces_ObjectNamespace.__name__ = true;
std_lib_namespaces_ObjectNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_ObjectNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_ObjectNamespace
});
var std_lib_namespaces__$RangeNamespace_ExclusiveRange = function(vm,start,end) {
	std_lib_MemberObject.call(this,vm);
	var current = start - 1;
	this.addFunctionMember("next",[],function(p) {
		current += 1;
		return new object_NumberObj(current,vm);
	});
	this.addFunctionMember("hasNext",[],function(p) {
		return new object_BooleanObj(current + 1 < end,vm);
	});
};
std_lib_namespaces__$RangeNamespace_ExclusiveRange.__name__ = true;
std_lib_namespaces__$RangeNamespace_ExclusiveRange.__super__ = std_lib_MemberObject;
std_lib_namespaces__$RangeNamespace_ExclusiveRange.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces__$RangeNamespace_ExclusiveRange
});
var std_lib_namespaces__$RangeNamespace_Iterator = function(vm,start,end) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("Iterator",[],function(p) {
		return new std_lib_namespaces__$RangeNamespace_ExclusiveRange(vm,start,end).getMembers();
	});
};
std_lib_namespaces__$RangeNamespace_Iterator.__name__ = true;
std_lib_namespaces__$RangeNamespace_Iterator.__super__ = std_lib_MemberObject;
std_lib_namespaces__$RangeNamespace_Iterator.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces__$RangeNamespace_Iterator
});
var std_lib_namespaces_RangeNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("exclusive",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var start = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var end = (js_Boot.__cast(p[1] , object_NumberObj)).value | 0;
		return new std_lib_namespaces__$RangeNamespace_Iterator(vm,start,end).getMembers();
	});
	this.addFunctionMember("inclusive",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var start = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var end = (js_Boot.__cast(p[1] , object_NumberObj)).value + 1 | 0;
		return new std_lib_namespaces__$RangeNamespace_Iterator(vm,start,end).getMembers();
	});
};
std_lib_namespaces_RangeNamespace.__name__ = true;
std_lib_namespaces_RangeNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_RangeNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_RangeNamespace
});
var std_lib_namespaces_Regex = function(vm,regex) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("match",[object_ObjectType.String],function(p) {
		var s = (js_Boot.__cast(p[0] , object_StringObj)).value;
		return new object_BooleanObj(regex.match(s),vm);
	});
	this.addFunctionMember("replace",[object_ObjectType.String,object_ObjectType.String],function(p) {
		var s = (js_Boot.__cast(p[0] , object_StringObj)).value;
		var by = (js_Boot.__cast(p[1] , object_StringObj)).value;
		return new object_StringObj(s.replace(regex.r,by),vm);
	});
};
std_lib_namespaces_Regex.__name__ = true;
std_lib_namespaces_Regex.__super__ = std_lib_MemberObject;
std_lib_namespaces_Regex.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_Regex
});
var std_lib_namespaces_RegexNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("compile",[object_ObjectType.String,object_ObjectType.String],function(p) {
		var pattern = (js_Boot.__cast(p[0] , object_StringObj)).value;
		var flags = (js_Boot.__cast(p[1] , object_StringObj)).value;
		return new std_lib_namespaces_Regex(vm,new EReg(pattern,flags)).getMembers();
	});
};
std_lib_namespaces_RegexNamespace.__name__ = true;
std_lib_namespaces_RegexNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_RegexNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_RegexNamespace
});
var std_lib_namespaces_StringNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("fromCharCode",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new object_StringObj(String.fromCodePoint(value),vm);
	});
};
std_lib_namespaces_StringNamespace.__name__ = true;
std_lib_namespaces_StringNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_StringNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_StringNamespace
});
var std_lib_namespaces_SysNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("trace",[null],function(p) {
		var filename = vm.filenameTable.resolve(vm.instructions.pos);
		var position = vm.lineNumberTable.resolve(vm.instructions.pos);
		var s = "" + filename + ":" + position.line + ": " + Std.string(p[0]);
		$global.console.log(s);
		return p[0];
	});
	this.addFunctionMember("println",[null],function(p) {
		$global.console.log(p[0].toString());
		return new object_NullObj(vm);
	});
	this.addFunctionMember("print",[null],function(p) {
		$global.console.log(p[0].toString());
		return new object_NullObj(vm);
	});
	this.addFunctionMember("readLine",[],function(p) {
		var input = "";
		throw haxe_Exception.thrown("Read line not supported on this target");
	});
	this.addFunctionMember("sleep",[object_ObjectType.Number],function(p) {
		throw haxe_Exception.thrown("unsupported");
	});
	this.addFunctionMember("exit",[object_ObjectType.Number],function(p) {
		throw haxe_Exception.thrown("unsupported");
	});
};
std_lib_namespaces_SysNamespace.__name__ = true;
std_lib_namespaces_SysNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_SysNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_SysNamespace
});
var std_lib_namespaces_io_Bytes = function(vm,bytes) {
	std_lib_MemberObject.call(this,vm);
	this.bytes = bytes;
	this.addFunctionMember("getByte",[object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new object_NumberObj(bytes.b[pos],vm);
	});
	this.addFunctionMember("getUInt16",[object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new object_NumberObj(bytes.getUInt16(pos),vm);
	});
	this.addFunctionMember("getInt32",[object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new object_NumberObj(bytes.getInt32(pos),vm);
	});
	this.addFunctionMember("getFloat32",[object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new object_NumberObj(bytes.getFloat(pos),vm);
	});
	this.addFunctionMember("getFloat64",[object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new object_NumberObj(bytes.getDouble(pos),vm);
	});
	this.addFunctionMember("setByte",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var value = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		bytes.b[pos] = value | 0;
		return new object_NullObj(vm);
	});
	this.addFunctionMember("setUInt16",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var value = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		bytes.setUInt16(pos,value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("setInt32",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var value = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		bytes.setInt32(pos,value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("setFloat32",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var value = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		bytes.setFloat(pos,value);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("setFloat64",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var value = (js_Boot.__cast(p[1] , object_NumberObj)).value;
		bytes.setDouble(pos,value);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("getString",[object_ObjectType.Number,object_ObjectType.Number],function(p) {
		var pos = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		var len = (js_Boot.__cast(p[1] , object_NumberObj)).value | 0;
		var this1 = bytes.getString(pos,len);
		return new object_StringObj(this1,vm);
	});
	this.addFunctionMember("length",[],function(p) {
		return new object_NumberObj(bytes.length,vm);
	});
	this.addFunctionMember("toHex",[],function(p) {
		return new object_StringObj(bytes.toHex(),vm);
	});
	this.addFunctionMember("toString",[],function(p) {
		return new object_StringObj(bytes.toString(),vm);
	});
};
std_lib_namespaces_io_Bytes.__name__ = true;
std_lib_namespaces_io_Bytes.__super__ = std_lib_MemberObject;
std_lib_namespaces_io_Bytes.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_io_Bytes
});
var std_lib_namespaces_io_BytesOutput = function(vm,bytes) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("setBigEndian",[object_ObjectType.Boolean],function(p) {
		var bigEndian = (js_Boot.__cast(p[0] , object_BooleanObj)).value;
		bytes.set_bigEndian(bigEndian);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeByte",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeByte(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeInt8",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeInt8(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeInt16",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeInt16(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeUInt16",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeUInt16(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeInt24",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeInt24(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeUInt24",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeUInt24(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeInt32",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeInt32(value | 0);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeFloat32",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeFloat(value);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeFloat64",[object_ObjectType.Number],function(p) {
		var value = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		bytes.writeDouble(value);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeString",[object_ObjectType.String],function(p) {
		var value = (js_Boot.__cast(p[0] , object_StringObj)).value;
		bytes.writeString(value);
		return new object_NullObj(vm);
	});
	this.addFunctionMember("writeHex",[object_ObjectType.String],function(p) {
		var value = (js_Boot.__cast(p[0] , object_StringObj)).value;
		bytes.write(haxe_io_Bytes.ofHex(value));
		return new object_NullObj(vm);
	});
	this.addFunctionMember("length",[],function(p) {
		return new object_NumberObj(bytes.b.pos,vm);
	});
	this.addFunctionMember("getBytes",[],function(p) {
		return new std_lib_namespaces_io_Bytes(vm,bytes.getBytes()).getMembers();
	});
};
std_lib_namespaces_io_BytesOutput.__name__ = true;
std_lib_namespaces_io_BytesOutput.__super__ = std_lib_MemberObject;
std_lib_namespaces_io_BytesOutput.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_io_BytesOutput
});
var std_lib_namespaces_io_IoNamespace = function(vm) {
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("Bytes",[object_ObjectType.Number],function(p) {
		var size = (js_Boot.__cast(p[0] , object_NumberObj)).value | 0;
		return new std_lib_namespaces_io_Bytes(vm,new haxe_io_Bytes(new ArrayBuffer(size))).getMembers();
	});
	this.addFunctionMember("BytesOutput",[],function(p) {
		return new std_lib_namespaces_io_BytesOutput(vm,new haxe_io_BytesOutput()).getMembers();
	});
};
std_lib_namespaces_io_IoNamespace.__name__ = true;
std_lib_namespaces_io_IoNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_io_IoNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_io_IoNamespace
});
var std_lib_namespaces_json_JsonDecoder = function(json,vm) {
	this.vm = vm;
	this.lexer = new std_lib_namespaces_json_lexer_Lexer(json);
	this.currentToken = this.lexer.readToken();
};
std_lib_namespaces_json_JsonDecoder.__name__ = true;
std_lib_namespaces_json_JsonDecoder.prototype = {
	nextToken: function() {
		this.currentToken = this.lexer.readToken();
	}
	,parseHash: function() {
		this.nextToken();
		var map = new haxe_ds_StringMap();
		while(this.currentToken.type != std_lib_namespaces_json_lexer_TokenType.RBrace) {
			this.assertToken(std_lib_namespaces_json_lexer_TokenType.String,"String");
			var key = this.currentToken.literal;
			this.nextToken();
			this.assertToken(std_lib_namespaces_json_lexer_TokenType.Colon,"`:`");
			this.nextToken();
			var value = this.decode();
			if(this.currentToken.type == std_lib_namespaces_json_lexer_TokenType.Comma) {
				if(this.lexer.peekToken().type == std_lib_namespaces_json_lexer_TokenType.RBrace) {
					throw haxe_Exception.thrown("failed to parse JSON. illegal trailing comma");
				}
				this.nextToken();
			}
			map.h[key] = value;
		}
		this.nextToken();
		return new object_HashObj(map,this.vm);
	}
	,parseArray: function() {
		this.nextToken();
		var array = [];
		while(this.currentToken.type != std_lib_namespaces_json_lexer_TokenType.RBracket) {
			array.push(this.decode());
			if(this.currentToken.type == std_lib_namespaces_json_lexer_TokenType.Comma) {
				if(this.lexer.peekToken().type == std_lib_namespaces_json_lexer_TokenType.RBracket) {
					throw haxe_Exception.thrown("failed to parse JSON. illegal trailing comma");
				}
				this.nextToken();
			}
		}
		this.nextToken();
		return new object_ArrayObj(array,this.vm);
	}
	,assertToken: function(type,expected) {
		if(this.currentToken.type != type) {
			throw haxe_Exception.thrown("failed to parse JSON. got " + Std.string(this.currentToken.type) + ", expected " + expected);
		}
	}
	,decode: function() {
		var o;
		switch(this.currentToken.type._hx_index) {
		case 2:
			var n = new object_NumberObj(parseFloat(this.currentToken.literal),this.vm);
			this.nextToken();
			o = n;
			break;
		case 3:
			var s = new object_StringObj(this.currentToken.literal,this.vm);
			this.nextToken();
			o = s;
			break;
		case 4:
			this.nextToken();
			o = new object_NullObj(this.vm);
			break;
		case 5:
			this.nextToken();
			o = new object_BooleanObj(true,this.vm);
			break;
		case 6:
			this.nextToken();
			o = new object_BooleanObj(false,this.vm);
			break;
		case 7:
			this.nextToken();
			var n = new object_NumberObj(-parseFloat(this.currentToken.literal),this.vm);
			this.nextToken();
			o = n;
			break;
		case 10:
			o = this.parseHash();
			break;
		case 12:
			o = this.parseArray();
			break;
		default:
			throw haxe_Exception.thrown("failed to parse JSON. unexpected token " + Std.string(this.currentToken.type));
		}
		return o;
	}
	,__class__: std_lib_namespaces_json_JsonDecoder
};
var std_lib_namespaces_json_JsonEncoder = function() { };
std_lib_namespaces_json_JsonEncoder.__name__ = true;
std_lib_namespaces_json_JsonEncoder.encode = function(object) {
	var encoded_b = "";
	switch(object.type._hx_index) {
	case 0:
		var cNumber = js_Boot.__cast(object , object_NumberObj);
		encoded_b += Std.string(Std.string(cNumber));
		break;
	case 1:
		var cBoolean = js_Boot.__cast(object , object_BooleanObj);
		encoded_b += Std.string(cBoolean.value ? "true" : "false");
		break;
	case 2:
		var cString = js_Boot.__cast(object , object_StringObj);
		encoded_b += Std.string("\"" + cString.value + "\"");
		break;
	case 3:
		var cArray = js_Boot.__cast(object , object_ArrayObj);
		encoded_b += "[";
		var iterator_current = 0;
		var iterator_array = cArray.value;
		while(iterator_current < iterator_array.length) {
			var v = iterator_array[iterator_current++];
			encoded_b += Std.string(std_lib_namespaces_json_JsonEncoder.encode(v));
			if(iterator_current < iterator_array.length) {
				encoded_b += ", ";
			}
		}
		encoded_b += "]";
		break;
	case 4:
		var cHash = js_Boot.__cast(object , object_HashObj);
		encoded_b += "{";
		var map = cHash.value;
		var iterator_map = map;
		var iterator_keys = map.keys();
		while(iterator_keys.hasNext()) {
			var key = iterator_keys.next();
			var _g1_value = iterator_map.get(key);
			var _g1_key = key;
			var k = _g1_key;
			var v = _g1_value;
			encoded_b += Std.string("\"" + k + "\"");
			encoded_b += ": ";
			encoded_b += Std.string(std_lib_namespaces_json_JsonEncoder.encode(v));
			if(iterator_keys.hasNext()) {
				encoded_b += ", ";
			}
		}
		encoded_b += "}";
		break;
	case 8:
		encoded_b += "null";
		break;
	default:
		throw haxe_Exception.thrown("failed to encode JSON. unsupported data type " + Std.string(object.type));
	}
	return encoded_b;
};
var std_lib_namespaces_json_JsonNamespace = function(vm) {
	var _gthis = this;
	std_lib_MemberObject.call(this,vm);
	this.addFunctionMember("encode",[null],function(p) {
		try {
			return new object_StringObj(std_lib_namespaces_json_JsonEncoder.encode(p[0]),vm);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g);
			_gthis.error(e.get_message());
			return null;
		}
	});
	this.addFunctionMember("decode",[object_ObjectType.String],function(p) {
		var json = (js_Boot.__cast(p[0] , object_StringObj)).value;
		try {
			var decoder = new std_lib_namespaces_json_JsonDecoder(json,vm);
			return decoder.decode();
		} catch( _g ) {
			var e = haxe_Exception.caught(_g);
			_gthis.error(e.get_message());
			return null;
		}
	});
};
std_lib_namespaces_json_JsonNamespace.__name__ = true;
std_lib_namespaces_json_JsonNamespace.__super__ = std_lib_MemberObject;
std_lib_namespaces_json_JsonNamespace.prototype = $extend(std_lib_MemberObject.prototype,{
	__class__: std_lib_namespaces_json_JsonNamespace
});
var std_lib_namespaces_json_lexer_Lexer = function(json) {
	this.position = 0;
	this.currentChar = " ";
	this.json = json;
};
std_lib_namespaces_json_lexer_Lexer.__name__ = true;
std_lib_namespaces_json_lexer_Lexer.prototype = {
	readChar: function() {
		this.currentChar = this.position >= this.json.length ? "\x00" : this.json.charAt(this.position);
		this.position++;
	}
	,peekChar: function() {
		if(this.position >= this.json.length) {
			return "\x00";
		} else {
			return this.json.charAt(this.position);
		}
	}
	,escapeChar: function() {
		this.readChar();
		switch(this.currentChar) {
		case "\"":
			return "\"";
		case "/":
			return "/";
		case "\\":
			return "\\";
		case "b":
			return "\x08";
		case "f":
			return "\x0C";
		case "n":
			return "\n";
		case "r":
			return "\r";
		case "t":
			return "\t";
		default:
			return "";
		}
	}
	,readString: function() {
		this.readChar();
		var string_b = "";
		while(this.currentChar != "\"" && this.currentChar != "\x00") {
			if(this.currentChar == "\\") {
				string_b += Std.string(this.escapeChar());
			} else {
				string_b += Std.string(this.currentChar);
			}
			this.readChar();
		}
		return string_b;
	}
	,readNumber: function() {
		var startPosition = this.position;
		while(true) {
			var s = this.peekChar();
			if(!(new EReg("^[0-9]+$","").match(s) || this.peekChar() == ".")) {
				break;
			}
			this.readChar();
		}
		return this.json.substring(startPosition - 1,this.position);
	}
	,readIdent: function() {
		var startPosition = this.position;
		while(true) {
			var s = this.peekChar();
			if(!new EReg("^[a-zA-Z0-9_\\$]+$","").match(s)) {
				break;
			}
			this.readChar();
		}
		return this.json.substring(startPosition - 1,this.position);
	}
	,eatWhitespace: function() {
		while(true) {
			var tmp;
			if(this.currentChar != " ") {
				var s = this.currentChar;
				tmp = new EReg("\r\n|\r|\n","").match(s);
			} else {
				tmp = true;
			}
			if(!(tmp || this.currentChar == "\t")) {
				break;
			}
			this.readChar();
		}
	}
	,tokenize: function() {
		while(this.currentChar != "\x00") {
			var token = this.readToken();
			console.log("src/std/lib/namespaces/json/lexer/Lexer.hx:93:","" + token.position + " " + Std.string(token.type) + " " + token.literal);
		}
	}
	,peekToken: function() {
		var lastPosition = this.position;
		var lastChar = this.currentChar;
		var token = this.readToken();
		this.position = lastPosition;
		this.currentChar = lastChar;
		return token;
	}
	,readToken: function() {
		this.readChar();
		this.eatWhitespace();
		switch(this.currentChar) {
		case "\x00":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Eof,this.position,this.currentChar);
		case "\"":
			var string = this.readString();
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.String,this.position,string);
		case ",":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Comma,this.position,",");
		case "-":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Minus,this.position,"-");
		case ":":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Colon,this.position,":");
		case "[":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.LBracket,this.position,"[");
		case "]":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.RBracket,this.position,"]");
		case "{":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.LBrace,this.position,"{");
		case "}":
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.RBrace,this.position,"}");
		default:
			var s = this.currentChar;
			if(new EReg("^[0-9]+$","").match(s)) {
				var number = this.readNumber();
				return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Number,this.position,number);
			}
			var s = this.currentChar;
			if(new EReg("^[a-zA-Z0-9_\\$]+$","").match(s)) {
				var ident = this.readIdent();
				switch(ident) {
				case "false":
					return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.False,this.position,"false");
				case "null":
					return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Null,this.position,"null");
				case "true":
					return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.True,this.position,"true");
				}
			}
			return new std_lib_namespaces_json_lexer_Token(std_lib_namespaces_json_lexer_TokenType.Illegal,this.position,this.currentChar);
		}
	}
	,__class__: std_lib_namespaces_json_lexer_Lexer
};
var std_lib_namespaces_json_lexer_Token = function(type,position,literal) {
	this.type = type;
	this.position = position;
	this.literal = literal;
};
std_lib_namespaces_json_lexer_Token.__name__ = true;
std_lib_namespaces_json_lexer_Token.prototype = {
	__class__: std_lib_namespaces_json_lexer_Token
};
var std_lib_namespaces_json_lexer_TokenType = $hxEnums["std.lib.namespaces.json.lexer.TokenType"] = { __ename__:true,__constructs__:null
	,Illegal: {_hx_name:"Illegal",_hx_index:0,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:1,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,Number: {_hx_name:"Number",_hx_index:2,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,String: {_hx_name:"String",_hx_index:3,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,Null: {_hx_name:"Null",_hx_index:4,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,True: {_hx_name:"True",_hx_index:5,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,False: {_hx_name:"False",_hx_index:6,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,Minus: {_hx_name:"Minus",_hx_index:7,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:8,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,Colon: {_hx_name:"Colon",_hx_index:9,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,LBrace: {_hx_name:"LBrace",_hx_index:10,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,RBrace: {_hx_name:"RBrace",_hx_index:11,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,LBracket: {_hx_name:"LBracket",_hx_index:12,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
	,RBracket: {_hx_name:"RBracket",_hx_index:13,__enum__:"std.lib.namespaces.json.lexer.TokenType",toString:$estr}
};
std_lib_namespaces_json_lexer_TokenType.__constructs__ = [std_lib_namespaces_json_lexer_TokenType.Illegal,std_lib_namespaces_json_lexer_TokenType.Eof,std_lib_namespaces_json_lexer_TokenType.Number,std_lib_namespaces_json_lexer_TokenType.String,std_lib_namespaces_json_lexer_TokenType.Null,std_lib_namespaces_json_lexer_TokenType.True,std_lib_namespaces_json_lexer_TokenType.False,std_lib_namespaces_json_lexer_TokenType.Minus,std_lib_namespaces_json_lexer_TokenType.Comma,std_lib_namespaces_json_lexer_TokenType.Colon,std_lib_namespaces_json_lexer_TokenType.LBrace,std_lib_namespaces_json_lexer_TokenType.RBrace,std_lib_namespaces_json_lexer_TokenType.LBracket,std_lib_namespaces_json_lexer_TokenType.RBracket];
var vm_Environment = function() {
	this.variables = [];
};
vm_Environment.__name__ = true;
vm_Environment.prototype = {
	setVariable: function(index,value) {
		this.variables[index] = value;
	}
	,getVariable: function(index) {
		return this.variables[index];
	}
	,hasVariable: function(index) {
		return this.variables[index] != null;
	}
	,__class__: vm_Environment
};
var vm_Frame = function(parent,returnAddress,calledFunction,expectedStackSize) {
	this.parent = parent;
	this.returnAddress = returnAddress;
	this.calledFunction = calledFunction;
	this.env = new vm_Environment();
	this.expectedStackSize = expectedStackSize;
};
vm_Frame.__name__ = true;
vm_Frame.prototype = {
	getVariable: function(index) {
		var v = this.env.getVariable(index);
		if(v == null && this.parent != null) {
			return this.parent.getVariable(index);
		}
		return v;
	}
	,setVariable: function(index,value) {
		if(this.parent != null && this.parent.env.hasVariable(index) && !this.env.hasVariable(index)) {
			this.parent.env.setVariable(index,value);
		} else {
			this.env.setVariable(index,value);
		}
	}
	,__class__: vm_Frame
};
var vm_VirtualMachine = function(fileData) {
	this.frames = new haxe_ds_GenericStack();
	this.stack = new haxe_ds_GenericStack();
	this.fileData = fileData;
	this.newWithState(fileData);
	this.builtInTable = new std_BuiltInTable(this);
	this.error = new error_RuntimeError(this);
	this.pushFrame(null,0,null);
};
vm_VirtualMachine.__name__ = true;
vm_VirtualMachine.prototype = {
	newWithState: function(fileData) {
		var fileData1 = new haxe_io_BytesInput(fileData);
		var byteCode = fileData1.readByte() == 1 ? new haxe_io_BytesInput(haxe_zip_Uncompress.run(fileData1.readAll())) : new haxe_io_BytesInput(fileData1.readAll());
		this.filenameTable = new compiler_debug_FilenameTable().fromByteCode(byteCode);
		this.lineNumberTable = new compiler_debug_LineNumberTable().fromByteCode(byteCode);
		this.variableTable = new compiler_debug_VariableTable().fromByteCode(byteCode);
		this.constantPool = compiler_constant_ConstantPool.fromByteCode(byteCode,this);
		var oPosition = this.instructions != null ? this.instructions.pos : -1;
		this.instructions = new haxe_io_BytesInput(byteCode.read(byteCode.readInt32()));
		if(oPosition != -1) {
			this.instructions.set_position(oPosition);
		}
	}
	,pushFrame: function(context,returnAddress,calledFunction) {
		var expectedStackSize = calledFunction != null ? Lambda.count(this.stack) + 1 - calledFunction.parametersCount : 0;
		var _this = this.frames;
		_this.head = new haxe_ds_GenericCell(new vm_Frame(context,returnAddress,calledFunction,expectedStackSize),_this.head);
		var _this = this.frames;
		this.currentFrame = _this.head == null ? null : _this.head.elt;
	}
	,popFrame: function() {
		var _this = this.frames;
		var k = _this.head;
		var frame;
		if(k == null) {
			frame = null;
		} else {
			_this.head = k.next;
			frame = k.elt;
		}
		var _this = this.frames;
		this.currentFrame = _this.head == null ? null : _this.head.elt;
		return frame;
	}
	,popStack: function() {
		var _this = this.stack;
		var k = _this.head;
		var o;
		if(k == null) {
			o = null;
		} else {
			_this.head = k.next;
			o = k.elt;
		}
		if(o == null) {
			this.error.error("failed to evaluate expression");
		}
		return o;
	}
	,callFunction: function(closure,parameters) {
		parameters.reverse();
		var _g = 0;
		while(_g < parameters.length) {
			var p = parameters[_g];
			++_g;
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(p,_this.head);
		}
		switch(closure.func.type._hx_index) {
		case 5:
			var cBuiltInFunction = js_Boot.__cast(closure.func , object_BuiltInFunctionObj);
			this.builtInTable.callFunction(cBuiltInFunction);
			break;
		case 6:
			var cUserFunction = js_Boot.__cast(closure.func , object_UserFunctionObj);
			if(parameters.length != cUserFunction.parametersCount) {
				this.error.error("wrong number of arguments to function");
			}
			var oPosition = this.instructions.pos;
			this.pushFrame(closure.context,this.instructions.totlen,cUserFunction);
			this.instructions.set_position(cUserFunction.position);
			this.eval();
			this.instructions.set_position(oPosition);
			break;
		default:
		}
		var _this = this.stack;
		var k = _this.head;
		var o;
		if(k == null) {
			o = null;
		} else {
			_this.head = k.next;
			o = k.elt;
		}
		if(o == null) {
			this.error.error("failed to evaluate expression");
		}
		return o;
	}
	,'eval': function() {
		while(this.instructions.pos < this.instructions.totlen) this.evalInstruction();
	}
	,evalInstruction: function() {
		var opCode = this.instructions.readByte();
		switch(opCode) {
		case 0:
			var constantIndex = this.instructions.readInt32();
			var constant = this.constantPool[constantIndex].type._hx_index == 6 ? new object_ClosureObj(js_Boot.__cast(this.constantPool[constantIndex] , object_UserFunctionObj),this.currentFrame,this) : this.constantPool[constantIndex];
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(constant,_this.head);
			break;
		case 1:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			break;
		case 2:
			var jumpIndex = this.instructions.readInt32();
			this.instructions.set_position(jumpIndex);
			break;
		case 3:
			var jumpIndex = this.instructions.readInt32();
			try {
				var _this = this.stack;
				var k = _this.head;
				var o;
				if(k == null) {
					o = null;
				} else {
					_this.head = k.next;
					o = k.elt;
				}
				if(o == null) {
					this.error.error("failed to evaluate expression");
				}
				var conditionValue = (js_Boot.__cast(o , object_BooleanObj)).value;
				if(!conditionValue) {
					this.instructions.set_position(jumpIndex);
				}
			} catch( _g ) {
				this.error.error("expected condition to evaluate to boolean");
			}
			break;
		case 4:
			var jumpIndex = this.instructions.readInt32();
			try {
				var _this = this.stack;
				var conditionValue = (js_Boot.__cast(_this.head == null ? null : _this.head.elt , object_BooleanObj)).value;
				if(conditionValue) {
					this.instructions.set_position(jumpIndex);
				}
			} catch( _g ) {
				this.error.error("expected condition to evaluate to boolean");
			}
			break;
		case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 15:case 17:case 18:case 19:case 20:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var right = o;
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var left = o;
			if(left.type != object_ObjectType.Number || right.type != object_ObjectType.Number) {
				this.error.error("cannot perform operation (left: " + Std.string(left.type) + ", right: " + Std.string(right.type) + ")");
			}
			var cLeft = (js_Boot.__cast(left , object_NumberObj)).value;
			var cRight = (js_Boot.__cast(right , object_NumberObj)).value;
			var o;
			switch(opCode) {
			case 5:
				o = new object_NumberObj(cLeft + cRight,this);
				break;
			case 6:
				o = new object_NumberObj(cLeft - cRight,this);
				break;
			case 7:
				o = new object_NumberObj(cLeft * cRight,this);
				break;
			case 8:
				o = new object_NumberObj(cLeft / cRight,this);
				break;
			case 9:
				o = new object_NumberObj((cLeft | 0) & (cRight | 0),this);
				break;
			case 10:
				o = new object_NumberObj(cLeft | 0 | (cRight | 0),this);
				break;
			case 11:
				o = new object_NumberObj((cLeft | 0) ^ (cRight | 0),this);
				break;
			case 12:
				o = new object_NumberObj((cLeft | 0) << (cRight | 0),this);
				break;
			case 13:
				o = new object_NumberObj((cLeft | 0) >> (cRight | 0),this);
				break;
			case 15:
				o = new object_NumberObj(cLeft % cRight,this);
				break;
			case 17:
				o = new object_BooleanObj(cLeft < cRight,this);
				break;
			case 18:
				o = new object_BooleanObj(cLeft <= cRight,this);
				break;
			case 19:
				o = new object_BooleanObj(cLeft > cRight,this);
				break;
			case 20:
				o = new object_BooleanObj(cLeft >= cRight,this);
				break;
			default:
				o = new object_NullObj(this);
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(o,_this.head);
			break;
		case 14:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var notValue = o;
			if(notValue.type == object_ObjectType.Number) {
				var value = (js_Boot.__cast(notValue , object_NumberObj)).value;
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_NumberObj(~(value | 0),this),_this.head);
			} else {
				this.error.error("cannot perform operation");
			}
			break;
		case 16:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var right = o;
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var left = o;
			var equals = left.equals(right);
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_BooleanObj(equals,this),_this.head);
			break;
		case 21:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var negValue = o;
			if(negValue.type == object_ObjectType.Number) {
				var value = (js_Boot.__cast(negValue , object_NumberObj)).value;
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_NumberObj(-value,this),_this.head);
			} else {
				this.error.error("only numbers can be negated");
			}
			break;
		case 22:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var invValue = o;
			if(invValue.type == object_ObjectType.Boolean) {
				var value = (js_Boot.__cast(invValue , object_BooleanObj)).value;
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_BooleanObj(!value,this),_this.head);
			} else {
				this.error.error("only booleans can be inverted");
			}
			break;
		case 23:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var right = o.toString();
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var left = o.toString();
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_StringObj("" + left + right,this),_this.head);
			break;
		case 24:
			var localIndex = this.instructions.readInt32();
			var value = this.currentFrame.getVariable(localIndex);
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(value,_this.head);
			break;
		case 25:
			var localIndex = this.instructions.readInt32();
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var value = o;
			this.currentFrame.setVariable(localIndex,value);
			break;
		case 26:
			var builtInIndex = this.instructions.readInt32();
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(this.builtInTable.resolveIndex(builtInIndex),_this.head);
			break;
		case 27:
			var callParametersCount = this.instructions.readInt32();
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var object = o;
			if(object.type._hx_index == 7) {
				var cClosure = js_Boot.__cast(object , object_ClosureObj);
				this.pushFrame(cClosure.context,this.instructions.pos,cClosure.func);
				if(cClosure.func.parametersCount != callParametersCount) {
					this.error.error("wrong number of arguments to function. expected " + cClosure.func.parametersCount + ", got " + callParametersCount);
				}
				switch(cClosure.func.type._hx_index) {
				case 5:
					var cBuiltInFunction = js_Boot.__cast(cClosure.func , object_BuiltInFunctionObj);
					this.builtInTable.callFunction(cBuiltInFunction);
					break;
				case 6:
					var cUserFunction = js_Boot.__cast(cClosure.func , object_UserFunctionObj);
					this.instructions.set_position(cUserFunction.position);
					break;
				default:
				}
			} else {
				this.error.error("object is not a function");
			}
			break;
		case 28:
			var frame = this.popFrame();
			this.instructions.set_position(frame.returnAddress);
			if(frame.expectedStackSize > Lambda.count(this.stack)) {
				var _this = this.stack;
				_this.head = new haxe_ds_GenericCell(new object_NullObj(this),_this.head);
			}
			break;
		case 29:
			var arrayLength = this.instructions.readInt32();
			var arrayValues = [];
			var _g = 0;
			var _g1 = arrayLength;
			while(_g < _g1) {
				var _ = _g++;
				var _this = this.stack;
				var k = _this.head;
				var o;
				if(k == null) {
					o = null;
				} else {
					_this.head = k.next;
					o = k.elt;
				}
				if(o == null) {
					this.error.error("failed to evaluate expression");
				}
				arrayValues.push(o);
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_ArrayObj(arrayValues,this),_this.head);
			break;
		case 30:
			var hashLength = this.instructions.readInt32();
			var hashValues = new haxe_ds_StringMap();
			var _g = 0;
			var _g1 = hashLength;
			while(_g < _g1) {
				var _ = _g++;
				var _this = this.stack;
				var k = _this.head;
				var o;
				if(k == null) {
					o = null;
				} else {
					_this.head = k.next;
					o = k.elt;
				}
				if(o == null) {
					this.error.error("failed to evaluate expression");
				}
				var value = o;
				var _this1 = this.stack;
				var k1 = _this1.head;
				var o1;
				if(k1 == null) {
					o1 = null;
				} else {
					_this1.head = k1.next;
					o1 = k1.elt;
				}
				if(o1 == null) {
					this.error.error("failed to evaluate expression");
				}
				var key = o1;
				if(key.type == object_ObjectType.String) {
					hashValues.h[(js_Boot.__cast(key , object_StringObj)).value] = value;
				} else {
					this.error.error("hash key must be a string");
				}
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(new object_HashObj(hashValues,this),_this.head);
			break;
		case 31:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var index = o;
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var target = o;
			var value;
			var _g = index.type;
			switch(target.type._hx_index) {
			case 3:
				switch(_g._hx_index) {
				case 0:
					var cTarget = js_Boot.__cast(target , object_ArrayObj);
					var cIndex = js_Boot.__cast(index , object_NumberObj);
					value = cTarget.value[cIndex.value | 0];
					break;
				case 2:
					var cIndex = js_Boot.__cast(index , object_StringObj);
					value = target.getMembers().value.h[cIndex.value];
					break;
				default:
					value = new object_NullObj(this);
				}
				break;
			case 4:
				if(_g._hx_index == 2) {
					var cTarget = js_Boot.__cast(target , object_HashObj);
					var cIndex = js_Boot.__cast(index , object_StringObj);
					var value1 = cTarget.value.h[cIndex.value];
					if(value1 == null) {
						value1 = cTarget.getMembers().value.h[cIndex.value];
					}
					value = value1;
				} else {
					value = new object_NullObj(this);
				}
				break;
			default:
				if(_g._hx_index == 2) {
					var cIndex = js_Boot.__cast(index , object_StringObj);
					value = target.getMembers().value.h[cIndex.value];
				} else {
					value = new object_NullObj(this);
				}
			}
			var _this = this.stack;
			_this.head = new haxe_ds_GenericCell(value == null ? new object_NullObj(this) : value,_this.head);
			break;
		case 32:
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var value = o;
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var index = o;
			var _this = this.stack;
			var k = _this.head;
			var o;
			if(k == null) {
				o = null;
			} else {
				_this.head = k.next;
				o = k.elt;
			}
			if(o == null) {
				this.error.error("failed to evaluate expression");
			}
			var target = o;
			var _g = index.type;
			switch(target.type._hx_index) {
			case 3:
				switch(_g._hx_index) {
				case 0:
					var cTarget = js_Boot.__cast(target , object_ArrayObj);
					var cIndex = js_Boot.__cast(index , object_NumberObj);
					cTarget.value[cIndex.value | 0] = value;
					break;
				case 2:
					var cIndex = js_Boot.__cast(index , object_StringObj);
					target.getMembers().value.h[cIndex.value] = value;
					break;
				default:
					this.error.error("index operator cannot be used on this datatype");
				}
				break;
			case 4:
				if(_g._hx_index == 2) {
					var cTarget = js_Boot.__cast(target , object_HashObj);
					var cIndex = js_Boot.__cast(index , object_StringObj);
					cTarget.value.h[cIndex.value] = value;
				} else {
					this.error.error("index operator cannot be used on this datatype");
				}
				break;
			default:
				if(_g._hx_index == 2) {
					var cIndex = js_Boot.__cast(index , object_StringObj);
					target.getMembers().value.h[cIndex.value] = value;
				} else {
					this.error.error("index operator cannot be used on this datatype");
				}
			}
			break;
		default:
		}
	}
	,__class__: vm_VirtualMachine
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b,gray>><//> ";
Console.warnPrefix = "<b,yellow>><//> ";
Console.errorPrefix = "<b,red>></b> ";
Console.successPrefix = "<b,light_green>><//> ";
Console.debugPrefix = "<b,magenta>><//> ";
Console.argSeparator = " ";
Console.unicodeCompatibilityMode = 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
FormatFlag.RESET = "reset";
FormatFlag.BOLD = "bold";
FormatFlag.ITALIC = "italic";
FormatFlag.DIM = "dim";
FormatFlag.UNDERLINE = "underline";
FormatFlag.BLINK = "blink";
FormatFlag.INVERT = "invert";
FormatFlag.HIDDEN = "hidden";
FormatFlag.BLACK = "black";
FormatFlag.RED = "red";
FormatFlag.GREEN = "green";
FormatFlag.YELLOW = "yellow";
FormatFlag.BLUE = "blue";
FormatFlag.MAGENTA = "magenta";
FormatFlag.CYAN = "cyan";
FormatFlag.WHITE = "white";
FormatFlag.LIGHT_BLACK = "light_black";
FormatFlag.LIGHT_RED = "light_red";
FormatFlag.LIGHT_GREEN = "light_green";
FormatFlag.LIGHT_YELLOW = "light_yellow";
FormatFlag.LIGHT_BLUE = "light_blue";
FormatFlag.LIGHT_MAGENTA = "light_magenta";
FormatFlag.LIGHT_CYAN = "light_cyan";
FormatFlag.LIGHT_WHITE = "light_white";
FormatFlag.BG_BLACK = "bg_black";
FormatFlag.BG_RED = "bg_red";
FormatFlag.BG_GREEN = "bg_green";
FormatFlag.BG_YELLOW = "bg_yellow";
FormatFlag.BG_BLUE = "bg_blue";
FormatFlag.BG_MAGENTA = "bg_magenta";
FormatFlag.BG_CYAN = "bg_cyan";
FormatFlag.BG_WHITE = "bg_white";
FormatFlag.BG_LIGHT_BLACK = "bg_light_black";
FormatFlag.BG_LIGHT_RED = "bg_light_red";
FormatFlag.BG_LIGHT_GREEN = "bg_light_green";
FormatFlag.BG_LIGHT_YELLOW = "bg_light_yellow";
FormatFlag.BG_LIGHT_BLUE = "bg_light_blue";
FormatFlag.BG_LIGHT_MAGENTA = "bg_light_magenta";
FormatFlag.BG_LIGHT_CYAN = "bg_light_cyan";
FormatFlag.BG_LIGHT_WHITE = "bg_light_white";
Snekky.Version = "0.9.0 [7ee57c9] (2021-05-27)";
build_Version.SemVersion = "0.9.0";
code_OpCode.Constant = 0;
code_OpCode.Pop = 1;
code_OpCode.Jump = 2;
code_OpCode.JumpNot = 3;
code_OpCode.JumpPeek = 4;
code_OpCode.Add = 5;
code_OpCode.Subtract = 6;
code_OpCode.Multiply = 7;
code_OpCode.Divide = 8;
code_OpCode.BitAnd = 9;
code_OpCode.BitOr = 10;
code_OpCode.BitXor = 11;
code_OpCode.BitShiftLeft = 12;
code_OpCode.BitShiftRight = 13;
code_OpCode.BitNot = 14;
code_OpCode.Modulo = 15;
code_OpCode.Equals = 16;
code_OpCode.LessThan = 17;
code_OpCode.LessThanOrEqual = 18;
code_OpCode.GreaterThan = 19;
code_OpCode.GreaterThanOrEqual = 20;
code_OpCode.Negate = 21;
code_OpCode.Not = 22;
code_OpCode.ConcatString = 23;
code_OpCode.Load = 24;
code_OpCode.Store = 25;
code_OpCode.LoadBuiltIn = 26;
code_OpCode.Call = 27;
code_OpCode.Return = 28;
code_OpCode.Array = 29;
code_OpCode.Hash = 30;
code_OpCode.LoadIndex = 31;
code_OpCode.StoreIndex = 32;
compiler_constant_ConstantType.Float = 0;
compiler_constant_ConstantType.String = 1;
compiler_constant_ConstantType.UserFunction = 2;
compiler_constant_ConstantType.Null = 3;
compiler_constant_ConstantType.Boolean = 4;
error_CompileError.init = Console.logPrefix = "";
haxe_io_FPHelper.i64tmp = (function($this) {
	var $r;
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	$r = this1;
	return $r;
}(this));
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
lexer_Keyword.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["func"] = lexer_TokenType.Function;
	_g.h["let"] = lexer_TokenType.Let;
	_g.h["mut"] = lexer_TokenType.Mut;
	_g.h["true"] = lexer_TokenType.True;
	_g.h["false"] = lexer_TokenType.False;
	_g.h["if"] = lexer_TokenType.If;
	_g.h["else"] = lexer_TokenType.Else;
	_g.h["while"] = lexer_TokenType.While;
	_g.h["return"] = lexer_TokenType.Return;
	_g.h["import"] = lexer_TokenType.Import;
	_g.h["break"] = lexer_TokenType.Break;
	_g.h["continue"] = lexer_TokenType.Continue;
	_g.h["null"] = lexer_TokenType.Null;
	_g.h["for"] = lexer_TokenType.For;
	_g.h["in"] = lexer_TokenType.In;
	_g.h["when"] = lexer_TokenType.When;
	$r = _g;
	return $r;
}(this));
std_lib_namespaces_MathNamespace.$name = "Math";
std_lib_namespaces_NumberNamespace.$name = "Number";
std_lib_namespaces_ObjectNamespace.$name = "Object";
std_lib_namespaces_RangeNamespace.$name = "Range";
std_lib_namespaces_RegexNamespace.$name = "Regex";
std_lib_namespaces_StringNamespace.$name = "String";
std_lib_namespaces_SysNamespace.$name = "Sys";
std_lib_namespaces_io_IoNamespace.$name = "Io";
std_lib_namespaces_json_JsonNamespace.$name = "Json";
Snekky.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
